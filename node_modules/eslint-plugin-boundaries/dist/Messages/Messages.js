"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceObjectValuesInTemplates = replaceObjectValuesInTemplates;
exports.replaceObjectValuesInTemplate = replaceObjectValuesInTemplate;
exports.quote = quote;
exports.micromatchPatternReplacingObjectsValues = micromatchPatternReplacingObjectsValues;
exports.ruleElementMessage = ruleElementMessage;
exports.customErrorMessage = customErrorMessage;
exports.elementMessage = elementMessage;
exports.dependencyImportKindMessage = dependencyImportKindMessage;
exports.dependencyUsageKindMessage = dependencyUsageKindMessage;
const elements_1 = require("@boundaries/elements");
const Support_1 = require("../Support");
function replaceObjectValueInTemplate(template, key, value, namespace) {
    const keyToReplace = namespace ? `${namespace}.${key}` : key;
    const regexp = new RegExp(`\\$\\{${keyToReplace}\\}`, "g");
    return template.replace(regexp, value);
}
function replaceObjectValuesInTemplates(strings, object, namespace) {
    const finalResult = (0, Support_1.isArray)(strings) ? [...strings] : strings;
    return Object.keys(object).reduce((result, objectKey) => {
        // If template is an array, replace key by value in all patterns
        if ((0, Support_1.isArray)(result)) {
            return result.map((resultEntry) => {
                return replaceObjectValueInTemplate(resultEntry, objectKey, object[objectKey], namespace);
            });
        }
        return replaceObjectValueInTemplate(result, objectKey, object[objectKey], namespace);
    }, finalResult);
}
function replaceObjectValuesInTemplate(template, object, namespace) {
    return replaceObjectValuesInTemplates(template, object, namespace);
}
function quote(str) {
    return `'${str || ""}'`;
}
function typeMessage(elementMatcher) {
    return `elements of type ${quote(elementMatcher)}`;
}
function categoryMessage(category) {
    return `category ${quote(category)}`;
}
function propertiesConcatenator(properties, index) {
    if (properties.length > 1 && index === properties.length - 1) {
        return " and";
    }
    if (index === 0) {
        return " with";
    }
    return ",";
}
function micromatchPatternReplacingObjectsValues(pattern, object) {
    let patternToReplace = pattern;
    if (!patternToReplace) {
        return "";
    }
    // Backward compatibility. Possibly unused, because the value is already replaced in the next step.
    // For the moment, keep it to avoid unexpected issues until the oncoming refactor.
    if (object.from) {
        patternToReplace = replaceObjectValuesInTemplates(patternToReplace, object.from);
    }
    return Object.keys(object).reduce((replacedPattern, namespace) => {
        if (!object[namespace]) {
            return replacedPattern;
        }
        return replaceObjectValuesInTemplates(replacedPattern, object[namespace] || {}, namespace);
    }, patternToReplace);
}
function micromatchPatternMessage(micromatchPatterns, elementCapturedValues) {
    const micromatchPatternsWithValues = micromatchPatternReplacingObjectsValues(micromatchPatterns, { from: elementCapturedValues || {} });
    if ((0, Support_1.isArray)(micromatchPatternsWithValues)) {
        if (micromatchPatternsWithValues.length === 1) {
            return quote(micromatchPatternsWithValues[0]);
        }
        return micromatchPatternsWithValues.reduce((message, micromatchPattern, index) => {
            if (index === 0) {
                return quote(micromatchPattern);
            }
            if (index === micromatchPatternsWithValues.length - 1) {
                return `${message} or ${quote(micromatchPattern)}`;
            }
            return `${message}, ${quote(micromatchPattern)}`;
        }, "");
    }
    return quote(micromatchPatternsWithValues);
}
function capturedValuesMatcherMessage(capturedValuesPattern, elementCapturedValues) {
    const capturedValuesPatternKeys = Object.keys(capturedValuesPattern || {});
    return capturedValuesPatternKeys
        .map((key) => {
        return [key, capturedValuesPattern?.[key]];
    })
        .reduce((message, propertyNameAndMatcher, index) => {
        return `${message}${propertiesConcatenator(capturedValuesPatternKeys, index)} ${propertyNameAndMatcher[0]
        // TODO: Support array patterns
        } ${micromatchPatternMessage(propertyNameAndMatcher[1], elementCapturedValues)}`;
    }, "");
}
function elementMatcherMessage(elementMatcher, elementCapturedValues) {
    if (!elementMatcher) {
        return "";
    }
    if ((0, elements_1.isElementSelector)(elementMatcher)) {
        const selector = (0, elements_1.normalizeElementsSelector)(elementMatcher);
        const parts = [];
        const toAdd = [];
        if (selector[0].type) {
            // @ts-expect-error Types have to be aligned properly
            toAdd.push(typeMessage(selector[0].type));
        }
        if (selector[0].category) {
            toAdd.push(propertiesConcatenator(parts, parts.length + toAdd.length + 1), 
            // @ts-expect-error Types have to be aligned properly
            categoryMessage(selector[0].category));
        }
        if (selector[0].captured) {
            toAdd.push(capturedValuesMatcherMessage(selector[0].captured, elementCapturedValues));
        }
        parts.push(...toAdd);
        return parts.map((part) => part.trim()).join(" ");
    }
    // Backward compatibility. Code should not reach here normally.
    if ((0, Support_1.isString)(elementMatcher)) {
        return typeMessage(elementMatcher);
    }
    // TODO: Support array patterns
    return `${typeMessage(elementMatcher[0])}${capturedValuesMatcherMessage(elementMatcher[1], elementCapturedValues)}`;
}
function ruleElementMessage(elementPatterns, elementCapturedValues) {
    if ((0, Support_1.isArray)(elementPatterns)) {
        if (elementPatterns.length === 1) {
            return elementMatcherMessage(elementPatterns[0], elementCapturedValues);
        }
        return elementPatterns.reduce((message, elementPattern, index) => {
            if (index === 0) {
                return elementMatcherMessage(elementPattern, elementCapturedValues);
            }
            return `${message}, or ${elementMatcherMessage(elementPattern, elementCapturedValues)}`;
        }, "");
    }
    return elementMatcherMessage(elementPatterns, elementCapturedValues);
}
function elementPropertiesToReplaceInTemplate(element, importKind) {
    if ((0, elements_1.isElementDescription)(element)) {
        return {
            ...element.captured,
            type: element.type || "",
            internalPath: element.internalPath || "",
            source: element.source || "",
            importKind: importKind || "",
        };
    }
    return {
        ...element.captured,
        type: element.type || "",
        internalPath: "",
        source: "",
        importKind: importKind || "",
    };
}
function customErrorMessage(message, dependency, report = {}) {
    let replacedMessage = replaceObjectValuesInTemplate(replaceObjectValuesInTemplate(message, elementPropertiesToReplaceInTemplate(dependency.from, dependency.dependency.kind), "file"), elementPropertiesToReplaceInTemplate(dependency.to, dependency.dependency.kind), "dependency");
    replacedMessage = replaceObjectValuesInTemplate(replaceObjectValuesInTemplate(replacedMessage, elementPropertiesToReplaceInTemplate(dependency.from, dependency.dependency.kind), "from"), elementPropertiesToReplaceInTemplate(dependency.to, dependency.dependency.kind), "target");
    if (dependency.from.parents?.[0]) {
        replacedMessage = replaceObjectValuesInTemplate(replacedMessage, elementPropertiesToReplaceInTemplate(dependency.from.parents?.[0], dependency.dependency.kind), "file.parent");
        replacedMessage = replaceObjectValuesInTemplate(replacedMessage, elementPropertiesToReplaceInTemplate(dependency.from.parents?.[0], dependency.dependency.kind), "from.parent");
    }
    if (dependency.to.parents?.[0]) {
        replacedMessage = replaceObjectValuesInTemplate(replacedMessage, elementPropertiesToReplaceInTemplate(dependency.to.parents?.[0], dependency.dependency.kind), "dependency.parent");
        replacedMessage = replaceObjectValuesInTemplate(replacedMessage, elementPropertiesToReplaceInTemplate(dependency.to.parents?.[0], dependency.dependency.kind), "target.parent");
    }
    return replaceObjectValuesInTemplate(replacedMessage, report, "report");
}
function elementCapturedValuesMessage(capturedValues) {
    if (!capturedValues) {
        return "";
    }
    const capturedValuesKeys = Object.keys(capturedValues);
    return capturedValuesKeys
        .map((key) => {
        return [key, capturedValues[key]];
    })
        .reduce((message, propertyNameAndValue, index) => {
        return `${message}${propertiesConcatenator(capturedValuesKeys, index)} ${propertyNameAndValue[0]} ${quote(propertyNameAndValue[1])}`;
    }, "");
}
function elementMessage(elementInfo) {
    return `of type ${quote(elementInfo.type)}${elementCapturedValuesMessage(elementInfo.captured)}`;
}
function hasToPrintKindMessage(ruleImportKind, dependency) {
    return ruleImportKind && dependency.dependency.kind;
}
function dependencyImportKindMessage(ruleImportKind, dependency) {
    if (hasToPrintKindMessage(ruleImportKind, dependency)) {
        return `kind ${quote(dependency.dependency.kind)} from `;
    }
    return "";
}
function dependencyUsageKindMessage(ruleImportKind, dependency, { suffix = " ", prefix = "", } = {}) {
    if (hasToPrintKindMessage(ruleImportKind, dependency)) {
        return `${prefix}${dependency.dependency.kind}${suffix}`;
    }
    return "";
}
