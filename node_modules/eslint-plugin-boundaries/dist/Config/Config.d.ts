import type { Linter } from "eslint";
import type { PluginBoundaries, Config } from "../Settings";
import { PLUGIN_NAME } from "../Settings";
export * from "../Public";
type PluginFullConfig<PluginName extends string = typeof PLUGIN_NAME> = {
    plugins: Record<PluginName, PluginBoundaries>;
    files: Linter.Config["files"];
} & Omit<Config<PluginName>, "plugins">;
/**
 * Returns an ESLint config object with the boundaries plugin registered, providing default JS and TS file patterns
 * and enforcing valid types for settings and rules. Supports renaming the plugin. Rules can be prefixed with either
 * the original plugin name or the provided plugin name.
 *
 * @param config - ESLint config object without the plugins field.
 * @param name - The name of the plugin to register. Defaults to "boundaries".
 * @returns {Linter.Config} The ESLint config object with the boundaries plugin registered and the provided config merged in.
 * @throws {Error} If settings or rules are not from eslint-plugin-boundaries.
 *
 * @example
 * ```ts
 * import { createConfig, recommended } from "eslint-plugin-boundaries/config";
 *
 * const config = createConfig({
 *   settings: {
 *     ...recommended.settings,
 *     "boundaries/elements": [],
 *     "boundaries/ignore": ["ignored/*.js"],
 *   },
 *   rules: {
 *     ...recommended.rules,
 *     "boundaries/element-types": ["error", { default: "disallow" }],
 *   }
 * });
 *
 * export default [config];
 * ```
 */
export declare function createConfig<PluginName extends string = typeof PLUGIN_NAME>(config: Omit<Config<PluginName> | Config, "plugins">, name?: PluginName): PluginFullConfig<PluginName>;
export declare const recommended: Config<"boundaries">;
export declare const strict: Config<"boundaries">;
