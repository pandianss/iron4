"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRulesResults = getRulesResults;
exports.elementRulesAllowDependency = elementRulesAllowDependency;
const elements_1 = require("@boundaries/elements");
const micromatch_1 = __importDefault(require("micromatch"));
const Elements_1 = require("../Elements");
const Messages_1 = require("../Messages");
const Settings_1 = require("../Settings");
const Support_1 = require("../Support");
const Support_2 = require("./Support");
const { RULE_ELEMENT_TYPES } = Settings_1.SETTINGS;
/**
 * Safely matches a dependency selector, catching and logging any errors
 */
function createSafeMatcherFunction(dependencyDescription, matcher) {
    return (dependencySelector, extraTemplateData, dependencySelectorsGlobals) => {
        // Just in case selectors are invalid, we catch errors here to avoid breaking the whole rule evaluation
        try {
            return matcher.getSelectorMatchingDescription(dependencyDescription, dependencySelector, {
                extraTemplateData,
                dependencySelectorsGlobals,
            });
        }
        catch (error) {
            (0, Support_1.warnOnce)(`Error occurred while matching dependency with selector ${JSON.stringify(dependencySelector)}: ${String(error)}`);
            return { isMatch: false, from: null, to: null };
        }
    };
}
/**
 * Determines the rule matching context (directions, template data, etc.)
 */
function createRuleMatchContext(rule, dependencyDescription) {
    const targetElementDirection = rule.from ? "from" : "to";
    const policyElementDirection = rule.from ? "to" : "from";
    const denyKeyToUse = rule.deny ? "deny" : "disallow";
    const capturedValuesTemplateData = targetElementDirection === "from"
        ? {
            ...dependencyDescription.from.captured,
            from: dependencyDescription.from.captured,
            to: dependencyDescription.to.captured,
        }
        : {
            ...dependencyDescription.to.captured,
            from: dependencyDescription.from.captured,
            to: dependencyDescription.to.captured,
        };
    const dependencySelectorsGlobals = rule.importKind ? { kind: rule.importKind } : {};
    const targetElementSelector = rule[targetElementDirection];
    return {
        targetElementDirection,
        policyElementDirection,
        denyKeyToUse,
        capturedValuesTemplateData,
        dependencySelectorsGlobals,
        targetElementSelector,
    };
}
/**
 * Evaluates both deny and allow policy matches for a rule
 */
function evaluatePolicyMatches(rule, context, isMatch, settings) {
    const { targetElementDirection, policyElementDirection, denyKeyToUse, capturedValuesTemplateData, dependencySelectorsGlobals, targetElementSelector, } = context;
    const templateData = settings.legacyTemplates
        ? capturedValuesTemplateData
        : {};
    const disallowPolicyMatches = rule[denyKeyToUse]
        ? isMatch({
            [targetElementDirection]: targetElementSelector,
            [policyElementDirection]: rule[denyKeyToUse],
        }, templateData, dependencySelectorsGlobals)
        : { isMatch: false };
    const allowPolicyMatches = !disallowPolicyMatches.isMatch && rule.allow
        ? isMatch({
            [targetElementDirection]: targetElementSelector,
            [policyElementDirection]: rule.allow,
        }, templateData, dependencySelectorsGlobals)
        : { isMatch: false };
    return { disallowPolicyMatches, allowPolicyMatches };
}
/**
 * Creates rule selectors data based on policy matches
 */
function createRuleSelectorsData(rule, context, disallowPolicyMatches, allowPolicyMatches) {
    const { targetElementDirection, policyElementDirection, denyKeyToUse } = context;
    const allowPolicyMatchesIsMatch = allowPolicyMatches.isMatch;
    const disallowPolicyMatchesIsMatch = disallowPolicyMatches.isMatch;
    const targetSelector = disallowPolicyMatchesIsMatch || allowPolicyMatchesIsMatch
        ? context.targetElementSelector
        : null;
    let policySelector = null;
    if (disallowPolicyMatchesIsMatch) {
        policySelector = rule[denyKeyToUse];
    }
    else if (allowPolicyMatchesIsMatch) {
        policySelector = rule.allow;
    }
    let selectorsData = null;
    if (disallowPolicyMatchesIsMatch) {
        selectorsData = disallowPolicyMatches;
    }
    else if (allowPolicyMatchesIsMatch) {
        selectorsData = allowPolicyMatches;
    }
    return {
        selectors: {
            [targetElementDirection]: targetSelector,
            [policyElementDirection]: policySelector,
        },
        selectorsData,
    };
}
function getRulesResults(ruleOptions, dependencyDescription, matcher, settings) {
    if (!ruleOptions.rules) {
        return [];
    }
    const isMatch = createSafeMatcherFunction(dependencyDescription, matcher);
    return ruleOptions.rules.map((rule, index) => {
        const context = createRuleMatchContext(rule, dependencyDescription);
        const { disallowPolicyMatches, allowPolicyMatches } = evaluatePolicyMatches(rule, context, isMatch, settings);
        const selectorsMatching = createRuleSelectorsData(rule, context, disallowPolicyMatches, allowPolicyMatches);
        return {
            index,
            // @ts-expect-error Workaround to support both allow and disallow in the same entry point rule
            originalRuleIndex: rule.originalRuleIndex,
            selectorsMatching,
            ruleHasImportKind: !!rule.importKind,
            allowPolicyMatches,
            denyPolicyMatches: disallowPolicyMatches,
        };
    });
}
/**
 * Determines the rule result based on policy matches
 */
function determineRuleResult(rulesResults) {
    let isAllowed = false;
    let ruleIndexMatching = null;
    for (const ruleResult of rulesResults) {
        if (ruleResult.denyPolicyMatches.isMatch) {
            isAllowed = false;
            ruleIndexMatching = ruleResult.index;
        }
        else if (ruleResult.allowPolicyMatches.isMatch) {
            isAllowed = true;
            ruleIndexMatching = ruleResult.index;
        }
    }
    return { isAllowed, ruleIndexMatching };
}
/**
 * Gets the message for the rule, prioritizing rule-specific messages
 */
function getRuleMessage(ruleIndexMatching, ruleOptions) {
    return ((ruleIndexMatching === null
        ? ruleOptions.message
        : ruleOptions.rules?.[ruleIndexMatching]?.message) || ruleOptions.message);
}
/**
 * Gets specifiers that match the rule for error reporting
 */
function getMatchingSpecifiers(ruleIndexMatching, rulesResults, dependency) {
    if (ruleIndexMatching === null)
        return null;
    const selectorDataSpecifiers = 
    // @ts-expect-error TODO: Align types. At this point, selectorsData.to must always be defined, because otherwise isMatch would be false
    rulesResults[ruleIndexMatching].selectorsMatching?.selectorsData?.to
        ?.specifiers;
    if (!selectorDataSpecifiers) {
        return null;
    }
    if ((0, Support_1.isString)(selectorDataSpecifiers)) {
        const hasMatchingSpecifier = dependency.dependency.specifiers?.some((specifier) => micromatch_1.default.isMatch(specifier, selectorDataSpecifiers));
        return hasMatchingSpecifier ? [selectorDataSpecifiers] : null;
    }
    return selectorDataSpecifiers.filter((pattern) => {
        return dependency.dependency.specifiers?.some((specifier) => micromatch_1.default.isMatch(specifier, pattern));
    });
}
/**
 * Creates the rule report object
 */
function createRuleReport(ruleIndexMatching, message, dependency, rulesResults) {
    if (ruleIndexMatching === null) {
        return {
            message,
            isDefault: true,
            importKind: undefined,
            disallow: dependency.to,
            element: dependency.from,
            index: -1,
        };
    }
    return {
        message,
        isDefault: false,
        importKind: rulesResults[ruleIndexMatching].ruleHasImportKind
            ? dependency.dependency.kind
            : undefined,
        disallow: rulesResults[ruleIndexMatching].selectorsMatching?.selectors.to,
        element: rulesResults[ruleIndexMatching].selectorsMatching?.selectors.from,
        index: rulesResults[ruleIndexMatching].originalRuleIndex ?? ruleIndexMatching,
    };
}
/**
 * Determines the report path for error reporting
 */
function getReportPath(ruleIndexMatching, rulesResults, dependency) {
    return ruleIndexMatching === null ||
        // @ts-expect-error TODO: Align types. At this point, selectorsData should always be defined
        !rulesResults[ruleIndexMatching].selectorsMatching?.selectorsData?.to
            ?.internalPath
        ? null
        : dependency.to.internalPath;
}
function elementRulesAllowDependency(dependency, settings, ruleOptions = {}) {
    const defaultIsAllowed = ruleOptions.default === "allow";
    const matcher = (0, Elements_1.getElementsMatcher)(settings);
    const rulesResults = getRulesResults(ruleOptions, dependency, matcher, settings);
    const { isAllowed, ruleIndexMatching } = determineRuleResult(rulesResults);
    const finalIsAllowed = ruleIndexMatching === null ? defaultIsAllowed : isAllowed;
    if (finalIsAllowed) {
        return {
            result: finalIsAllowed,
            ruleReport: null,
            report: null,
        };
    }
    const message = getRuleMessage(ruleIndexMatching, ruleOptions);
    const ruleReport = createRuleReport(ruleIndexMatching, message, dependency, rulesResults);
    const reportPath = getReportPath(ruleIndexMatching, rulesResults, dependency);
    const result = {
        result: finalIsAllowed,
        // @ts-expect-error Temporary workaround for RuleResult type until types are aligned
        ruleReport,
        report: {
            specifiers: getMatchingSpecifiers(ruleIndexMatching, rulesResults, dependency) ||
                undefined,
            path: reportPath,
        },
    };
    return result;
}
function errorMessage(ruleData, dependency) {
    const ruleReport = ruleData.ruleReport;
    if (!ruleReport) {
        return `No detailed rule report available. This is likely a bug in ${Settings_1.PLUGIN_NAME}. Please report it at ${Settings_1.PLUGIN_ISSUES_URL}`;
    }
    if (ruleReport.message) {
        return (0, Messages_1.customErrorMessage)(ruleReport.message, dependency);
    }
    if (ruleReport.isDefault) {
        return `No rule allowing this dependency was found. File is ${(0, Messages_1.elementMessage)(dependency.from)}. Dependency is ${(0, Messages_1.elementMessage)(dependency.to)}`;
    }
    return `Importing ${(0, Messages_1.dependencyImportKindMessage)(ruleReport.importKind, dependency)}${(0, Messages_1.ruleElementMessage)(ruleReport.disallow, dependency.from.captured)} is not allowed in ${(0, Messages_1.ruleElementMessage)(ruleReport.element, dependency.from.captured)}. Disallowed in rule ${ruleReport.index + 1}`;
}
exports.default = (0, Support_2.dependencyRule)({
    ruleName: RULE_ELEMENT_TYPES,
    description: `Check allowed dependencies between element types`,
    schema: (0, Settings_1.rulesOptionsSchema)(),
}, function ({ dependency, node, context, settings, options }) {
    // TODO: Remove these checks when allowing to use more selectors in ESLint rules
    if ((0, elements_1.isLocalElement)(dependency.to) &&
        !(0, elements_1.isIgnoredElement)(dependency.to) &&
        !(0, elements_1.isUnknownLocalElement)(dependency.to) &&
        !(0, elements_1.isInternalDependency)(dependency)) {
        const ruleData = elementRulesAllowDependency(dependency, settings, options);
        if (!ruleData.result) {
            context.report({
                message: errorMessage(ruleData, dependency),
                node,
            });
        }
    }
});
