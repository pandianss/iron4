"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const elements_1 = require("@boundaries/elements");
const Messages_1 = require("../Messages");
const Settings_1 = require("../Settings");
const Support_1 = require("./Support");
const { RULE_NO_PRIVATE } = Settings_1.SETTINGS;
function errorMessage(dependency, options) {
    if (options?.message) {
        return (0, Messages_1.customErrorMessage)(options.message, dependency);
    }
    // @ts-expect-error could not be defined. TODO: I have to decide whether to unify properties in all elements, or to use type guards
    return `Dependency is private of element ${(0, Messages_1.elementMessage)(dependency.to.parents?.[0])}`;
}
exports.default = (0, Support_1.dependencyRule)({
    ruleName: RULE_NO_PRIVATE,
    description: `Prevent importing private elements of another element`,
    schema: [
        {
            type: "object",
            properties: {
                allowUncles: {
                    type: "boolean",
                },
                message: {
                    type: "string",
                },
            },
            additionalProperties: false,
        },
    ],
}, function ({ dependency, node, context, options }) {
    if (!dependency.to.isIgnored &&
        (0, elements_1.isLocalDependencyElement)(dependency.to) &&
        dependency.to.type &&
        dependency.to.parents.length &&
        dependency.dependency.relationship.to !==
            elements_1.DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL &&
        dependency.dependency.relationship.to !==
            elements_1.DEPENDENCY_RELATIONSHIPS_MAP.CHILD &&
        dependency.dependency.relationship.to !==
            elements_1.DEPENDENCY_RELATIONSHIPS_MAP.SIBLING &&
        (!options?.allowUncles ||
            dependency.dependency.relationship.to !==
                elements_1.DEPENDENCY_RELATIONSHIPS_MAP.UNCLE)) {
        context.report({
            message: errorMessage(dependency, options),
            node: node,
        });
    }
}, {
    validate: false,
});
