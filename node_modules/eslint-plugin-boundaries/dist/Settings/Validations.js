"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.elementsMatcherSchema = elementsMatcherSchema;
exports.rulesOptionsSchema = rulesOptionsSchema;
exports.validateElementTypesMatcher = validateElementTypesMatcher;
exports.isValidElementAssigner = isValidElementAssigner;
exports.validateSettings = validateSettings;
exports.getSettings = getSettings;
exports.validateRules = validateRules;
const elements_1 = require("@boundaries/elements");
const micromatch_1 = __importDefault(require("micromatch"));
const Common_1 = require("../Support/Common");
const Debug_1 = require("../Support/Debug");
const Helpers_1 = require("./Helpers");
const Settings_1 = require("./Settings");
const Settings_types_1 = require("./Settings.types");
const { TYPES, ALIAS, ELEMENTS, DEPENDENCY_NODES, ADDITIONAL_DEPENDENCY_NODES, VALID_DEPENDENCY_NODE_KINDS, DEFAULT_DEPENDENCY_NODES, VALID_MODES, } = Settings_types_1.SETTINGS;
const DEFAULT_MATCHER_OPTIONS = {
    type: "object",
};
function elementsMatcherSchema(matcherOptions = DEFAULT_MATCHER_OPTIONS) {
    return {
        oneOf: [
            {
                type: "string", // single matcher
            },
            {
                type: "array", // multiple matchers
                items: {
                    oneOf: [
                        {
                            type: "string", // matcher with options
                        },
                        {
                            type: "array",
                            items: [
                                {
                                    type: "string", // matcher
                                },
                                matcherOptions, // options
                            ],
                        },
                    ],
                },
            },
        ],
    };
}
function rulesOptionsSchema(options = {}) {
    const mainKey = (0, Helpers_1.rulesMainKey)(options.rulesMainKey);
    return [
        {
            type: "object",
            properties: {
                message: {
                    type: "string",
                },
                default: {
                    type: "string",
                    enum: ["allow", "disallow"],
                },
                rules: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            [mainKey]: elementsMatcherSchema(),
                            allow: elementsMatcherSchema(options.targetMatcherOptions),
                            disallow: elementsMatcherSchema(options.targetMatcherOptions),
                            importKind: {
                                oneOf: [
                                    {
                                        type: "string",
                                    },
                                    {
                                        type: "array",
                                        items: {
                                            type: "string",
                                        },
                                    },
                                ],
                            },
                            message: {
                                type: "string",
                            },
                        },
                        additionalProperties: false,
                        anyOf: [
                            {
                                required: [mainKey, "allow", "disallow"],
                            },
                            {
                                required: [mainKey, "allow"],
                            },
                            {
                                required: [mainKey, "disallow"],
                            },
                        ],
                    },
                },
            },
            additionalProperties: false,
        },
    ];
}
function isValidElementTypesMatcher(matcher, settings) {
    const matcherToCheck = (0, Common_1.isArray)(matcher)
        ? matcher[0]
        : matcher;
    return (!matcherToCheck ||
        (matcherToCheck &&
            micromatch_1.default.some(settings.elementTypeNames, matcherToCheck)));
}
/**
 * Checks if the value is a single matcher with options (tuple of [string, object])
 */
function isSingleMatcherWithOptions(value) {
    return ((0, Common_1.isArray)(value) &&
        value.length === 2 &&
        (0, Common_1.isString)(value[0]) &&
        (0, Common_1.isObject)(value[1]));
}
// TODO: Remove this validation. Selectors should not be limited to element types defined in settings when using selector objects
function validateElementTypesMatcher(elementsMatcher, settings) {
    // Handle empty array case
    if ((0, Common_1.isArray)(elementsMatcher) && elementsMatcher.length === 0) {
        return;
    }
    // Determine if it's a single matcher or an array of matchers
    let matcher;
    if ((0, Common_1.isString)(elementsMatcher)) {
        matcher = elementsMatcher;
    }
    else if (isSingleMatcherWithOptions(elementsMatcher)) {
        // It's a single matcher with options: ["type", { option: value }]
        matcher = elementsMatcher;
    }
    else if ((0, Common_1.isArray)(elementsMatcher)) {
        // It's an array of matchers: ["helpers", "components"] or [["helpers", {...}], "components"]
        // NOTE: Validate only the first matcher. It is wrong, but we don't want to impact performance, and anyway it was already validating only the first one.
        // In next major version, validation will be removed, because schema validation will handle it.
        matcher = elementsMatcher[0];
    }
    else {
        (0, Debug_1.warnOnce)(`Option is not a valid elements selector: '${JSON.stringify(elementsMatcher)}'`);
        return;
    }
    // Validate the matcher
    if (!isValidElementTypesMatcher(matcher, settings)) {
        (0, Debug_1.warnOnce)(`Option '${JSON.stringify(matcher)}' does not match any element type from '${ELEMENTS}' setting`);
    }
}
function isValidElementAssigner(element) {
    if (!element) {
        (0, Debug_1.warnOnce)(`Please provide a valid object to define element types in '${ELEMENTS}' setting`);
        return false;
    }
    if ((0, Helpers_1.isLegacyType)(element)) {
        (0, Debug_1.warnOnce)(`Defining elements as strings in settings is deprecated. Will be automatically converted, but this feature will be removed in next major versions`);
        return true;
    }
    else {
        const isObjectElement = (0, Common_1.isObject)(element);
        if (!isObjectElement) {
            (0, Debug_1.warnOnce)(`Please provide a valid object to define element types in '${ELEMENTS}' setting`);
            return false;
        }
        if (!element.type || !(0, Common_1.isString)(element.type)) {
            (0, Debug_1.warnOnce)(`Please provide type in '${ELEMENTS}' setting`);
            return false;
        }
        if (element.mode &&
            (0, Common_1.isString)(element.mode) &&
            !VALID_MODES.includes(element.mode)) {
            (0, Debug_1.warnOnce)(`Invalid mode property of type ${element.type} in '${ELEMENTS}' setting. Should be one of ${VALID_MODES.join(",")}. Default value "${VALID_MODES[0]}" will be used instead`);
            return false;
        }
        if (!element.pattern ||
            !((0, Common_1.isString)(element.pattern) || (0, Common_1.isArray)(element.pattern))) {
            (0, Debug_1.warnOnce)(`Please provide a valid pattern to type ${element.type} in '${ELEMENTS}' setting`);
            return false;
        }
        if (element.capture && !(0, Common_1.isArray)(element.capture)) {
            (0, Debug_1.warnOnce)(`Invalid capture property of type ${element.type} in '${ELEMENTS}' setting`);
            return false;
        }
        return true;
    }
}
function validateElements(elements) {
    if (!elements || !(0, Common_1.isArray)(elements) || !elements.length) {
        (0, Debug_1.warnOnce)(`Please provide element types using the '${ELEMENTS}' setting`);
        return;
    }
    return elements.filter(isValidElementAssigner);
}
function validateDependencyNodes(dependencyNodes) {
    if (!dependencyNodes) {
        return;
    }
    const defaultNodesNames = Object.keys(DEFAULT_DEPENDENCY_NODES);
    const invalidFormatMessage = [
        `Please provide a valid value in ${DEPENDENCY_NODES} setting.`,
        `The value should be an array of the following strings:`,
        ` "${defaultNodesNames.join('", "')}".`,
    ].join(" ");
    if (!(0, Common_1.isArray)(dependencyNodes)) {
        (0, Debug_1.warnOnce)(invalidFormatMessage);
        return;
    }
    for (const dependencyNode of dependencyNodes) {
        if (!(0, Helpers_1.isDependencyNodeKey)(dependencyNode)) {
            (0, Debug_1.warnOnce)(invalidFormatMessage);
        }
    }
    return dependencyNodes.filter(Helpers_1.isDependencyNodeKey);
}
/**
 * Validates the legacyTemplates setting.
 * @param legacyTemplates The legacyTemplates setting value
 * @returns The validated legacyTemplates value or undefined
 */
function validateLegacyTemplates(
/** The legacyTemplates setting value */
legacyTemplates) {
    if (legacyTemplates === undefined) {
        return;
    }
    if ((0, Common_1.isBoolean)(legacyTemplates)) {
        return legacyTemplates;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES}' setting. The value should be a boolean.`);
}
function isValidDependencyNodeSelector(selector) {
    const isValidObject = (0, Common_1.isObject)(selector) &&
        (0, Common_1.isString)(selector.selector) &&
        (!selector.kind ||
            ((0, Common_1.isString)(selector.kind) &&
                VALID_DEPENDENCY_NODE_KINDS.includes(selector.kind)));
    if (!isValidObject) {
        (0, Debug_1.warnOnce)(`Please provide a valid object in ${ADDITIONAL_DEPENDENCY_NODES} setting. The object should be composed of the following properties: { selector: "<esquery selector>", kind: "value" | "type" }. The invalid object will be ignored.`);
    }
    return isValidObject;
}
function validateAdditionalDependencyNodes(additionalDependencyNodes) {
    if (!additionalDependencyNodes) {
        return;
    }
    const invalidFormatMessage = [
        `Please provide a valid value in ${ADDITIONAL_DEPENDENCY_NODES} setting.`,
        "The value should be an array composed of the following objects:",
        '{ selector: "<esquery selector>", kind: "value" | "type" }.',
    ].join(" ");
    if (!(0, Common_1.isArray)(additionalDependencyNodes)) {
        (0, Debug_1.warnOnce)(invalidFormatMessage);
        return;
    }
    return additionalDependencyNodes.filter(isValidDependencyNodeSelector);
}
function deprecateAlias(aliases) {
    if (aliases) {
        (0, Debug_1.warnOnce)(`Defining aliases in '${ALIAS}' setting is deprecated. Please use 'import/resolver' setting`);
    }
}
function deprecateTypes(types) {
    if (types) {
        (0, Debug_1.warnOnce)(`'${TYPES}' setting is deprecated. Please use '${ELEMENTS}' instead`);
    }
}
function validateIgnore(ignore) {
    if (!ignore) {
        return;
    }
    if ((0, Common_1.isString)(ignore) || ((0, Common_1.isArray)(ignore) && ignore.every(Common_1.isString))) {
        return ignore;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.IGNORE}' setting. The value should be a string or an array of strings.`);
}
function validateInclude(include) {
    if (!include) {
        return;
    }
    if ((0, Common_1.isString)(include) || ((0, Common_1.isArray)(include) && include.every(Common_1.isString))) {
        return include;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE}' setting. The value should be a string or an array of strings.`);
}
function validateRootPath(rootPath) {
    if (!rootPath) {
        return;
    }
    if ((0, Common_1.isString)(rootPath)) {
        return rootPath;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.ROOT_PATH}' setting. The value should be a string.`);
}
// TODO: Remove settings validation in next major version. It should be done by schema validation only
function validateSettings(settings) {
    deprecateTypes(settings[TYPES]);
    deprecateAlias(settings[ALIAS]);
    return {
        [Settings_types_1.SETTINGS_KEYS_MAP.ELEMENTS]: validateElements(settings[ELEMENTS] || settings[TYPES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.IGNORE]: validateIgnore(settings[Settings_types_1.SETTINGS_KEYS_MAP.IGNORE]),
        [Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE]: validateInclude(settings[Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE]),
        [Settings_types_1.SETTINGS_KEYS_MAP.ROOT_PATH]: validateRootPath(settings[Settings_types_1.SETTINGS_KEYS_MAP.ROOT_PATH]),
        [Settings_types_1.SETTINGS_KEYS_MAP.DEPENDENCY_NODES]: validateDependencyNodes(settings[DEPENDENCY_NODES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES]: validateLegacyTemplates(settings[Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.ADDITIONAL_DEPENDENCY_NODES]: validateAdditionalDependencyNodes(settings[ADDITIONAL_DEPENDENCY_NODES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.CACHE]: settings[Settings_types_1.SETTINGS_KEYS_MAP.CACHE],
    };
}
/**
 * Returns the normalized settings from the ESLint rule context
 * @param context The ESLint rule context
 * @returns The normalized settings
 */
function getSettings(context) {
    const validatedSettings = validateSettings(context.settings);
    const dependencyNodesSetting = (0, Common_1.getArrayOrNull)(validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.DEPENDENCY_NODES]);
    const additionalDependencyNodesSetting = (0, Common_1.getArrayOrNull)(validatedSettings[ADDITIONAL_DEPENDENCY_NODES]);
    const dependencyNodes = 
    // TODO In next major version, make this default to all types of nodes!!!
    (dependencyNodesSetting || [Settings_types_1.DEPENDENCY_NODE_KEYS_MAP.IMPORT])
        .flatMap((dependencyNode) => [
        ...DEFAULT_DEPENDENCY_NODES[dependencyNode],
    ])
        .filter(Boolean);
    const additionalDependencyNodes = additionalDependencyNodesSetting || [];
    const ignoreSetting = validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.IGNORE];
    const ignorePaths = (0, Common_1.isString)(ignoreSetting) ? [ignoreSetting] : ignoreSetting;
    const includeSetting = validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE];
    const includePaths = (0, Common_1.isString)(includeSetting)
        ? [includeSetting]
        : includeSetting;
    const descriptors = (0, Settings_1.transformLegacyTypes)(validatedSettings[ELEMENTS]);
    // NOTE: Filter valid descriptors only to avoid a breaking change for the moment
    const validDescriptors = descriptors.filter(elements_1.isElementDescriptor);
    const invalidDescriptors = descriptors.filter((desc) => !(0, elements_1.isElementDescriptor)(desc));
    if (invalidDescriptors.length > 0) {
        /*
         * TODO: Report invalid descriptors in ESLint context as a warning in a separate rule:
         * context.report({
         * message: `Some element descriptors are invalid and will be ignored: ${JSON.stringify(
         *   invalidDescriptors,
         * )}`,
         * loc: { line: 1, column: 0 },
         * });
         */
        (0, Debug_1.warnOnce)(`Some element descriptors are invalid and will be ignored: ${JSON.stringify(invalidDescriptors)}`);
    }
    const result = {
        elementDescriptors: validDescriptors,
        elementTypeNames: (0, Settings_1.getElementsTypeNames)(validDescriptors),
        ignorePaths,
        includePaths,
        rootPath: (0, Settings_1.getRootPath)(validatedSettings),
        dependencyNodes: [...dependencyNodes, ...additionalDependencyNodes],
        legacyTemplates: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES] ??
            Settings_types_1.LEGACY_TEMPLATES_DEFAULT,
        cache: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.CACHE] ?? Settings_types_1.CACHE_DEFAULT,
    };
    return result;
}
function validateRules(settings, rules = [], options = {}) {
    const mainKey = (0, Helpers_1.rulesMainKey)(options.mainKey);
    for (const rule of rules) {
        //@ts-expect-error TODO: Add a different schema validation for each rule type, so keys are properly validated
        validateElementTypesMatcher([rule[mainKey]], settings);
        if (!options.onlyMainKey) {
            if (rule.allow) {
                validateElementTypesMatcher(rule.allow, settings);
            }
            if (rule.disallow) {
                validateElementTypesMatcher(rule.disallow, settings);
            }
        }
    }
}
