import type { DependencyKind, ElementDescriptors, ElementsSelector, CapturedValues, ExternalLibrariesSelector } from "@boundaries/elements";
import type { ESLint, Linter, Rule } from "eslint";
export declare const PLUGIN_NAME: "boundaries";
export declare const PLUGIN_ENV_VARS_PREFIX: "ESLINT_PLUGIN_BOUNDARIES";
export declare const REPO_URL: "https://github.com/javierbrea/eslint-plugin-boundaries";
export declare const WEBSITE_URL: "https://www.jsboundaries.dev";
export declare const PLUGIN_ISSUES_URL: "https://github.com/javierbrea/eslint-plugin-boundaries/issues";
export declare const DEPENDENCY_NODE_REQUIRE: "require";
export declare const DEPENDENCY_NODE_IMPORT: "import";
export declare const DEPENDENCY_NODE_DYNAMIC_IMPORT: "dynamic-import";
export declare const DEPENDENCY_NODE_EXPORT: "export";
export declare const ELEMENT_TYPES: "element-types";
export declare const ENTRY_POINT: "entry-point";
export declare const EXTERNAL: "external";
export declare const NO_IGNORED: "no-ignored";
export declare const NO_PRIVATE: "no-private";
export declare const NO_UNKNOWN_FILES: "no-unknown-files";
export declare const NO_UNKNOWN: "no-unknown";
/**
 * Map of all rule short names, without the plugin prefix.
 */
export declare const RULE_SHORT_NAMES_MAP: {
    readonly ELEMENT_TYPES: "element-types";
    readonly ENTRY_POINT: "entry-point";
    readonly EXTERNAL: "external";
    readonly NO_IGNORED: "no-ignored";
    readonly NO_PRIVATE: "no-private";
    readonly NO_UNKNOWN_FILES: "no-unknown-files";
    readonly NO_UNKNOWN: "no-unknown";
};
/**
 * Map of all rule names, including the default plugin prefix.
 */
export declare const RULE_NAMES_MAP: {
    readonly ELEMENT_TYPES: "boundaries/element-types";
    readonly ENTRY_POINT: "boundaries/entry-point";
    readonly EXTERNAL: "boundaries/external";
    readonly NO_IGNORED: "boundaries/no-ignored";
    readonly NO_PRIVATE: "boundaries/no-private";
    readonly NO_UNKNOWN_FILES: "boundaries/no-unknown-files";
    readonly NO_UNKNOWN: "boundaries/no-unknown";
};
/**
 * List of all rule names
 */
export declare const RULE_NAMES: readonly ("boundaries/element-types" | "boundaries/entry-point" | "boundaries/external" | "boundaries/no-ignored" | "boundaries/no-private" | "boundaries/no-unknown-files" | "boundaries/no-unknown")[];
/**
 * Type representing all valid rule names, including the default plugin prefix.
 */
export type RuleName = (typeof RULE_NAMES)[number];
/**
 * List of all rule names, including the default plugin prefix.
 */
export type RuleNames = typeof RULE_NAMES;
/**
 * List of all rule short names, without the plugin prefix.
 */
export declare const RULE_SHORT_NAMES: readonly ("external" | "element-types" | "entry-point" | "no-ignored" | "no-private" | "no-unknown-files" | "no-unknown")[];
/**
 * Type representing all valid rule short names, without the plugin prefix.
 */
export type RuleShortName = (typeof RULE_SHORT_NAMES)[number];
/**
 * List of all rule short names, without the plugin prefix.
 */
export type RuleShortNames = typeof RULE_SHORT_NAMES;
/**
 * Main key used in rule definitions.
 */
export declare const FROM: "from";
/**
 * Different types of dependency nodes supported by the plugin by default.
 * Each type corresponds to a common way of importing or requiring modules in JavaScript/TypeScript.
 */
export declare const DEPENDENCY_NODE_KEYS_MAP: {
    /**
     * CommonJS require statements, e.g., `const module = require('module')`.
     */
    readonly REQUIRE: "require";
    /**
     * ES6 import statements, e.g., `import module from 'module'`.
     */
    readonly IMPORT: "import";
    /**
     * Dynamic import statements, e.g., `import('module')`.
     */
    readonly DYNAMIC_IMPORT: "dynamic-import";
    /**
     * Export statements, e.g., `export { module } from 'source'`.
     */
    readonly EXPORT: "export";
};
/**
 * Keys of the different types of dependency nodes supported by the plugin by default.
 */
export type DependencyNodeKey = (typeof DEPENDENCY_NODE_KEYS_MAP)[keyof typeof DEPENDENCY_NODE_KEYS_MAP];
/**
 * Additional custom dependency node selector to consider when analyzing dependencies.
 * Each entry defines a selector and its kind (either 'type' or 'value').
 * This allows for extending the default dependency nodes with project-specific patterns.
 */
export type DependencyNodeSelector = {
    /** A selector string to identify the dependency node in the AST */
    selector: string;
    /** The kind of import, either 'type' or 'value' */
    kind: DependencyKind;
    /** Name to assign to the dependency node. Useful to identify the kind of node selector in rules */
    name?: string;
};
export declare const SETTINGS: {
    readonly ELEMENTS: "boundaries/elements";
    readonly IGNORE: "boundaries/ignore";
    readonly INCLUDE: "boundaries/include";
    readonly ROOT_PATH: "boundaries/root-path";
    readonly DEPENDENCY_NODES: "boundaries/dependency-nodes";
    readonly ADDITIONAL_DEPENDENCY_NODES: "boundaries/additional-dependency-nodes";
    readonly LEGACY_TEMPLATES: "boundaries/legacy-templates";
    readonly CACHE: "boundaries/cache";
    readonly DEBUG: "ESLINT_PLUGIN_BOUNDARIES_DEBUG";
    readonly ENV_ROOT_PATH: "ESLINT_PLUGIN_BOUNDARIES_ROOT_PATH";
    readonly RULE_ELEMENT_TYPES: "boundaries/element-types";
    readonly RULE_ENTRY_POINT: "boundaries/entry-point";
    readonly RULE_EXTERNAL: "boundaries/external";
    readonly RULE_NO_IGNORED: "boundaries/no-ignored";
    readonly RULE_NO_PRIVATE: "boundaries/no-private";
    readonly RULE_NO_UNKNOWN_FILES: "boundaries/no-unknown-files";
    readonly RULE_NO_UNKNOWN: "boundaries/no-unknown";
    readonly TYPES: "boundaries/types";
    readonly ALIAS: "boundaries/alias";
    readonly VALID_MODES: readonly ["folder", "file", "full"];
    readonly VALID_DEPENDENCY_NODE_KINDS: readonly ["value", "type", "typeof"];
    readonly DEFAULT_DEPENDENCY_NODES: {
        readonly require: readonly [{
            readonly selector: "CallExpression[callee.name=require] > Literal";
            readonly kind: "value";
        }];
        readonly import: readonly [{
            readonly selector: "ImportDeclaration:not([importKind=type]) > Literal";
            readonly kind: "value";
        }, {
            readonly selector: "ImportDeclaration[importKind=type] > Literal";
            readonly kind: "type";
        }];
        readonly "dynamic-import": readonly [{
            readonly selector: "ImportExpression > Literal";
            readonly kind: "value";
        }];
        readonly export: readonly [{
            readonly selector: "ExportAllDeclaration:not([exportKind=type]) > Literal";
            readonly kind: "value";
        }, {
            readonly selector: "ExportAllDeclaration[exportKind=type] > Literal";
            readonly kind: "type";
        }, {
            readonly selector: "ExportNamedDeclaration:not([exportKind=type]) > Literal";
            readonly kind: "value";
        }, {
            readonly selector: "ExportNamedDeclaration[exportKind=type] > Literal";
            readonly kind: "type";
        }];
    };
};
/**
 * Map of the valid keys for the plugin settings.
 */
export declare const SETTINGS_KEYS_MAP: {
    readonly ELEMENTS: "boundaries/elements";
    readonly IGNORE: "boundaries/ignore";
    readonly INCLUDE: "boundaries/include";
    readonly ROOT_PATH: "boundaries/root-path";
    readonly DEPENDENCY_NODES: "boundaries/dependency-nodes";
    readonly ADDITIONAL_DEPENDENCY_NODES: "boundaries/additional-dependency-nodes";
    readonly LEGACY_TEMPLATES: "boundaries/legacy-templates";
    /** @deprecated Use 'ELEMENTS' instead */
    readonly TYPES: "boundaries/types";
    /** @deprecated Use import/resolver settings instead */
    readonly ALIAS: "boundaries/alias";
    readonly CACHE: "boundaries/cache";
};
/**
 * Default value for the legacy templates setting.
 */
export declare const LEGACY_TEMPLATES_DEFAULT: true;
/**
 * Default value for the cache setting.
 */
export declare const CACHE_DEFAULT: true;
/**
 * Valid keys for the plugin settings.
 */
export type SettingsKey = (typeof SETTINGS_KEYS_MAP)[keyof typeof SETTINGS_KEYS_MAP];
/**
 * List of glob patterns to include when analyzing dependencies.
 * If specified, only files matching these patterns will be included in the plugin analysis.
 */
export type IncludeSetting = string | string[];
/**
 * List of glob patterns to ignore when analyzing dependencies.
 * Files matching these patterns will be excluded from the plugin analysis.
 */
export type IgnoreSetting = string | string[];
/**
 * Root path of the project. This is used to resolve relative paths in element patterns.
 * Can also be set via the ESLINT_PLUGIN_BOUNDARIES_ROOT_PATH environment variable.
 */
export type RootPathSetting = string;
/**
 * Alias settings to define path aliases for module resolution.
 * Each key is an alias and its value is the corresponding path.
 * @deprecated Use "import/resolver" settings instead
 */
export type AliasSetting = Record<string, string>;
/**
 * Settings for the eslint-plugin-boundaries plugin.
 */
export type Settings = {
    /**
     * Element descriptors to define the different elements (or layers) in your project.
     * Each element descriptor includes a type, a pattern to match files, and optional settings like mode and capture groups.
     */
    [SETTINGS_KEYS_MAP.ELEMENTS]?: ElementDescriptors;
    /**
     * List of glob patterns to ignore when analyzing dependencies.
     * Files matching these patterns will be excluded from the plugin analysis.
     */
    [SETTINGS_KEYS_MAP.IGNORE]?: IgnoreSetting;
    /**
     * List of glob patterns to include when analyzing dependencies.
     * If specified, only files matching these patterns will be included in the plugin analysis.
     */
    [SETTINGS_KEYS_MAP.INCLUDE]?: IncludeSetting;
    /**
     * Root path of the project. This is used to resolve relative paths in element patterns.
     * Can also be set via the ESLINT_PLUGIN_BOUNDARIES_ROOT_PATH environment variable.
     */
    [SETTINGS_KEYS_MAP.ROOT_PATH]?: RootPathSetting;
    /**
     * Specifies which dependency nodes (import types) to consider when analyzing dependencies.
     * Each key corresponds to a type of dependency node (e.g., import, require, dynamic-import, export) and maps to an array of selectors defining how to identify those nodes in the AST.
     * If not specified, only 'import' nodes will be considered by default.
     */
    [SETTINGS_KEYS_MAP.DEPENDENCY_NODES]?: DependencyNodeKey[];
    /**
     * Additional custom dependency node selectors to consider when analyzing dependencies.
     * Each entry defines a selector and its kind (either 'type' or 'value').
     * This allows for extending the default dependency nodes with project-specific patterns.
     */
    [SETTINGS_KEYS_MAP.ADDITIONAL_DEPENDENCY_NODES]?: DependencyNodeSelector[];
    /**
     * Whether to enable legacy template syntax support (default: `true`, but it will be `false` in future major releases).
     * This enables:
     * - Using `${variable}` syntax in templates for backward compatibility
     * - Passing captured values from elements to template data at first object level. This might override existing keys in the elements data objects.
     */
    [SETTINGS_KEYS_MAP.LEGACY_TEMPLATES]?: boolean;
    /** @deprecated Use "boundaries/elements" setting instead */
    [SETTINGS_KEYS_MAP.TYPES]?: ElementDescriptors;
    /** @deprecated Use "import/resolver" setting instead */
    [SETTINGS_KEYS_MAP.ALIAS]?: AliasSetting;
    /** Whether to enable caching for the plugin analysis */
    [SETTINGS_KEYS_MAP.CACHE]?: boolean;
};
/**
 * Normalized settings for the eslint-plugin-boundaries plugin.
 * All settings have default values applied.
 */
export type SettingsNormalized = {
    /** Element descriptors */
    elementDescriptors: ElementDescriptors;
    /** Element type names extracted from the descriptors. Used to validate selectors defined as strings in rules */
    elementTypeNames: string[];
    /** List of glob patterns to ignore when analyzing dependencies */
    ignorePaths: string[] | undefined;
    /** List of glob patterns to include when analyzing dependencies */
    includePaths: string[] | undefined;
    /** Root path of the project */
    rootPath: string;
    /** Dependency nodes to consider when analyzing dependencies */
    dependencyNodes: DependencyNodeSelector[];
    /** Whether legacy template syntax support is enabled */
    legacyTemplates: boolean;
    /** Whether caching is enabled */
    cache: boolean;
};
/**
 * Eslint boundaries plugin rules.
 * By default, rule names are prefixed with "boundaries/", but it can be customized via the `PluginName` generic parameter.
 *
 * @template PluginName - The name of the plugin, defaults to "boundaries". It defines the prefix for the rule names.
 */
export type Rules<PluginName extends string = typeof PLUGIN_NAME> = {
    [K in `${PluginName}/${typeof ELEMENT_TYPES | typeof ENTRY_POINT | typeof EXTERNAL | typeof NO_IGNORED | typeof NO_PRIVATE | typeof NO_UNKNOWN_FILES | typeof NO_UNKNOWN}`]?: K extends `${PluginName}/${typeof ELEMENT_TYPES}` ? Linter.RuleEntry<ElementTypesRuleOptions[]> : K extends `${PluginName}/${typeof ENTRY_POINT}` ? Linter.RuleEntry<EntryPointRuleOptions[]> : K extends `${PluginName}/${typeof EXTERNAL}` ? Linter.RuleEntry<ExternalRuleOptions[]> : K extends `${PluginName}/${typeof NO_PRIVATE}` ? Linter.RuleEntry<NoPrivateOptions[]> : Linter.RuleEntry<never>;
};
/**
 * ESLint configuration with optional settings and rules specific to the boundaries plugin.
 */
export interface Config<PluginName extends string = typeof PLUGIN_NAME> extends Linter.Config {
    /**
     * Optional settings specific to the boundaries plugin.
     */
    settings?: Settings;
    /**
     * Optional rules specific to the boundaries plugin.
     */
    rules?: Rules<PluginName>;
}
/**
 * ESLint plugin interface for the boundaries plugin, including metadata, rules, and configurations.
 */
export interface PluginBoundaries extends ESLint.Plugin {
    meta: {
        name: string;
        version: string;
    };
    rules: Record<RuleShortName, Rule.RuleModule>;
    configs: {
        recommended: Config;
        strict: Config;
    };
}
export type RuleMetaDefinition = {
    type?: Rule.RuleMetaData["type"];
    /** The description of the rule */
    description: string;
    /** The name of the rule */
    ruleName: RuleName;
    /** The schema of the rule options */
    schema?: Rule.RuleMetaData["schema"];
};
export declare const RULE_POLICY_ALLOW: "allow";
export declare const RULE_POLICY_DISALLOW: "disallow";
/**
 * Map containing the available rule policies.
 */
export declare const RULE_POLICIES_MAP: {
    readonly ALLOW: "allow";
    readonly DISALLOW: "disallow";
};
/**
 * Policy for rules, either allowing or disallowing certain dependencies.
 */
export type RulePolicy = (typeof RULE_POLICIES_MAP)[keyof typeof RULE_POLICIES_MAP];
/**
 * Base options for some rules, including default policy and custom message.
 */
export type RuleBaseOptions = {
    /** Default policy for all the rules (allow or disallow) */
    default?: RulePolicy;
    /** Custom message for all rule violations. It can be overridden at the rule level. */
    message?: string;
};
export type RuleReport = {
    message?: string;
    isDefault?: boolean;
    importKind?: DependencyKind;
    disallow?: ElementsSelector;
    element: ElementsSelector;
    index: number;
};
export type RuleResultReport = {
    path: string | null;
    specifiers?: string[];
};
export type RuleResult = {
    result: boolean;
    ruleReport: RuleReport | null;
    report: RuleResultReport | null;
};
export type RuleMatcherElementsCapturedValues = {
    from: CapturedValues;
    target: CapturedValues;
};
/**
 * Rule that defines allowed or disallowed dependencies between different element types.
 */
export type ElementTypesRule = {
    /** Selectors of the source elements that the rule applies to (the elements importing) */
    from?: ElementsSelector;
    /** Selectors of the target elements that are disallowed to be imported */
    to?: ElementsSelector;
    /** Selectors of the elements that are disallowed to be imported */
    disallow?: ElementsSelector;
    /** Selectors of the elements that are allowed to be imported */
    allow?: ElementsSelector;
    /** Kind of import that the rule applies to (e.g., "type", "value") */
    importKind?: DependencyKind;
    /** Custom message for rule violations */
    message?: string;
};
/**
 * Options for the element-types rule, including default policy and specific rules.
 */
export type ElementTypesRuleOptions = Omit<RuleBaseOptions, "rules"> & {
    /** Specific rules for defining boundaries between elements */
    rules?: ElementTypesRule[];
};
/**
 * Rule that defines entry points for specific element types, controlling which files can be imported.
 */
export type EntryPointRule = {
    /** Selectors of the elements that the rule applies to (the elements being imported) */
    target: ElementsSelector;
    /** Micromatch patterns of the files that are disallowed to import from other elements. Relative to the element path */
    disallow?: string[];
    /** Micromatch patterns of the files that are allowed to import from other elements. Relative to the element path */
    allow?: string[];
    /** Kind of import that the rule applies to (e.g., "type", "value") */
    importKind?: DependencyKind;
    /** Custom message for rule violations */
    message?: string;
};
/**
 * Options for the entry-point rule, including default policy and specific rules.
 */
export type EntryPointRuleOptions = Omit<RuleBaseOptions, "rules"> & {
    /** Specific rules for defining entry points between elements */
    rules?: EntryPointRule[];
};
/**
 * Rule that defines allowed or disallowed external library imports for specific element types.
 */
export type ExternalRule = {
    /** Selectors of the source elements that the rule applies to (the elements importing) */
    from: ElementsSelector;
    /** Selectors of the external libraries that are disallowed to be imported */
    disallow?: ExternalLibrariesSelector;
    /** Selectors of the external libraries that are allowed to be imported */
    allow?: ExternalLibrariesSelector;
    /** Kind of import that the rule applies to (e.g., "type", "value") */
    importKind?: DependencyKind;
    /** Custom message for rule violations */
    message?: string;
};
/**
 * Options for the external rule, including default policy and specific rules.
 */
export type ExternalRuleOptions = Omit<RuleBaseOptions, "rules"> & {
    /** Specific rules for defining allowed or disallowed external library imports */
    rules?: ExternalRule[];
};
/**
 * Options for the no-private rule, which restricts imports of private elements.
 * Private elements are those that are children of another elements in the folder structure.
 * This rules enables that private elements can't be used by anyone except its parent (or any other descendant of the parent when `allowUncles` option is enabled)
 */
export type NoPrivateOptions = {
    /** Whether to allow imports from "uncle" elements (elements sharing the same ancestor) */
    allowUncles?: boolean;
    /** Custom message for rule violations */
    message?: string;
};
export type RuleOptionsWithRules = ExternalRuleOptions | EntryPointRuleOptions | ElementTypesRuleOptions;
export type RuleOptions = RuleOptionsWithRules | NoPrivateOptions;
export type RuleOptionsRules = ExternalRule | EntryPointRule | ElementTypesRule;
export type RuleMainKey = "from" | "to" | "target";
export type ValidateRulesOptions = {
    mainKey?: RuleMainKey;
    onlyMainKey?: boolean;
};
