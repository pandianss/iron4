var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/Config/Config.ts
var Config = class {
  /** The ignore paths */
  _ignorePaths;
  /** The include paths */
  _includePaths;
  /** Whether legacy template support is enabled */
  _legacyTemplates;
  /** Whether the cache is enabled */
  _cache;
  /**
   * Creates a new Config instance
   * @param options Configuration options
   */
  constructor(options) {
    this._ignorePaths = options?.ignorePaths;
    this._includePaths = options?.includePaths;
    this._legacyTemplates = options?.legacyTemplates ?? true;
    this._cache = options?.cache ?? true;
  }
  /**
   * The normalized configuration options
   */
  get options() {
    return {
      ignorePaths: this._ignorePaths,
      includePaths: this._includePaths,
      legacyTemplates: this._legacyTemplates,
      cache: this._cache
    };
  }
  /**
   * Normalized options for descriptors
   */
  get descriptorOptions() {
    return {
      ignorePaths: this._ignorePaths,
      includePaths: this._includePaths,
      cache: this._cache
    };
  }
  /**
   * Normalized options for element matchers
   */
  get matchersOptions() {
    return {
      legacyTemplates: this._legacyTemplates
    };
  }
  /**
   * Whether caching is enabled
   */
  get cache() {
    return this._cache;
  }
};

// src/Matcher/BaseElementsMatcher.ts
import Handlebars from "handlebars";

// src/Support/TypeGuards.ts
function isString(value) {
  return typeof value === "string";
}
function isNullish(value) {
  return value === null || value === void 0;
}
function isNull(value) {
  return value === null;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isObject(value) {
  return !isNullish(value) && !isBoolean(value) && !isArray(value) && typeof value === "object";
}
function isEmptyObject(obj) {
  return isObject(obj) && Object.keys(obj).length === 0;
}
function isArray(value) {
  return Array.isArray(value);
}
function isEmptyArray(arr) {
  return arr.length === 0;
}
function isStringArray(value) {
  return isArray(value) && value.every(isString);
}
function isObjectWithProperty(value, key) {
  return isObject(value) && Object.hasOwn(value, key);
}
function isObjectWithAnyOfProperties(value, keys) {
  return isObject(value) && keys.some((key) => key in value);
}

// src/Matcher/MatcherHelpers.ts
function isCapturedValuesSelector(value) {
  if (!isObject(value) || isArray(value)) {
    return false;
  }
  return Object.values(value).every(
    (pattern) => isString(pattern) || isStringArray(pattern)
  );
}
function isSimpleElementSelectorByType(value) {
  return isString(value);
}
function isBaseElementSelectorData(value) {
  return isObjectWithAnyOfProperties(value, [
    "path",
    "elementPath",
    "internalPath",
    "type",
    "category",
    "captured",
    "origin",
    "source",
    "baseSource",
    "isIgnored",
    "isUnknown"
  ]);
}
function isElementSelectorData(value) {
  return isBaseElementSelectorData(value) || isObjectWithAnyOfProperties(value, [
    "relationship",
    "kind",
    "specifiers",
    "nodeKind"
  ]);
}
function isElementSelectorWithLegacyOptions(value) {
  return isArray(value) && (value.length === 2 && isSimpleElementSelectorByType(value[0]) && // NOTE: Arrays of length 2 with captured values selector as second element having a key "type" or "category" will be treated as legacy options instead of two different selectors. We have to live with this limitation for now.
  isCapturedValuesSelector(value[1]) || // NOTE: Backwards compatibility: Allow arrays of length 1 with simple element selector. Some users might defined arrays without options.
  value.length === 1 && isSimpleElementSelectorByType(value[0]));
}
function isElementSelector(value) {
  return isSimpleElementSelectorByType(value) || isElementSelectorData(value) || isElementSelectorWithLegacyOptions(value);
}
function isElementsSelector(value) {
  return isElementSelector(value) || isArray(value) && !isEmptyArray(value) && value.every(isElementSelector);
}
function isDependencySelector(value) {
  return isObjectWithAnyOfProperties(value, ["from", "to"]);
}
function isExternalLibrarySelectorOptionsWithPath(value) {
  return isObjectWithProperty(value, "path") && (isString(value.path) || isStringArray(value.path));
}
function isExternalLibrarySelectorOptionsWithSpecifiers(value) {
  return isObjectWithProperty(value, "specifiers") && isStringArray(value.specifiers);
}
function isExternalLibrarySelectorOptions(value) {
  return isExternalLibrarySelectorOptionsWithPath(value) || isExternalLibrarySelectorOptionsWithSpecifiers(value);
}
function isExternalLibrarySelectorWithOptions(value) {
  return isArray(value) && value.length === 2 && isSimpleElementSelectorByType(value[0]) && isExternalLibrarySelectorOptions(value[1]);
}
function isExternalLibrarySelector(value) {
  return isSimpleElementSelectorByType(value) || isExternalLibrarySelectorWithOptions(value);
}
function isExternalLibrariesSelector(value) {
  return isExternalLibrarySelector(value) || isArray(value) && !isEmptyArray(value) && value.every(isExternalLibrarySelector);
}

// src/Matcher/BaseElementsMatcher.ts
var HANDLEBARS_TEMPLATE_REGEX = /{{\s*[^}\s]+(?:\s+[^}\s]+)*\s*}}/;
var LEGACY_TEMPLATE_REGEX = /\$\{([^}]+)\}/g;
function normalizeSelector(selector) {
  if (isSimpleElementSelectorByType(selector)) {
    return { type: selector };
  }
  if (isElementSelectorData(selector)) {
    return { ...selector };
  }
  if (isElementSelectorWithLegacyOptions(selector)) {
    return {
      type: selector[0],
      captured: selector[1] ? { ...selector[1] } : void 0
    };
  }
  throw new Error("Invalid element selector");
}
function normalizeElementsSelector(elementsSelector) {
  if (isArray(elementsSelector)) {
    if (isElementSelectorWithLegacyOptions(elementsSelector)) {
      return [normalizeSelector(elementsSelector)];
    }
    return elementsSelector.map((sel) => normalizeSelector(sel));
  }
  return [normalizeSelector(elementsSelector)];
}
var BaseElementsMatcher = class {
  /**
   * Option to use legacy templates with ${} syntax.
   */
  _legacyTemplates;
  /**
   * Micromatch instance for matching.
   */
  micromatch;
  /**
   * Creates a new BaseElementsMatcher.
   * @param config Configuration options for the matcher.
   * @param globalCache Global cache instance.
   */
  constructor(config, micromatch2) {
    this.micromatch = micromatch2;
    this._legacyTemplates = config.legacyTemplates;
  }
  /**
   * Converts a template with ${} to Handlebars {{}} templates for backwards compatibility.
   * @param template The template to convert.
   * @returns The converted template.
   */
  _getBackwardsCompatibleTemplate(template) {
    return template.replaceAll(LEGACY_TEMPLATE_REGEX, "{{ $1 }}");
  }
  /**
   * Determines if a template contains Handlebars syntax.
   * @param template The template to check.
   * @returns True if the template contains Handlebars syntax, false otherwise.
   */
  _isHandlebarsTemplate(template) {
    return HANDLEBARS_TEMPLATE_REGEX.test(template);
  }
  /**
   * Returns a rendered template using the provided template data.
   * Optimized version with template caching for better performance.
   * @param template The template to render.
   * @param templateData The data to use for replace in the template.
   * @returns The rendered template.
   */
  _getRenderedTemplate(template, templateData) {
    const templateToUse = this._legacyTemplates ? this._getBackwardsCompatibleTemplate(template) : template;
    if (!this._isHandlebarsTemplate(templateToUse)) {
      return template;
    }
    const compiledTemplate = Handlebars.compile(templateToUse);
    return compiledTemplate(templateData);
  }
  /**
   * Returns rendered templates using the provided template data.
   * @param template The templates to render.
   * @param extraTemplateData The data to use for replace in the templates.
   * @returns The rendered templates.
   */
  getRenderedTemplates(template, templateData) {
    if (isArray(template)) {
      return template.map((temp) => {
        return this._getRenderedTemplate(temp, templateData);
      });
    }
    return this._getRenderedTemplate(template, templateData);
  }
  /**
   * Returns whether the given value matches the micromatch pattern, converting non-string values to strings.
   * Optimized version with caching for better performance.
   * @param value The value to check.
   * @param pattern The micromatch pattern to match against.
   * @returns Whether the value matches the pattern.
   */
  isMicromatchMatch(value, pattern) {
    const elementValueToCheck = !value || !isString(value) ? String(value) : value;
    const selectorValueToCheck = isArray(pattern) ? pattern.filter(Boolean) : pattern;
    return this.micromatch.isMatch(elementValueToCheck, selectorValueToCheck);
  }
  /**
   * Returns whether the given value matches the micromatch pattern after rendering it as a template.
   * @param pattern The micromatch pattern to render and match against.
   * @param templateData The data to use for rendering the pattern as a template.
   * @param value The value to check.
   * @returns Whether the value matches the rendered pattern.
   */
  isTemplateMicromatchMatch(pattern, templateData, value) {
    if (isNullish(value)) {
      return false;
    }
    const patternRendered = this.getRenderedTemplates(pattern, templateData);
    if (!patternRendered) {
      return false;
    }
    const filteredPattern = isArray(patternRendered) ? patternRendered.filter(Boolean) : patternRendered;
    if (isArray(value)) {
      return value.some((val) => this.isMicromatchMatch(val, filteredPattern));
    }
    return this.isMicromatchMatch(value, filteredPattern);
  }
  /**
   * Whether the given element key matches the selector key as booleans.
   * @param param0 The parameters object.
   * @returns Whether the element key matches the selector key.
   */
  isElementKeyBooleanMatch({
    /** The element to check. */
    element,
    /** The selector to check against. */
    selector,
    /** The key of the element to check. */
    elementKey,
    /** The key of the selector to check against. */
    selectorKey
  }) {
    if (!(selectorKey in selector)) {
      return true;
    }
    if (!(elementKey in element)) {
      return false;
    }
    if (!isBoolean(selector[selectorKey]) || !isBoolean(element[elementKey])) {
      return false;
    }
    return selector[selectorKey] === element[elementKey];
  }
  /**
   * Whether the given element key matches the selector key using micromatch.
   * @param param0 The parameters object.
   * @returns Whether the element key matches the selector key.
   */
  isElementKeyMicromatchMatch({
    element,
    selector,
    elementKey,
    selectorKey,
    selectorValue,
    templateData
  }) {
    if (!(selectorKey in selector)) {
      return true;
    }
    if (!selectorValue) {
      return false;
    }
    if (!isObjectWithProperty(element, elementKey)) {
      return false;
    }
    return this.isTemplateMicromatchMatch(
      selectorValue,
      templateData,
      element[elementKey]
    );
  }
};

// src/Matcher/DependenciesMatcher.ts
var DependenciesMatcher = class extends BaseElementsMatcher {
  /**
   * Elements matcher to use for matching elements within dependencies.
   */
  _elementsMatcher;
  /**
   * Creates a new DependenciesMatcher.
   * @param elementsMatcher Elements matcher to use for matching elements within dependencies.
   * @param config Configuration options for the matcher.
   * @param micromatch Micromatch instance for matching.
   * @param globalCache Global cache instance.
   */
  constructor(elementsMatcher, config, micromatch2) {
    super(config, micromatch2);
    this._elementsMatcher = elementsMatcher;
  }
  /**
   * Normalizes selector into DependencySelectorNormalized format, containing arrays of selectors data.
   * @param selector The dependency selector to normalize.
   * @returns The normalized dependency selector.
   */
  _normalizeDependencySelector(selector, dependencySelectorsGlobals) {
    if (!isDependencySelector(selector)) {
      throw new Error("Invalid dependency selector");
    }
    let normalizedDependencySelectors = selector.to ? normalizeElementsSelector(selector.to) : null;
    if (normalizedDependencySelectors) {
      normalizedDependencySelectors = normalizedDependencySelectors.map(
        (depSelector) => {
          return {
            ...dependencySelectorsGlobals,
            ...depSelector
          };
        }
      );
    }
    return {
      from: selector.from ? normalizeElementsSelector(selector.from) : null,
      to: normalizedDependencySelectors
    };
  }
  /**
   * Converts a DependencyElementSelectorData to a BaseElementSelectorData, by removing dependency-specific properties.
   * @param selector The dependency element selector data.
   * @returns The base element selector data.
   */
  _convertDependencyElementSelectorDataToBaseElementSelectorData(selector) {
    const baseSelector = {};
    if (selector.type) {
      baseSelector.type = selector.type;
    }
    if (selector.category) {
      baseSelector.category = selector.category;
    }
    if (selector.path) {
      baseSelector.path = selector.path;
    }
    if (selector.elementPath) {
      baseSelector.elementPath = selector.elementPath;
    }
    if (selector.internalPath) {
      baseSelector.internalPath = selector.internalPath;
    }
    if (selector.captured) {
      baseSelector.captured = selector.captured;
    }
    if (selector.origin) {
      baseSelector.origin = selector.origin;
    }
    if (selector.baseSource) {
      baseSelector.baseSource = selector.baseSource;
    }
    if (selector.source) {
      baseSelector.source = selector.source;
    }
    if (!isNullish(selector.isIgnored)) {
      baseSelector.isIgnored = selector.isIgnored;
    }
    if (!isNullish(selector.isUnknown)) {
      baseSelector.isUnknown = selector.isUnknown;
    }
    return baseSelector;
  }
  /**
   * Returns the selectors matching result for the given dependency.
   * @param dependency The dependency description.
   * @param selector The dependency selector normalized.
   * @param extraTemplateData The extra template data for selector values.
   * @returns The selectors matching result for the given dependency.
   */
  _getSelectorMatching(dependency, selector, templateData) {
    const getFromSelectorMatching = () => {
      for (const fromSelectorData of selector.from) {
        const fromMatch = this._elementsMatcher.isElementMatch(
          dependency.from,
          fromSelectorData,
          {
            extraTemplateData: templateData
          }
        );
        const dependencyPropertiesMatch = this._dependencyFromPropertiesMatch(
          dependency,
          [fromSelectorData],
          templateData
        );
        if (fromMatch && dependencyPropertiesMatch) {
          return fromSelectorData;
        }
      }
      return null;
    };
    const getToSelectorMatching = () => {
      for (const toSelectorData of selector.to) {
        const toMatch = isBaseElementSelectorData(toSelectorData) ? this._elementsMatcher.isElementMatch(
          dependency.to,
          this._convertDependencyElementSelectorDataToBaseElementSelectorData(
            toSelectorData
          ),
          {
            extraTemplateData: templateData
          }
        ) : true;
        const dependencyPropertiesMatch = this._dependencyToPropertiesMatch(
          dependency,
          [toSelectorData],
          templateData
        );
        if (toMatch && dependencyPropertiesMatch) {
          return toSelectorData;
        }
      }
      return null;
    };
    const fromSelectorMatching = selector.from ? getFromSelectorMatching() : null;
    const toSelectorMatching = selector.to ? getToSelectorMatching() : null;
    return {
      from: fromSelectorMatching,
      to: toSelectorMatching,
      isMatch: Boolean(
        (selector.from ? fromSelectorMatching : true) && (selector.to ? toSelectorMatching : true)
      )
    };
  }
  /**
   * Determines if the dependency relationship matches the selector.
   * @param dependency The dependency description.
   * @param selector The data of an element selector.
   * @returns Whether the dependency relationship matches the selector.
   */
  _relationshipMatches(selector, relationship, templateData) {
    if (!selector.relationship) {
      return true;
    }
    return this.isTemplateMicromatchMatch(
      selector.relationship,
      templateData,
      relationship
    );
  }
  /**
   * Determines if the selector matches an specific kind
   * @param selector The dependency selector data
   * @param kind Kind to check
   * @param templateData The template data for rendering selector values
   * @returns Whether the selector matches the kind
   */
  _kindMatches(selector, kind, templateData) {
    if (!selector.kind) {
      return true;
    }
    return this.isTemplateMicromatchMatch(selector.kind, templateData, kind);
  }
  /**
   * Determines if the selector matches some of the specifiers
   * @param selector The dependency selector data
   * @param specifiers Specifiers to check
   * @param templateData The template data for rendering selector values
   * @returns Whether the selector matches some of the specifiers
   */
  _specifierMatches(selector, specifiers, templateData) {
    if (!selector.specifiers) {
      return true;
    }
    return this.isTemplateMicromatchMatch(
      selector.specifiers,
      templateData,
      specifiers
    );
  }
  /**
   * Determines if the selector matches the nodeKind
   * @param selector The dependency selector data
   * @param nodeKind The nodeKind to check
   * @param templateData The template data for rendering selector values
   * @returns Whether the selector matches the nodeKind
   */
  _nodeKindMatches(selector, nodeKind, templateData) {
    if (!selector.nodeKind) {
      return true;
    }
    return this.isTemplateMicromatchMatch(
      selector.nodeKind,
      templateData,
      nodeKind
    );
  }
  /**
   * Determines if the dependency description matches the selector for 'from'.
   * @param dependency The dependency description.
   * @param fromSelector The selector for 'from' elements.
   * @param templateData The template data for rendering selector values
   * @returns Whether the dependency properties match the selector for 'from'.
   */
  _dependencyFromPropertiesMatch(dependency, fromSelector, templateData) {
    return fromSelector.some(
      (selectorData) => this._relationshipMatches(
        selectorData,
        dependency.dependency.relationship.from,
        templateData
      )
    );
  }
  /**
   * Determines if the dependency description matches the selector for 'to'.
   * @param dependency The dependency description.
   * @param toSelector The selector for 'to' elements.
   * @param templateData The template data for rendering selector values
   * @returns Whether the dependency properties match the selector for 'to'.
   */
  _dependencyToPropertiesMatch(dependency, toSelector, templateData) {
    const dependencyInfo = dependency.dependency;
    const relationshipTo = dependencyInfo.relationship.to;
    const kind = dependencyInfo.kind;
    const nodeKind = dependencyInfo.nodeKind;
    const specifiers = dependencyInfo.specifiers;
    for (const selectorData of toSelector) {
      if (this._kindMatches(selectorData, kind, templateData) && this._nodeKindMatches(selectorData, nodeKind, templateData) && this._relationshipMatches(selectorData, relationshipTo, templateData) && this._specifierMatches(selectorData, specifiers, templateData)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the selectors matching result for the given dependency.
   * @param dependency The dependency to check.
   * @param selector The selector to check against.
   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.
   * @returns The matching result for the dependency against the selector.
   */
  getSelectorsMatching(dependency, selector, {
    extraTemplateData = {},
    dependencySelectorsGlobals = {}
  } = {}) {
    const normalizedSelector = this._normalizeDependencySelector(
      selector,
      dependencySelectorsGlobals
    );
    const fromExtraData = extraTemplateData.from || {};
    const toExtraData = extraTemplateData.to || {};
    const templateData = {
      ...extraTemplateData,
      from: {
        ...dependency.from,
        relationship: dependency.dependency.relationship.from,
        ...fromExtraData
      },
      to: {
        ...dependency.to,
        relationship: dependency.dependency.relationship.to,
        kind: dependency.dependency.kind,
        nodeKind: dependency.dependency.nodeKind,
        specifiers: dependency.dependency.specifiers,
        ...toExtraData
      }
    };
    const result = this._getSelectorMatching(
      dependency,
      normalizedSelector,
      templateData
    );
    return result;
  }
  /**
   * Returns whether the given dependency matches the selector.
   * @param dependency The dependency to check.
   * @param selector The selector to check against.
   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.
   * @returns Whether the dependency matches the selector properties.
   */
  isDependencyMatch(dependency, selector, options) {
    const matchResult = this.getSelectorsMatching(
      dependency,
      selector,
      options
    );
    return matchResult.isMatch;
  }
};

// src/Matcher/ElementsMatcher.ts
var ElementsMatcher = class extends BaseElementsMatcher {
  /** Whether the cache is enabled or not */
  _cacheIsEnabled;
  /**
   * Creates a new ElementsSelectorMatcher.
   * @param config Configuration options for the matcher.
   * @param micromatch Micromatch instance for matching.
   * @param globalCache Global cache instance.
   */
  constructor(config, micromatch2) {
    super(config, micromatch2);
  }
  /**
   * Whether the given element type matches the selector type.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element type matches the selector type.
   */
  _isTypeMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "type",
      selectorKey: "type",
      selectorValue: selector.type,
      templateData
    });
  }
  /**
   * Whether the given element category matches the selector category.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element category matches the selector category.
   */
  _isCategoryMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "category",
      selectorKey: "category",
      selectorValue: selector.category,
      templateData
    });
  }
  /**
   * Whether the given element path matches the selector path.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element path matches the selector path.
   */
  _isPathMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "path",
      selectorKey: "path",
      selectorValue: selector.path,
      templateData
    });
  }
  /**
   * Whether the given element path matches the selector element path.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element path matches the selector element path.
   */
  _isElementPathMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "elementPath",
      selectorKey: "elementPath",
      selectorValue: selector.elementPath,
      templateData
    });
  }
  /**
   * Whether the given element internal path matches the selector internal path.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element internal path matches the selector internal path.
   */
  _isInternalPathMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "internalPath",
      selectorKey: "internalPath",
      selectorValue: selector.internalPath,
      templateData
    });
  }
  /**
   * Whether the given element origin matches the selector origin
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element origin matches the selector origin.
   */
  _isOriginMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "origin",
      selectorKey: "origin",
      selectorValue: selector.origin,
      templateData
    });
  }
  /**
   * Whether the given element baseSource matches the selector baseSource
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element baseSource matches the selector baseSource.
   */
  _isBaseSourceMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "baseSource",
      selectorKey: "baseSource",
      selectorValue: selector.baseSource,
      templateData
    });
  }
  /**
   * Whether the given element source matches the selector source
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param templateData The data to use for replace in selector value
   * @returns Whether the element source matches the selector source.
   */
  _isSourceMatch(element, selector, templateData) {
    return this.isElementKeyMicromatchMatch({
      element,
      selector,
      elementKey: "source",
      selectorKey: "source",
      selectorValue: selector.source,
      templateData
    });
  }
  /**
   * Determines if the captured values of the element match those in the selector.
   * @param element The element to check.
   * @param selector The selector to check against
   * @param templateData The data to use for replace in selector values
   * @returns True if the captured values match, false otherwise.
   */
  _isCapturedValuesMatch(element, selector, templateData) {
    if (!selector.captured || isEmptyObject(selector.captured)) {
      return true;
    }
    if (!element.captured) {
      return false;
    }
    for (const [key, pattern] of Object.entries(selector.captured)) {
      const elementValue = element.captured?.[key];
      if (!elementValue) {
        return false;
      }
      const renderedPattern = this.getRenderedTemplates(pattern, templateData);
      if (!renderedPattern) {
        return false;
      }
      const filteredPattern = isArray(renderedPattern) ? renderedPattern.filter(Boolean) : renderedPattern;
      const isMatch = this.micromatch.isMatch(elementValue, filteredPattern);
      if (!isMatch) {
        return false;
      }
    }
    return true;
  }
  /**
   * Determines if the isIgnored property of the element matches that in the selector.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @returns True if the isIgnored properties match, false otherwise.
   */
  _isIgnoredMatch(element, selector) {
    return this.isElementKeyBooleanMatch({
      element,
      selector,
      elementKey: "isIgnored",
      selectorKey: "isIgnored"
    });
  }
  /**
   * Determines if the isUnknown property of the element matches that in the selector.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @returns True if the isUnknown properties match, false otherwise.
   */
  _isUnknownMatch(element, selector) {
    return this.isElementKeyBooleanMatch({
      element,
      selector,
      elementKey: "isUnknown",
      selectorKey: "isUnknown"
    });
  }
  /**
   * Returns the selector matching result for the given local or external element.
   * @param element The local or external element to check.
   * @param selector The selector to check against.
   * @param extraTemplateData Extra template data to use for matching.
   * @returns The selector matching result for the given element, or null if none matches.
   */
  _getSelectorMatching(element, selectorsData, extraTemplateData) {
    const templateData = {
      element,
      ...extraTemplateData
    };
    for (const selectorData of selectorsData) {
      if (!this._isTypeMatch(element, selectorData, templateData) || !this._isCategoryMatch(element, selectorData, templateData) || !this._isOriginMatch(element, selectorData, templateData) || !this._isIgnoredMatch(element, selectorData) || !this._isUnknownMatch(element, selectorData) || !this._isPathMatch(element, selectorData, templateData) || !this._isElementPathMatch(element, selectorData, templateData) || !this._isInternalPathMatch(element, selectorData, templateData) || !this._isSourceMatch(element, selectorData, templateData) || !this._isBaseSourceMatch(element, selectorData, templateData) || !this._isCapturedValuesMatch(element, selectorData, templateData)) {
        continue;
      }
      return selectorData;
    }
    return null;
  }
  /**
   * Returns the selector matching result for the given element, or null if none matches.
   * It omits checks in keys applying only to dependency between elements, such as relationship.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.
   * @returns The selector matching result for the given element, or null if none matches.
   */
  getSelectorMatching(element, selector, { extraTemplateData = {} } = {}) {
    const selectorsData = normalizeElementsSelector(selector);
    return this._getSelectorMatching(element, selectorsData, extraTemplateData);
  }
  /**
   * Returns whether the given element matches the selector.
   * It omits checks in keys applying only to dependency between elements, such as relationship.
   * @param element The element to check.
   * @param selector The selector to check against.
   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.
   * @returns Whether the element matches the selector properties applying to elements.
   */
  isElementMatch(element, selector, options) {
    const selectorMatching = this.getSelectorMatching(
      element,
      selector,
      options
    );
    return !isNullish(selectorMatching);
  }
};

// src/Descriptor/ElementsDescriptor.types.ts
var ELEMENT_DESCRIPTOR_MODES_MAP = {
  /** Mode to interpret the pattern as a folder */
  FOLDER: "folder",
  /** Mode to interpret the pattern as a file */
  FILE: "file",
  /** Mode to interpret the pattern as a full path */
  FULL: "full"
};
var ELEMENT_ORIGINS_MAP = {
  /** Origin of local elements (files) */
  LOCAL: "local",
  /** Origin of external elements (libraries) */
  EXTERNAL: "external",
  /** Origin of core elements */
  CORE: "core"
};

// src/Descriptor/ElementsDescriptorHelpers.ts
function isElementDescriptorMode(value) {
  return isString(value) && Object.values(ELEMENT_DESCRIPTOR_MODES_MAP).includes(
    value
  );
}
function isElementDescriptorPattern(value) {
  return isString(value) || isArray(value) && !isEmptyArray(value) && value.every(isString);
}
function isBaseElementDescriptor(value) {
  return isObjectWithProperty(value, "pattern") && isElementDescriptorPattern(value.pattern);
}
function isElementDescriptorWithType(value) {
  return isBaseElementDescriptor(value) && isObjectWithProperty(value, "type") && isString(value.type);
}
function isElementDescriptorWithCategory(value) {
  return isBaseElementDescriptor(value) && isObjectWithProperty(value, "category") && isString(value.category);
}
function isElementDescriptor(value) {
  return isElementDescriptorWithType(value) || isElementDescriptorWithCategory(value);
}
function isBaseElement(value) {
  return isObjectWithProperty(value, "type") && isObjectWithProperty(value, "category") && isObjectWithProperty(value, "path") && isObjectWithProperty(value, "captured") && isObjectWithProperty(value, "origin") && isObjectWithProperty(value, "isIgnored") && isObjectWithProperty(value, "isUnknown");
}
function isIgnoredElement(value) {
  return isBaseElement(value) && isObjectWithProperty(value, "isIgnored") && value.isIgnored === true;
}
function isLocalElement(value) {
  return isBaseElement(value) && value.origin === ELEMENT_ORIGINS_MAP.LOCAL;
}
function isUnknownLocalElement(value) {
  return isLocalElement(value) && value.isUnknown === true;
}
function isKnownLocalElement(value) {
  return isLocalElement(value) && value.isUnknown === false;
}
function isDependencyElementDescription(value) {
  return isBaseElement(value) && isObjectWithProperty(value, "source") && isString(value.source);
}
function isElementDescription(value) {
  return isIgnoredElement(value) || isUnknownLocalElement(value) || isKnownLocalElement(value) || isDependencyElementDescription(value);
}
function isLocalDependencyElement(value) {
  return isDependencyElementDescription(value) && isLocalElement(value);
}
function isExternalDependencyElement(value) {
  return isDependencyElementDescription(value) && value.origin === ELEMENT_ORIGINS_MAP.EXTERNAL && isObjectWithProperty(value, "baseSource") && isString(value.baseSource);
}
function isCoreDependencyElement(value) {
  return isDependencyElementDescription(value) && value.origin === ELEMENT_ORIGINS_MAP.CORE && isObjectWithProperty(value, "baseSource") && isString(value.baseSource);
}

// src/Descriptor/DependenciesDescriptor.types.ts
var DEPENDENCY_KIND_TYPE = "type";
var DEPENDENCY_KIND_VALUE = "value";
var DEPENDENCY_KIND_TYPEOF = "typeof";
var DEPENDENCY_KINDS_MAP = {
  /** Type import, e.g., `import type { X } from 'module'` */
  TYPE: DEPENDENCY_KIND_TYPE,
  /** Value import, e.g., `import { X } from 'module'` */
  VALUE: DEPENDENCY_KIND_VALUE,
  /** typeof import, e.g. `type ModuleType = typeof import("./my_module");` */
  TYPE_OF: DEPENDENCY_KIND_TYPEOF
};
var DEPENDENCY_RELATIONSHIPS_MAP = {
  /** The dependency is internal to the element */
  INTERNAL: "internal",
  /** The dependency is a child of the element */
  CHILD: "child",
  /** The dependency is a descendant of the element */
  DESCENDANT: "descendant",
  /** The dependency is a sibling of the element (both have the same parent) */
  SIBLING: "sibling",
  /** The dependency is a parent of the element */
  PARENT: "parent",
  /** The dependency is an uncle of the element */
  UNCLE: "uncle",
  /** The dependency is a nephew of the element */
  NEPHEW: "nephew",
  /** The dependency is an ancestor of the element */
  ANCESTOR: "ancestor"
};
var DEPENDENCY_RELATIONSHIPS_INVERTED_MAP = {
  [DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL]: DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL,
  [DEPENDENCY_RELATIONSHIPS_MAP.CHILD]: DEPENDENCY_RELATIONSHIPS_MAP.PARENT,
  [DEPENDENCY_RELATIONSHIPS_MAP.DESCENDANT]: DEPENDENCY_RELATIONSHIPS_MAP.ANCESTOR,
  [DEPENDENCY_RELATIONSHIPS_MAP.SIBLING]: DEPENDENCY_RELATIONSHIPS_MAP.SIBLING,
  [DEPENDENCY_RELATIONSHIPS_MAP.PARENT]: DEPENDENCY_RELATIONSHIPS_MAP.CHILD,
  [DEPENDENCY_RELATIONSHIPS_MAP.UNCLE]: DEPENDENCY_RELATIONSHIPS_MAP.NEPHEW,
  [DEPENDENCY_RELATIONSHIPS_MAP.NEPHEW]: DEPENDENCY_RELATIONSHIPS_MAP.UNCLE,
  [DEPENDENCY_RELATIONSHIPS_MAP.ANCESTOR]: DEPENDENCY_RELATIONSHIPS_MAP.DESCENDANT
};

// src/Descriptor/DependenciesDescriptorHelpers.ts
function isDependencyKind(value) {
  return isString(value) && Object.values(DEPENDENCY_KINDS_MAP).includes(value);
}
function isDependencyRelationship(value) {
  return isString(value) && Object.values(DEPENDENCY_RELATIONSHIPS_MAP).includes(
    value
  );
}
function isDependencyRelationshipDescription(value) {
  return isObjectWithProperty(value, "to") && (isNull(value.to) || isDependencyRelationship(value.to)) && isObjectWithProperty(value, "from") && (isNull(value.from) || isDependencyRelationship(value.from));
}
function isElementsDependencyInfo(value) {
  return isObjectWithProperty(value, "kind") && isDependencyKind(value.kind) && isObjectWithProperty(value, "relationship") && isDependencyRelationshipDescription(value.relationship) && isObjectWithProperty(value, "nodeKind") && (isNull(value.nodeKind) || isString(value.nodeKind));
}
function isDependencyDescription(value) {
  return isObjectWithProperty(value, "to") && isElementDescription(value.to) && isObjectWithProperty(value, "from") && isElementDescription(value.from) && isObjectWithProperty(value, "dependency") && isElementsDependencyInfo(value.dependency);
}
function isInternalDependency(dependency) {
  return dependency.dependency.relationship.to === DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL;
}

// src/Cache/Cache.ts
var CacheManager = class {
  /**
   * Internal cache map
   */
  _cache;
  /**
   * Creates a new CacheManager instance
   */
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  /**
   * Generates a string key from the given cache key. Has to be implemented for non-string keys.
   * @param key The cache key to generate from
   * @returns The generated string key
   */
  generateKey(key) {
    if (isString(key)) {
      return key;
    }
    const errorMessage = "Cache key generation for non-string keys is not implemented because it causes performance issues: " + JSON.stringify(key);
    throw new Error(errorMessage);
  }
  /**
   * Generates a hashed key for the given cache key
   * @param key The cache key to hash
   * @returns The hashed key as a string
   */
  getKey(key) {
    return this.generateKey(key);
  }
  /**
   * Retrieves a value from the cache based on the given hashed key
   * @param hashedKey The hashed key to retrieve
   * @returns The cached value or undefined if not found
   */
  get(hashedKey) {
    return this._cache.get(hashedKey);
  }
  /**
   * Stores a value in the cache with a given hashed key
   * @param hashedKey The hashed key to store
   * @param value The value to cache
   */
  set(hashedKey, value) {
    this._cache.set(hashedKey, value);
  }
  /**
   * Checks if a value exists in the cache based on the given hashed key
   * @param hashedKey The hashed key to check
   * @returns True if the value exists, false otherwise
   */
  has(hashedKey) {
    return this._cache.has(hashedKey);
  }
  /**
   * Retrieves all cached values
   * @returns A map of all cached values
   */
  getAll() {
    return this._cache;
  }
  /**
   * Clears the entire cache
   */
  clear() {
    this._cache.clear();
  }
  /**
   * Serializes the  cache to a plain object.
   * @returns The serialized cache.
   */
  serialize() {
    return Array.from(this.getAll().entries()).reduce(
      (acc, [key, value]) => {
        acc[key] = value;
        return acc;
      },
      {}
    );
  }
  /**
   * Sets the cache from a serialized object.
   * @param serializedCache The serialized cache.
   */
  setFromSerialized(serializedCache) {
    for (const key in serializedCache) {
      this.set(key, serializedCache[key]);
    }
  }
};

// src/Cache/CacheDisabled.ts
var CacheManagerDisabled = class extends CacheManager {
  /**
   * Generates a fake cache key as caching is disabled
   * @param key The cache key to hash
   * @returns An empty string
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getKey(_key) {
    return "";
  }
  /**
   * Does nothing as caching is disabled
   * @param hashedKey The hashed key to retrieve
   * @returns Undefined as caching is disabled
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  get(_hashedKey) {
    return void 0;
  }
  /**
   * Does nothing as caching is disabled
   * @param hashedKey The hashed key to store
   * @param value The value to cache
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  set(_hashedKey, _value) {
    return;
  }
  /**
   * Does nothing as caching is disabled
   * @param hashedKey The hashed key to check
   * @returns False as caching is disabled
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  has(_hashedKey) {
    return false;
  }
};

// src/Descriptor/DependenciesDescriptionsCache.ts
var DependenciesDescriptionsCache = class extends CacheManager {
  /** Generates a unique key for the given dependency description options.
   * @param options The options to generate the key from.
   * @returns The generated key.
   */
  generateKey(options) {
    return `${options.from}|${options.to}|${options.source}|${options.kind}|${options.nodeKind}|${options.specifiers ? options.specifiers.join(",") : ""}`;
  }
};

// src/Descriptor/DependenciesDescriptor.ts
var DependenciesDescriptor = class {
  /**
   * Cache to store previously described dependencies.
   */
  _dependenciesCache;
  /**
   * Elements descriptor instance.
   */
  _elementsDescriptor;
  /**
   * Configuration options.
   */
  _config;
  /**
   * Creates a new DependenciesDescriptor instance.
   * @param elementsDescriptor The elements descriptor instance.
   * @param config The configuration options.
   */
  constructor(elementsDescriptor, config) {
    this._elementsDescriptor = elementsDescriptor;
    this._config = config;
    this._dependenciesCache = this._config.cache ? new DependenciesDescriptionsCache() : new CacheManagerDisabled();
  }
  /**
   * Serializes the elements cache to a plain object.
   * @returns The serialized elements cache.
   */
  serializeCache() {
    return this._dependenciesCache.serialize();
  }
  /**
   * Sets the elements cache from a serialized object.
   * @param serializedCache The serialized elements cache.
   */
  setCacheFromSerialized(serializedCache) {
    this._dependenciesCache.setFromSerialized(serializedCache);
  }
  /**
   * Clears the elements cache.
   */
  clearCache() {
    this._dependenciesCache.clear();
  }
  /**
   * Retrieves the element path of the parent of a given element.
   * @param elementInfo The element whose parent is to be retrieved.
   * @returns The parent element path, or undefined if none exists.
   */
  _getParent(elementInfo) {
    return elementInfo.parents[0]?.elementPath;
  }
  /**
   * Retrieves the common ancestor of two elements.
   * @param elementInfoA The first element.
   * @param elementInfoB The second element.
   * @returns The common ancestor element path, or undefined if none exists.
   */
  _getCommonAncestor(elementInfoA, elementInfoB) {
    const commonAncestor = elementInfoA.parents.find((elementParentA) => {
      return elementInfoB.parents.some((elementParentB) => {
        return elementParentA.elementPath === elementParentB.elementPath;
      });
    });
    return commonAncestor?.elementPath;
  }
  /**
   * Checks if the parent of element A is an ancestor of element B.
   * @param elementA The element A.
   * @param elementB The element B.
   * @returns True if the parent of element A is an ancestor of element B, false otherwise.
   */
  _isDescendantOfParent(elementA, elementB) {
    const commonAncestor = this._getCommonAncestor(elementA, elementB);
    return commonAncestor && commonAncestor === this._getParent(elementA);
  }
  /**
   * Checks if two elements are siblings (same parent).
   * @param elementA The first element.
   * @param elementB The second element.
   * @returns True if the elements are siblings, false otherwise.
   */
  _isSibling(elementA, elementB) {
    const parentA = this._getParent(elementA);
    const parentB = this._getParent(elementB);
    return parentA && parentB && parentA === parentB;
  }
  /**
   * Checks if one element is a descendant of another.
   * @param elementA The potential descendant element.
   * @param elementB The potential ancestor element.
   * @returns True if elementA is a descendant of elementB, false otherwise.
   */
  _isDescendant(elementA, elementB) {
    return elementA.parents.some(
      (parent) => parent.elementPath === elementB.elementPath
    );
  }
  /**
   * Checks if one element is a child of another.
   * @param elementA The potential child element.
   * @param elementB The potential parent element.
   * @returns True if elementA is a child of elementB, false otherwise.
   */
  _isChild(elementA, elementB) {
    return this._getParent(elementA) === elementB.elementPath;
  }
  /**
   * Checks if two local elements are internally related (same element).
   * @param elementA The first element.
   * @param elementB The second element.
   * @returns True if the elements are internally related, false otherwise.
   */
  _isInternal(elementA, elementB) {
    return elementA.elementPath === elementB.elementPath;
  }
  /**
   * Retrieves the relationship between two local known elements in terms of dependency.
   * @param element The element depending on another element.
   * @param dependency The element being depended on.
   * @returns The relationship between the elements.
   */
  _dependencyRelationship(element, dependency) {
    if (isIgnoredElement(dependency) || !isKnownLocalElement(dependency) || !isKnownLocalElement(element)) {
      return null;
    }
    if (this._isInternal(dependency, element)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL;
    }
    if (this._isChild(dependency, element)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.CHILD;
    }
    if (this._isDescendant(dependency, element)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.DESCENDANT;
    }
    if (this._isSibling(dependency, element)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.SIBLING;
    }
    if (this._isChild(element, dependency)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.PARENT;
    }
    if (this._isDescendant(element, dependency)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.ANCESTOR;
    }
    if (this._isDescendantOfParent(dependency, element)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.UNCLE;
    }
    if (this._isDescendantOfParent(element, dependency)) {
      return DEPENDENCY_RELATIONSHIPS_MAP.NEPHEW;
    }
    return null;
  }
  _dependencyRelationships(element, dependency) {
    const toRelationship = this._dependencyRelationship(element, dependency);
    const fromRelationship = toRelationship ? DEPENDENCY_RELATIONSHIPS_INVERTED_MAP[toRelationship] : null;
    return {
      from: fromRelationship,
      to: toRelationship
    };
  }
  /**
   * Describes elements in a dependency relationship, and provides additional information about the dependency itself.
   * @param options The options for describing the elements and the dependency details.
   * @returns The description of the dependency between the elements.
   */
  describeDependency({
    from,
    to,
    source,
    kind,
    nodeKind,
    specifiers
  }) {
    const cacheKey = this._dependenciesCache.getKey({
      from,
      to,
      source,
      kind,
      nodeKind,
      specifiers
    });
    if (this._dependenciesCache.has(cacheKey)) {
      return this._dependenciesCache.get(cacheKey);
    }
    const fromElement = this._elementsDescriptor.describeElement(from);
    const toElement = this._elementsDescriptor.describeDependencyElement(
      source,
      to
    );
    const result = {
      from: fromElement,
      to: toElement,
      dependency: {
        kind,
        nodeKind: nodeKind || null,
        relationship: this._dependencyRelationships(fromElement, toElement),
        specifiers: specifiers || null
      }
    };
    this._dependenciesCache.set(cacheKey, result);
    return result;
  }
};

// src/Descriptor/ElementsDescriptor.ts
import isCoreModule from "is-core-module";
var UNKNOWN_ELEMENT = {
  path: null,
  elementPath: null,
  internalPath: null,
  source: null,
  baseSource: null,
  parents: null,
  type: null,
  category: null,
  captured: null,
  origin: ELEMENT_ORIGINS_MAP.LOCAL,
  isIgnored: false,
  isUnknown: true
};
var SCOPED_PACKAGE_REGEX = /^@[^/]*\/?[^/]+/;
var EXTERNAL_PATH_REGEX = /^\w/;
var ElementsDescriptor = class {
  _mod = null;
  /**
   * Cache to store previously described elements.
   */
  _descriptionsCache;
  /**
   * Cache to store previously described files.
   */
  _filesCache;
  /**
   * Configuration instance for this descriptor.
   */
  _config;
  /**
   * Element descriptors used by this descriptor.
   */
  _elementDescriptors;
  /** Micromatch instance for path matching */
  _micromatch;
  /**
   * The configuration options for this descriptor.
   * @param elementDescriptors The element descriptors.
   * @param configOptions The configuration options.
   * @param globalCache The global cache for various caching needs.
   * @param micromatch The micromatch instance for path matching.
   */
  constructor(elementDescriptors, configOptions, micromatch2) {
    this._micromatch = micromatch2;
    this._elementDescriptors = elementDescriptors;
    this._validateDescriptors(elementDescriptors);
    this._config = configOptions;
    this._filesCache = this._config.cache ? new CacheManager() : new CacheManagerDisabled();
    this._descriptionsCache = this._config.cache ? new CacheManager() : new CacheManagerDisabled();
    this._loadModuleInNode();
  }
  /**
   * Serializes the elements cache to a plain object.
   * @returns The serialized elements cache.
   */
  serializeCache() {
    return {
      descriptions: this._descriptionsCache.serialize(),
      files: this._filesCache.serialize()
    };
  }
  /**
   * Sets the elements cache from a serialized object.
   * @param serializedCache The serialized elements cache.
   */
  setCacheFromSerialized(serializedCache) {
    this._descriptionsCache.setFromSerialized(serializedCache.descriptions);
    this._filesCache.setFromSerialized(serializedCache.files);
  }
  /**
   * Clears the elements cache.
   */
  clearCache() {
    this._descriptionsCache.clear();
    this._filesCache.clear();
  }
  /**
   * Loads the Node.js module to access built-in modules information when running in Node.js environment.
   */
  _loadModuleInNode() {
    if (!this._mod && !isNullish(process) && !isNullish(process.versions) && !isNullish(process.versions.node)) {
      this._mod = __require("module");
    }
  }
  /**
   * Validates the element descriptors to ensure they are correctly defined.
   */
  _validateDescriptors(elementDescriptors) {
    let index = 0;
    for (const descriptor of elementDescriptors) {
      if (!isElementDescriptor(descriptor)) {
        throw new Error(
          `Element descriptor at index ${index} must have a pattern, and either a 'type' or 'category' defined.`
        );
      }
      index++;
    }
  }
  /**
   * Determines if a dependency source is a core module.
   * @param dependencySource The source of the dependency to check.
   * @param baseDependencySource The base source of the dependency to check.
   * @returns True if the dependency source is a core module, false otherwise.
   */
  _dependencySourceIsCoreModule(dependencySource, baseDependencySource) {
    if (this._mod) {
      const baseSourceWithoutPrefix = baseDependencySource.startsWith("node:") ? baseDependencySource.slice(5) : baseDependencySource;
      return this._mod.builtinModules.includes(baseSourceWithoutPrefix);
    }
    return isCoreModule(dependencySource);
  }
  /**
   * Determines if a dependency source is scoped (e.g., @scope/package).
   * @param dependencySource The source of the dependency to check.
   * @returns True if the dependency source is scoped, false otherwise.
   */
  _dependencySourceIsScoped(dependencySource) {
    return SCOPED_PACKAGE_REGEX.test(dependencySource);
  }
  /**
   * Determines if a dependency source is external or an alias.
   * @param dependencySource The source of the dependency to check.
   * @returns True if the dependency source is external or an alias, false otherwise.
   */
  _dependencySourceIsExternalOrScoped(dependencySource) {
    return EXTERNAL_PATH_REGEX.test(dependencySource) || this._dependencySourceIsScoped(dependencySource);
  }
  /**
   * Gets the base source of an external module.
   * @param dependencySource The source of the dependency to check.
   * @returns The base source of the external module. (e.g., for "@scope/package/submodule", it returns "@scope/package")
   */
  _getExternalOrCoreModuleBaseSource(dependencySource) {
    if (this._dependencySourceIsScoped(dependencySource)) {
      const [scope, packageName] = dependencySource.split("/");
      return `${scope}/${packageName}`;
    }
    const [pkg] = dependencySource.split("/");
    return pkg;
  }
  /**
   * Determines if an element is external based on its file path and dependency source.
   * Files inside "node_modules" are considered external.
   * If the dependency source is not provided, only the file path is considered.
   * If the dependency source is provided, it must not be a local path (i.e, it should start by "./", "../", or "/").
   * @param filePath
   * @param dependencySource
   * @returns
   */
  _isExternalDependency(filePath, dependencySource) {
    return (!filePath || filePath.includes("node_modules")) && // Not having a source, and being in node_modules only could happen if user is analyzing a file directly from there, not as a dependency. Should this be considered external then?
    (!dependencySource || this._dependencySourceIsExternalOrScoped(dependencySource));
  }
  /**
   * Determines if a given path is included based on the configuration.
   * Uses caching for better performance on repeated calls.
   * @param elementPath The element path to check.
   * @param includeExternal Whether to include external files.
   * @returns True if the path is included, false otherwise.
   */
  _pathIsIncluded(elementPath) {
    let result;
    if (this._config.includePaths && this._config.ignorePaths) {
      const isIncluded = this._micromatch.isMatch(
        elementPath,
        this._config.includePaths
      );
      const isIgnored = this._micromatch.isMatch(
        elementPath,
        this._config.ignorePaths
      );
      result = isIncluded && !isIgnored;
    } else if (this._config.includePaths) {
      result = this._micromatch.isMatch(elementPath, this._config.includePaths);
    } else if (this._config.ignorePaths) {
      result = !this._micromatch.isMatch(elementPath, this._config.ignorePaths);
    } else {
      result = true;
    }
    return result;
  }
  /**
   * Gets captured values from the captured array and capture configuration.
   * @param captured The array of captured strings.
   * @param captureConfig The configuration for capturing values.
   * @returns The captured values as an object.
   */
  _getCapturedValues(captured, captureConfig) {
    if (!captureConfig) {
      return null;
    }
    return captured.reduce((capturedValues, captureValue, index) => {
      if (captureConfig[index]) {
        capturedValues[captureConfig[index]] = captureValue;
      }
      return capturedValues;
    }, {});
  }
  /**
   * Gets the element path based on the path pattern, path segments to the element, and all path segments from the file path.
   * @param pathPattern The element path pattern.
   * @param pathSegments The path segments leading to the element.
   * @param allPathSegments The full path segments from the file path.
   * @returns The element path.
   */
  _getElementPath(pathPattern, pathSegments, allPathSegments) {
    const elementPathRegexp = this._micromatch.makeRe(pathPattern);
    const testedSegments = [];
    let result;
    for (const pathSegment of pathSegments) {
      testedSegments.push(pathSegment);
      const joinedSegments = testedSegments.join("/");
      if (elementPathRegexp.test(joinedSegments)) {
        result = joinedSegments;
        break;
      }
    }
    return `${[...allPathSegments].reverse().join("/").split(result)[0]}${result}`;
  }
  _fileDescriptorMatch({
    elementDescriptor,
    filePath,
    currentPathSegments,
    lastPathSegmentMatching,
    alreadyMatched
  }) {
    const mode = isElementDescriptorMode(elementDescriptor.mode) ? elementDescriptor.mode : ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER;
    const patterns = isArray(elementDescriptor.pattern) ? elementDescriptor.pattern : [elementDescriptor.pattern];
    for (const pattern of patterns) {
      const useFullPathMatch = mode === ELEMENT_DESCRIPTOR_MODES_MAP.FULL && !alreadyMatched;
      const effectivePattern = mode === ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER && !alreadyMatched ? `${pattern}/**/*` : pattern;
      const targetPath = useFullPathMatch ? filePath : currentPathSegments.join("/");
      let baseCapture = null;
      let hasCapture = true;
      if (elementDescriptor.basePattern) {
        const baseTarget = filePath.split("/").slice(0, filePath.split("/").length - lastPathSegmentMatching).join("/");
        baseCapture = this._micromatch.capture(
          [elementDescriptor.basePattern, "**", effectivePattern].join("/"),
          baseTarget
        );
        hasCapture = baseCapture !== null;
      }
      const capture = this._micromatch.capture(effectivePattern, targetPath);
      if (capture && hasCapture) {
        return {
          matched: true,
          capture,
          baseCapture,
          useFullPathMatch,
          patternUsed: pattern
        };
      }
    }
    return { matched: false };
  }
  /**
   * Retrieves the description of a local file given its path.
   * @param elementPath The path of the element to describe.
   * @returns The description of the element.
   */
  _getFileDescription(filePath) {
    if (!filePath) {
      return {
        ...UNKNOWN_ELEMENT
      };
    }
    if (!this._pathIsIncluded(filePath)) {
      return {
        ...UNKNOWN_ELEMENT,
        path: filePath,
        isIgnored: true,
        origin: null
      };
    }
    const parents = [];
    const elementResult = {
      path: filePath,
      type: null,
      category: null,
      captured: null,
      origin: ELEMENT_ORIGINS_MAP.LOCAL,
      isIgnored: false
    };
    const state = {
      pathSegmentsAccumulator: [],
      lastPathSegmentMatching: 0
    };
    const pathSegments = filePath.split("/").reverse();
    const processElementMatch = (elementDescriptor, matchInfo, currentPathSegments, elementPaths) => {
      const { capture, baseCapture, useFullPathMatch, patternUsed } = matchInfo;
      let capturedValues = this._getCapturedValues(
        capture,
        elementDescriptor.capture
      );
      if (elementDescriptor.basePattern && baseCapture) {
        capturedValues = {
          ...this._getCapturedValues(
            baseCapture,
            elementDescriptor.baseCapture
          ),
          ...capturedValues
        };
      }
      const elementPath = useFullPathMatch ? filePath : this._getElementPath(patternUsed, currentPathSegments, elementPaths);
      if (!elementResult.type && !elementResult.category) {
        const mode = elementDescriptor.mode || ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER;
        elementResult.type = elementDescriptor.type || null;
        elementResult.category = elementDescriptor.category || null;
        elementResult.isUnknown = false;
        elementResult.elementPath = elementPath;
        elementResult.captured = capturedValues;
        elementResult.internalPath = mode === ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER || filePath !== elementPath ? filePath.replace(`${elementPath}/`, "") : filePath.split("/").pop();
      } else {
        parents.push({
          type: elementDescriptor.type || null,
          category: elementDescriptor.category || null,
          elementPath,
          captured: capturedValues
        });
      }
    };
    for (let i = 0; i < pathSegments.length; i++) {
      const segment = pathSegments[i];
      state.pathSegmentsAccumulator.unshift(segment);
      const alreadyHasMainElement = Boolean(elementResult.type) || Boolean(elementResult.category);
      for (const elementDescriptor of this._elementDescriptors) {
        const match = this._fileDescriptorMatch({
          elementDescriptor,
          filePath,
          currentPathSegments: state.pathSegmentsAccumulator,
          lastPathSegmentMatching: state.lastPathSegmentMatching,
          alreadyMatched: alreadyHasMainElement
        });
        if (match.matched) {
          processElementMatch(
            elementDescriptor,
            match,
            state.pathSegmentsAccumulator,
            pathSegments
          );
          state.pathSegmentsAccumulator = [];
          state.lastPathSegmentMatching = i + 1;
          break;
        }
      }
    }
    const result = { ...elementResult, parents };
    if (!isKnownLocalElement(result)) {
      return {
        ...UNKNOWN_ELEMENT,
        path: filePath
      };
    }
    return result;
  }
  /**
   * Describes a file given its path.
   * @param includeExternal Whether to include external files (inside node_modules) in the matching process.
   * @param filePath The path of the file to describe.
   * @returns The description of the element.
   */
  _describeFile(filePath) {
    const cacheKey = this._filesCache.getKey(String(filePath));
    if (this._filesCache.has(cacheKey)) {
      return this._filesCache.get(cacheKey);
    }
    const description = this._getFileDescription(filePath);
    this._filesCache.set(cacheKey, description);
    return description;
  }
  /**
   * Returns an external or core dependency element given its dependency source and file path.
   * @param dependencySource The source of the dependency.
   * @param filePath The resolved file path of the dependency, if known.
   * @returns The external or core dependency element, or null if it is a local dependency.
   */
  _getExternalOrCoreDependencyElement(dependencySource, filePath) {
    const baseDependencySource = this._getExternalOrCoreModuleBaseSource(dependencySource);
    const isCore = this._dependencySourceIsCoreModule(
      dependencySource,
      baseDependencySource
    );
    if (isCore) {
      const coreElement = {
        ...UNKNOWN_ELEMENT,
        source: dependencySource,
        baseSource: baseDependencySource,
        origin: ELEMENT_ORIGINS_MAP.CORE
      };
      return coreElement;
    }
    const isExternal = this._isExternalDependency(
      filePath || null,
      dependencySource
    );
    if (isExternal) {
      const externalElement = {
        ...UNKNOWN_ELEMENT,
        path: filePath || null,
        internalPath: dependencySource.replace(baseDependencySource, ""),
        source: dependencySource,
        baseSource: baseDependencySource,
        origin: ELEMENT_ORIGINS_MAP.EXTERNAL
      };
      return externalElement;
    }
    return null;
  }
  _describeElement(filePath, dependencySource) {
    const cacheKey = `${String(dependencySource)}::${String(filePath)}`;
    if (this._descriptionsCache.has(cacheKey)) {
      return this._descriptionsCache.get(cacheKey);
    }
    const externalOrCoreDependencyElement = dependencySource ? this._getExternalOrCoreDependencyElement(dependencySource, filePath) : null;
    if (externalOrCoreDependencyElement) {
      this._descriptionsCache.set(cacheKey, externalOrCoreDependencyElement);
      return externalOrCoreDependencyElement;
    }
    const fileDescription = this._describeFile(filePath);
    const elementResult = dependencySource ? {
      ...fileDescription,
      source: dependencySource
    } : fileDescription;
    this._descriptionsCache.set(cacheKey, elementResult);
    return elementResult;
  }
  /**
   * Describes an element given its file path.
   * @param filePath The path of the file to describe.
   * @returns The description of the element.
   */
  describeElement(filePath) {
    return this._describeElement(filePath);
  }
  /**
   * Describes a dependency element given its dependency source and file path.
   * @param dependencySource The source of the dependency.
   * @param filePath The path of the file being the dependency, if known.
   * @returns The description of the dependency element.
   */
  describeDependencyElement(dependencySource, filePath) {
    return this._describeElement(filePath, dependencySource);
  }
};

// src/Descriptor/Descriptors.ts
var Descriptors = class {
  _elementsDescriptor;
  _dependenciesDescriptor;
  /** Creates a new DescriptorsManager instance
   * @param elementDescriptors The element descriptors.
   * @param configOptions The configuration options.
   * @param micromatch The Micromatch instance.
   */
  constructor(elementDescriptors, config, micromatch2) {
    this._elementsDescriptor = new ElementsDescriptor(
      elementDescriptors,
      config,
      micromatch2
    );
    this._dependenciesDescriptor = new DependenciesDescriptor(
      this._elementsDescriptor,
      config
    );
  }
  /**
   * Serializes the elements and dependencies cache to a plain object.
   * @returns The serialized elements and dependencies cache.
   */
  serializeCache() {
    return {
      elements: this._elementsDescriptor.serializeCache(),
      dependencies: this._dependenciesDescriptor.serializeCache()
    };
  }
  /**
   * Sets the elements and dependencies cache from a serialized object.
   * @param serializedCache The serialized elements and dependencies cache.
   */
  setCacheFromSerialized(serializedCache) {
    this._elementsDescriptor.setCacheFromSerialized(serializedCache.elements);
    this._dependenciesDescriptor.setCacheFromSerialized(
      serializedCache.dependencies
    );
  }
  /**
   * Clears all caches.
   */
  clearCache() {
    this._elementsDescriptor.clearCache();
    this._dependenciesDescriptor.clearCache();
  }
  /**
   * Describes an element given its file path.
   * @param filePath The path of the file to describe.
   * @returns The description of the element.
   */
  describeElement(filePath) {
    return this._elementsDescriptor.describeElement(filePath);
  }
  /**
   * Describes a dependency element given its dependency source and file path.
   * @param dependencySource The source of the dependency.
   * @param filePath The path of the file being the dependency, if known.
   * @returns The description of the dependency element.
   */
  describeDependencyElement(dependencySource, filePath) {
    return this._elementsDescriptor.describeDependencyElement(
      dependencySource,
      filePath
    );
  }
  /**
   * Describes elements in a dependency relationship, and provides additional information about the dependency itself.
   * @param options The options for describing the elements and the dependency details.
   * @returns The description of the dependency between the elements.
   */
  describeDependency(options) {
    return this._dependenciesDescriptor.describeDependency(options);
  }
};

// src/Matcher/Matcher.ts
var Matcher = class {
  _descriptors;
  _elementsMatcher;
  _dependenciesMatcher;
  /**
   * Constructor for the Matcher class.
   * @param descriptors Element descriptors to use for matching.
   * @param elementsMatcher Elements matcher instance.
   * @param dependenciesMatcher Dependencies matcher instance.
   * @param config Configuration options.
   * @param globalCache Global cache instance.
   */
  constructor(descriptors, elementsMatcher, dependenciesMatcher, config, micromatch2) {
    this._descriptors = new Descriptors(descriptors, config, micromatch2);
    this._elementsMatcher = elementsMatcher;
    this._dependenciesMatcher = dependenciesMatcher;
  }
  /**
   * Determines if an element matches a given selector.
   * @param filePath The file path of the element
   * @param selector The selector to match against
   * @param options Extra matcher options
   * @returns True if the element matches the selector, false otherwise
   */
  _isElementMatch(filePath, selector, options) {
    const description = this._descriptors.describeElement(filePath);
    return this._elementsMatcher.isElementMatch(description, selector, options);
  }
  /**
   * Determines if a dependency matches a given selector.
   * @param dependencyData The data describing the dependency
   * @param selector The selector to match against
   * @param options Extra matcher options
   * @returns True if the dependency matches the selector, false otherwise
   */
  _isDependencyMatch(dependencyData, selector, options) {
    const description = this._descriptors.describeDependency(dependencyData);
    return this._dependenciesMatcher.isDependencyMatch(
      description,
      selector,
      options
    );
  }
  isMatch(descriptorOptions, selector, options) {
    if (isString(descriptorOptions)) {
      return this._isElementMatch(
        descriptorOptions,
        selector,
        options
      );
    }
    return this._isDependencyMatch(
      descriptorOptions,
      selector,
      options
    );
  }
  /**
   * Determines the selector matching for an element.
   * @param filePath The file path of the element
   * @param selector The selectors to match against
   * @param options Extra options for matching
   * @returns The matching selector data or null if no match is found
   */
  _getElementSelectorMatching(filePath, selector, options) {
    const description = this._descriptors.describeElement(filePath);
    return this._elementsMatcher.getSelectorMatching(
      description,
      selector,
      options
    );
  }
  /**
   * Determines the selector matching for a dependency.
   * @param dependencyData The data describing the dependency
   * @param selector The selectors to match against
   * @param options Extra options for matching
   * @returns The matching dependency result or null if no match is found
   */
  _getDependencySelectorMatching(dependencyData, selector, options) {
    const description = this._descriptors.describeDependency(dependencyData);
    return this._dependenciesMatcher.getSelectorsMatching(
      description,
      selector,
      options
    );
  }
  getSelectorMatching(descriptorOptions, selector, options) {
    if (isString(descriptorOptions)) {
      return this._getElementSelectorMatching(
        descriptorOptions,
        selector,
        options
      );
    }
    return this._getDependencySelectorMatching(
      descriptorOptions,
      selector,
      options
    );
  }
  getSelectorMatchingDescription(description, selector, options) {
    if (isElementsSelector(selector) && isElementDescription(description)) {
      return this._elementsMatcher.getSelectorMatching(
        description,
        selector,
        options
      );
    } else if (isDependencySelector(selector) && isDependencyDescription(description)) {
      return this._dependenciesMatcher.getSelectorsMatching(
        description,
        selector,
        options
      );
    }
    throw new Error(
      "Invalid arguments: Please provide a valid description and selector"
    );
  }
  /**
   * Describes an element given its file path.
   * @param filePath The path of the file to describe.
   * @returns The description of the element.
   */
  describeElement(filePath) {
    return this._descriptors.describeElement(filePath);
  }
  /**
   * Describes a dependency element given its dependency source and file path.
   * @param dependencySource The source of the dependency.
   * @param filePath The path of the file being the dependency, if known.
   * @returns The description of the dependency element.
   */
  describeDependencyElement(dependencySource, filePath) {
    return this._descriptors.describeDependencyElement(
      dependencySource,
      filePath
    );
  }
  /**
   * Describes elements in a dependency relationship, and provides additional information about the dependency itself.
   * @param options The options for describing the elements and the dependency details.
   * @returns The description of the dependency between the elements.
   */
  describeDependency(options) {
    return this._descriptors.describeDependency(options);
  }
  /**
   * Clears all caches.
   */
  clearCache() {
    this._descriptors.clearCache();
  }
  /**
   * Serializes the descriptors matchers cache to a plain object.
   * @returns The serialized cache
   */
  serializeCache() {
    return {
      descriptors: this._descriptors.serializeCache()
    };
  }
  /**
   * Sets the descriptors matchers cache from a serialized object.
   * @param serializedCache The serialized cache
   */
  setCacheFromSerialized(serializedCache) {
    this._descriptors.setCacheFromSerialized(serializedCache.descriptors);
  }
};

// src/Matcher/Micromatch.ts
import micromatch from "micromatch";
var MatchingResultsCache = class extends CacheManager {
  /**
   * Generates a unique cache key based on the value and pattern
   * @param param0 The cache key components
   * @returns The generated cache key
   */
  generateKey({ value, pattern }) {
    return `${value}::${isArray(pattern) ? pattern.join("|") : pattern}`;
  }
};
var CapturedValueCache = class extends CacheManager {
  /**
   * Generates a unique cache key based on the pattern and target
   * @param param0 The cache key components
   * @returns The generated cache key
   */
  generateKey({ pattern, target }) {
    return `${pattern}|${target}`;
  }
};
var Micromatch = class {
  /**
   * Cache for micromatch matching results
   */
  _matchingResultsCache;
  /**
   * Cache for micromatch captures
   */
  _capturesCache = new CacheManagerDisabled();
  /**
   * Cache for micromatch makeRe results
   */
  _makeReCache = new CacheManagerDisabled();
  /**
   * Creates an instance of Micromatch class.
   * @param cache Whether to use caching or not.
   */
  constructor(cache) {
    this._matchingResultsCache = cache ? new MatchingResultsCache() : new CacheManagerDisabled();
    this._capturesCache = cache ? new CapturedValueCache() : new CacheManagerDisabled();
    this._makeReCache = cache ? new CacheManager() : new CacheManagerDisabled();
  }
  /**
   * Clears all caches.
   */
  clearCache() {
    this._matchingResultsCache.clear();
    this._capturesCache.clear();
    this._makeReCache.clear();
  }
  /**
   * Serializes the current cache state.
   * @returns The serialized cache data.
   */
  serializeCache() {
    return {
      matchingResults: this._matchingResultsCache.serialize(),
      captures: this._capturesCache.serialize()
    };
  }
  /**
   * Restores the cache state from serialized data.
   * @param serializedCache The serialized cache data.
   */
  setFromSerialized(serializedCache) {
    this._matchingResultsCache.setFromSerialized(
      serializedCache.matchingResults
    );
    this._capturesCache.setFromSerialized(serializedCache.captures);
  }
  /**
   * Optimized micromatch match with caching.
   * @param value The value to match.
   * @param pattern The pattern to match against.
   * @returns True if the value matches the pattern, false otherwise.
   */
  isMatch(value, pattern) {
    const cacheKey = this._matchingResultsCache.getKey({
      value,
      pattern
    });
    if (this._matchingResultsCache.has(cacheKey)) {
      return this._matchingResultsCache.get(cacheKey);
    }
    const isMatch = micromatch.isMatch(value, pattern);
    this._matchingResultsCache.set(cacheKey, isMatch);
    return isMatch;
  }
  /**
   * Optimized micromatch capture with caching.
   * @param pattern The pattern to match against.
   * @param target The target string to test.
   * @returns Captured groups or null if no match.
   */
  capture(pattern, target) {
    const cacheKey = this._capturesCache.getKey({ pattern, target });
    if (this._capturesCache.has(cacheKey)) {
      return this._capturesCache.get(cacheKey);
    }
    const result = micromatch.capture(pattern, target);
    this._capturesCache.set(cacheKey, result);
    return result;
  }
  /**
   * Optimized micromatch makeRe with caching.
   * @param pattern The pattern to convert to RegExp.
   * @returns The RegExp instance.
   */
  makeRe(pattern) {
    if (this._makeReCache.has(pattern)) {
      return this._makeReCache.get(pattern);
    }
    const regexp = micromatch.makeRe(pattern);
    this._makeReCache.set(pattern, regexp);
    return regexp;
  }
};

// src/MatchersCache.ts
var MatchersCache = class extends CacheManager {
  /**
   * Generates a unique key based on the configuration options and element descriptors
   * @param params The configuration and element descriptors
   * @returns A unique string key
   */
  generateKey({
    config,
    elementDescriptors
  }) {
    const configHash = `${config.legacyTemplates}|${config.includePaths}|${config.ignorePaths}|${config.cache}`;
    const elementDescriptorsHash = elementDescriptors.map(
      (descriptor) => `${descriptor.type}|${descriptor.category}|${descriptor.pattern}|${descriptor.basePattern}|${descriptor.mode}|${descriptor.capture}|${descriptor.baseCapture}`
    ).join(",");
    return `${configHash}|:|${elementDescriptorsHash}`;
  }
};

// src/Elements.ts
var Elements = class {
  /** The global configuration options for Elements. Can be overridden when getting a descriptor */
  _globalConfigOptions;
  /** Cache manager for Matcher instances, unique for each different configuration */
  _matchersCache = new MatchersCache();
  /** Micromatch instances for pattern matching */
  _micromatchWithCache = new Micromatch(true);
  _micromatchWithoutCache = new Micromatch(false);
  /**
   * Creates a new Elements instance
   * @param configOptions The global configuration options for Elements. Can be overridden when getting a descriptor.
   */
  constructor(configOptions) {
    const globalConfig = new Config(configOptions);
    this._globalConfigOptions = globalConfig.options;
  }
  /**
   * Returns a serialized representation of the current state of the cache.
   * @returns A serialized representation of the cache.
   */
  serializeCache() {
    const matchersCache = Array.from(
      this._matchersCache.getAll().entries()
    ).reduce(
      (acc, [key, cache]) => {
        acc[key] = {
          config: cache.config,
          elementDescriptors: cache.elementDescriptors,
          cache: cache.matcher.serializeCache()
        };
        return acc;
      },
      {}
    );
    const micromatchCache = this._micromatchWithCache.serializeCache();
    return {
      matchers: matchersCache,
      micromatch: micromatchCache
    };
  }
  /**
   * Sets the Elements cache from a serialized representation.
   * @param serializedCache The serialized cache to set.
   */
  setCacheFromSerialized(serializedCache) {
    this._micromatchWithCache.setFromSerialized(serializedCache.micromatch);
    for (const key in serializedCache.matchers) {
      const matcher = this.getMatcher(
        serializedCache.matchers[key].elementDescriptors,
        serializedCache.matchers[key].config
      );
      matcher.setCacheFromSerialized(serializedCache.matchers[key].cache);
      this._matchersCache.set(key, {
        config: serializedCache.matchers[key].config,
        elementDescriptors: serializedCache.matchers[key].elementDescriptors,
        matcher
      });
    }
  }
  /**
   * Clears cache
   */
  clearCache() {
    for (const { matcher } of this._matchersCache.getAll().values()) {
      matcher.clearCache();
    }
    this._matchersCache.clear();
    this._micromatchWithCache.clearCache();
  }
  /**
   * Gets a Matcher instance for the given configuration options.
   * It uses caching to return the same instance for the same configuration options. If no options are provided, the global configuration options are used.
   * @param elementDescriptors The element descriptors to use.
   * @param config Optional configuration options to override the global ones.
   * @returns A matcher instance, unique for each different configuration.
   */
  getMatcher(elementDescriptors, config) {
    const optionsToUse = config || this._globalConfigOptions;
    const configInstance = new Config(optionsToUse);
    const cacheIsEnabled = configInstance.cache;
    const configOptionsNormalized = configInstance.options;
    const descriptorNormalizedOptions = configInstance.descriptorOptions;
    const matchersNormalizedOptions = configInstance.matchersOptions;
    const cacheKey = this._matchersCache.getKey({
      config: configOptionsNormalized,
      elementDescriptors
    });
    if (this._matchersCache.has(cacheKey)) {
      return this._matchersCache.get(cacheKey).matcher;
    }
    const micromatch2 = cacheIsEnabled ? this._micromatchWithCache : this._micromatchWithoutCache;
    const elementsMatcher = new ElementsMatcher(
      matchersNormalizedOptions,
      micromatch2
    );
    const dependenciesMatcher = new DependenciesMatcher(
      elementsMatcher,
      matchersNormalizedOptions,
      micromatch2
    );
    const matcher = new Matcher(
      elementDescriptors,
      elementsMatcher,
      dependenciesMatcher,
      descriptorNormalizedOptions,
      micromatch2
    );
    this._matchersCache.set(cacheKey, {
      config: configOptionsNormalized,
      elementDescriptors,
      matcher
    });
    return matcher;
  }
};
export {
  CacheManager,
  DEPENDENCY_KINDS_MAP,
  DEPENDENCY_KIND_TYPE,
  DEPENDENCY_KIND_TYPEOF,
  DEPENDENCY_KIND_VALUE,
  DEPENDENCY_RELATIONSHIPS_INVERTED_MAP,
  DEPENDENCY_RELATIONSHIPS_MAP,
  ELEMENT_DESCRIPTOR_MODES_MAP,
  ELEMENT_ORIGINS_MAP,
  Elements,
  isBaseElement,
  isBaseElementDescriptor,
  isBaseElementSelectorData,
  isCapturedValuesSelector,
  isCoreDependencyElement,
  isDependencyDescription,
  isDependencyElementDescription,
  isDependencyKind,
  isDependencyRelationship,
  isDependencyRelationshipDescription,
  isDependencySelector,
  isElementDescription,
  isElementDescriptor,
  isElementDescriptorMode,
  isElementDescriptorPattern,
  isElementDescriptorWithCategory,
  isElementDescriptorWithType,
  isElementSelector,
  isElementSelectorData,
  isElementSelectorWithLegacyOptions,
  isElementsDependencyInfo,
  isElementsSelector,
  isExternalDependencyElement,
  isExternalLibrariesSelector,
  isExternalLibrarySelector,
  isExternalLibrarySelectorOptions,
  isExternalLibrarySelectorOptionsWithPath,
  isExternalLibrarySelectorOptionsWithSpecifiers,
  isExternalLibrarySelectorWithOptions,
  isIgnoredElement,
  isInternalDependency,
  isKnownLocalElement,
  isLocalDependencyElement,
  isLocalElement,
  isSimpleElementSelectorByType,
  isUnknownLocalElement,
  normalizeElementsSelector
};
//# sourceMappingURL=index.mjs.map