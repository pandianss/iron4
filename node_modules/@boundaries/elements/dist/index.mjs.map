{"version":3,"sources":["../src/Config/Config.ts","../src/Matcher/BaseElementsMatcher.ts","../src/Support/TypeGuards.ts","../src/Matcher/MatcherHelpers.ts","../src/Matcher/DependenciesMatcher.ts","../src/Matcher/ElementsMatcher.ts","../src/Descriptor/ElementsDescriptor.types.ts","../src/Descriptor/ElementsDescriptorHelpers.ts","../src/Descriptor/DependenciesDescriptor.types.ts","../src/Descriptor/DependenciesDescriptorHelpers.ts","../src/Cache/Cache.ts","../src/Cache/CacheDisabled.ts","../src/Descriptor/DependenciesDescriptionsCache.ts","../src/Descriptor/DependenciesDescriptor.ts","../src/Descriptor/ElementsDescriptor.ts","../src/Descriptor/Descriptors.ts","../src/Matcher/Matcher.ts","../src/Matcher/Micromatch.ts","../src/MatchersCache.ts","../src/Elements.ts"],"sourcesContent":["import type {\n  ConfigOptions,\n  MicromatchPattern,\n  ConfigOptionsNormalized,\n  DescriptorOptionsNormalized,\n  MatchersOptionsNormalized,\n} from \"./Config.types\";\n\nexport class Config {\n  /** The ignore paths */\n  private readonly _ignorePaths?: MicromatchPattern;\n  /** The include paths */\n  private readonly _includePaths?: MicromatchPattern;\n  /** Whether legacy template support is enabled */\n  private readonly _legacyTemplates: boolean;\n  /** Whether the cache is enabled */\n  private readonly _cache: boolean;\n  /**\n   * Creates a new Config instance\n   * @param options Configuration options\n   */\n  constructor(options?: ConfigOptions) {\n    this._ignorePaths = options?.ignorePaths;\n    this._includePaths = options?.includePaths;\n    this._legacyTemplates = options?.legacyTemplates ?? true;\n    this._cache = options?.cache ?? true;\n  }\n\n  /**\n   * The normalized configuration options\n   */\n  public get options(): ConfigOptionsNormalized {\n    return {\n      ignorePaths: this._ignorePaths,\n      includePaths: this._includePaths,\n      legacyTemplates: this._legacyTemplates,\n      cache: this._cache,\n    };\n  }\n\n  /**\n   * Normalized options for descriptors\n   */\n  public get descriptorOptions(): DescriptorOptionsNormalized {\n    return {\n      ignorePaths: this._ignorePaths,\n      includePaths: this._includePaths,\n      cache: this._cache,\n    };\n  }\n\n  /**\n   * Normalized options for element matchers\n   */\n  public get matchersOptions(): MatchersOptionsNormalized {\n    return {\n      legacyTemplates: this._legacyTemplates,\n    };\n  }\n\n  /**\n   * Whether caching is enabled\n   */\n  public get cache(): boolean {\n    return this._cache;\n  }\n}\n","import Handlebars from \"handlebars\";\n\nimport type { MicromatchPattern, MatchersOptionsNormalized } from \"../Config\";\nimport type {\n  LocalElementKnown,\n  CoreDependencyElement,\n  LocalDependencyElementKnown,\n  ExternalDependencyElement,\n  BaseElement,\n  IgnoredElement,\n} from \"../Descriptor\";\nimport {\n  isArray,\n  isObjectWithProperty,\n  isString,\n  isBoolean,\n  isNullish,\n} from \"../Support\";\n\nimport type {\n  BaseElementSelector,\n  BaseElementSelectorData,\n  DependencyElementSelectorData,\n  DependencyElementSelector,\n  BaseElementsSelector,\n  ElementsSelector,\n  ElementSelector,\n  ElementSelectorData,\n  DependencyElementsSelector,\n  TemplateData,\n  SelectableElement,\n} from \"./Matcher.types\";\nimport {\n  isSimpleElementSelectorByType,\n  isElementSelectorWithLegacyOptions,\n  isElementSelectorData,\n} from \"./MatcherHelpers\";\nimport type { Micromatch } from \"./Micromatch\";\n\nconst HANDLEBARS_TEMPLATE_REGEX = /{{\\s*[^}\\s]+(?:\\s+[^}\\s]+)*\\s*}}/;\nconst LEGACY_TEMPLATE_REGEX = /\\$\\{([^}]+)\\}/g;\n\n/**\n * Normalizes a selector into ElementSelectorData format.\n * @param selector The selector to normalize.\n * @returns The normalized selector data.\n */\nfunction normalizeSelector(\n  selector: BaseElementSelector\n): BaseElementSelectorData;\nfunction normalizeSelector(\n  selector: DependencyElementSelector\n): DependencyElementSelectorData;\nfunction normalizeSelector(selector: ElementSelector): ElementSelectorData {\n  if (isSimpleElementSelectorByType(selector)) {\n    return { type: selector };\n  }\n\n  if (isElementSelectorData(selector)) {\n    return { ...selector };\n  }\n\n  if (isElementSelectorWithLegacyOptions(selector)) {\n    return {\n      type: selector[0],\n      captured: selector[1] ? { ...selector[1] } : undefined,\n    };\n  }\n  throw new Error(\"Invalid element selector\");\n}\n\n/**\n * Normalizes an ElementsSelector into an array of ElementSelectorData.\n * @param elementsSelector The elements selector, in any supported format.\n * @returns The normalized array of selector data.\n */\nexport function normalizeElementsSelector(\n  elementsSelector: BaseElementsSelector\n): BaseElementSelectorData[];\nexport function normalizeElementsSelector(\n  elementsSelector: DependencyElementsSelector\n): DependencyElementSelectorData[];\nexport function normalizeElementsSelector(\n  elementsSelector: ElementsSelector\n): ElementSelectorData[] {\n  if (isArray(elementsSelector)) {\n    if (isElementSelectorWithLegacyOptions(elementsSelector)) {\n      return [normalizeSelector(elementsSelector)];\n    }\n    return elementsSelector.map((sel) => normalizeSelector(sel));\n  }\n  return [normalizeSelector(elementsSelector)];\n}\n\n/**\n * Base matcher class to determine if elements or dependencies match a given selector.\n */\nexport class BaseElementsMatcher {\n  /**\n   * Option to use legacy templates with ${} syntax.\n   */\n  protected readonly _legacyTemplates: boolean;\n\n  /**\n   * Micromatch instance for matching.\n   */\n  protected micromatch: Micromatch;\n\n  /**\n   * Creates a new BaseElementsMatcher.\n   * @param config Configuration options for the matcher.\n   * @param globalCache Global cache instance.\n   */\n  constructor(config: MatchersOptionsNormalized, micromatch: Micromatch) {\n    this.micromatch = micromatch;\n    this._legacyTemplates = config.legacyTemplates;\n  }\n\n  /**\n   * Converts a template with ${} to Handlebars {{}} templates for backwards compatibility.\n   * @param template The template to convert.\n   * @returns The converted template.\n   */\n  private _getBackwardsCompatibleTemplate(template: string): string {\n    return template.replaceAll(LEGACY_TEMPLATE_REGEX, \"{{ $1 }}\");\n  }\n\n  /**\n   * Determines if a template contains Handlebars syntax.\n   * @param template The template to check.\n   * @returns True if the template contains Handlebars syntax, false otherwise.\n   */\n  private _isHandlebarsTemplate(template: string): boolean {\n    return HANDLEBARS_TEMPLATE_REGEX.test(template);\n  }\n\n  /**\n   * Returns a rendered template using the provided template data.\n   * Optimized version with template caching for better performance.\n   * @param template The template to render.\n   * @param templateData The data to use for replace in the template.\n   * @returns The rendered template.\n   */\n  private _getRenderedTemplate(\n    template: string,\n    templateData: TemplateData\n  ): string {\n    const templateToUse = this._legacyTemplates\n      ? this._getBackwardsCompatibleTemplate(template)\n      : template;\n    if (!this._isHandlebarsTemplate(templateToUse)) {\n      // If the template does not contain any Handlebars syntax, return it as is.\n      return template;\n    }\n\n    const compiledTemplate = Handlebars.compile(templateToUse);\n\n    return compiledTemplate(templateData);\n  }\n\n  /**\n   * Returns rendered templates using the provided template data.\n   * @param template The templates to render.\n   * @param extraTemplateData The data to use for replace in the templates.\n   * @returns The rendered templates.\n   */\n  protected getRenderedTemplates(\n    template: MicromatchPattern,\n    templateData: TemplateData\n  ): MicromatchPattern {\n    if (isArray(template)) {\n      return template.map((temp) => {\n        return this._getRenderedTemplate(temp, templateData);\n      });\n    }\n    return this._getRenderedTemplate(template, templateData);\n  }\n\n  /**\n   * Returns whether the given value matches the micromatch pattern, converting non-string values to strings.\n   * Optimized version with caching for better performance.\n   * @param value The value to check.\n   * @param pattern The micromatch pattern to match against.\n   * @returns Whether the value matches the pattern.\n   */\n  protected isMicromatchMatch(\n    value: unknown,\n    pattern: MicromatchPattern\n  ): boolean {\n    // Convert non-string element values to string for matching.\n    const elementValueToCheck =\n      !value || !isString(value) ? String(value) : value;\n    // Clean empty strings from arrays to avoid matching them.\n    const selectorValueToCheck = isArray(pattern)\n      ? pattern.filter(Boolean)\n      : pattern;\n\n    return this.micromatch.isMatch(elementValueToCheck, selectorValueToCheck);\n  }\n\n  /**\n   * Returns whether the given value matches the micromatch pattern after rendering it as a template.\n   * @param pattern The micromatch pattern to render and match against.\n   * @param templateData The data to use for rendering the pattern as a template.\n   * @param value The value to check.\n   * @returns Whether the value matches the rendered pattern.\n   */\n  protected isTemplateMicromatchMatch(\n    pattern: MicromatchPattern,\n    templateData: TemplateData,\n    value?: unknown\n  ): boolean {\n    // If the element value is nullish, it cannot match anything.\n    if (isNullish(value)) {\n      return false;\n    }\n\n    const patternRendered = this.getRenderedTemplates(pattern, templateData);\n\n    // Empty rendered selector values do not match anything. (It may happen due to templates rendering to empty strings.)\n    if (!patternRendered) {\n      return false;\n    }\n\n    // Clean empty strings from arrays to avoid matching them.\n    const filteredPattern = isArray(patternRendered)\n      ? patternRendered.filter(Boolean)\n      : patternRendered;\n\n    if (isArray(value)) {\n      // If the value is an array, we check if any of its items match the pattern.\n      return value.some((val) => this.isMicromatchMatch(val, filteredPattern));\n    }\n    return this.isMicromatchMatch(value, filteredPattern);\n  }\n\n  /**\n   * Whether the given element key matches the selector key as booleans.\n   * @param param0 The parameters object.\n   * @returns Whether the element key matches the selector key.\n   */\n  protected isElementKeyBooleanMatch<\n    T extends BaseElement,\n    S extends BaseElementSelectorData,\n  >({\n    /** The element to check. */\n    element,\n    /** The selector to check against. */\n    selector,\n    /** The key of the element to check. */\n    elementKey,\n    /** The key of the selector to check against. */\n    selectorKey,\n  }: {\n    /** The element to check. */\n    element: T;\n    /** The selector to check against. */\n    selector: S;\n    /** The key of the element to check. */\n    elementKey: keyof T;\n    /** The key of the selector to check against. */\n    selectorKey: keyof S;\n  }): boolean {\n    // The selector key does not exist in the selector, so it matches any value.\n    if (!(selectorKey in selector)) {\n      return true;\n    }\n    // The selector key exists in the selector, but it does not exist in the element. No match.\n    // istanbul ignore next - This case should not happen due to element validations, but we guard against it anyway.\n    if (!(elementKey in element)) {\n      return false;\n    }\n    // Both values must be booleans to match.\n    if (!isBoolean(selector[selectorKey]) || !isBoolean(element[elementKey])) {\n      return false;\n    }\n    return (\n      (selector[selectorKey] as boolean) === (element[elementKey] as boolean)\n    );\n  }\n\n  /**\n   * Whether the given element key matches the selector key using micromatch.\n   * @param param0 The parameters object.\n   * @returns Whether the element key matches the selector key.\n   */\n  protected isElementKeyMicromatchMatch<\n    T extends SelectableElement,\n    S extends BaseElementSelectorData | DependencyElementSelectorData,\n  >({\n    element,\n    selector,\n    elementKey,\n    selectorKey,\n    selectorValue,\n    templateData,\n  }: {\n    /** The element to check. */\n    element: T;\n    /** The selector to check against. */\n    selector: S;\n    /** The key of the element to check. */\n    elementKey: T extends LocalElementKnown\n      ? keyof LocalElementKnown\n      : T extends CoreDependencyElement\n        ? keyof CoreDependencyElement\n        : T extends ExternalDependencyElement\n          ? keyof ExternalDependencyElement\n          : T extends IgnoredElement\n            ? keyof IgnoredElement\n            : keyof LocalDependencyElementKnown;\n    /** The key of the selector to check against. */\n    selectorKey: S extends DependencyElementSelectorData\n      ? keyof DependencyElementSelectorData\n      : keyof BaseElementSelectorData;\n    /** The value of the selector key to check against. */\n    selectorValue?: MicromatchPattern;\n    /** Data to pass when the selector value is rendered as a template */\n    templateData: TemplateData;\n  }): boolean {\n    // The selector key does not exist in the selector, so it matches any value. We also check the value passed separately in order to improve typing inference.\n    if (!(selectorKey in selector)) {\n      return true;\n    }\n    // Empty selector values do not match anything.\n    if (!selectorValue) {\n      return false;\n    }\n\n    // The selector key exists in the selector, but it does not exist in the element. No match.\n    if (!isObjectWithProperty(element, elementKey)) {\n      return false;\n    }\n\n    return this.isTemplateMicromatchMatch(\n      selectorValue,\n      templateData,\n      element[elementKey]\n    );\n  }\n}\n","/**\n * Determines if the given value is a string.\n * @param value The value to check.\n * @returns True if the value is a string, false otherwise.\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\n/**\n * Determines if the given value is not null or undefined.\n * @param value The value to check.\n * @returns True if the value is not null or undefined, false otherwise.\n */\nexport function isNullish(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Determines if the given value is null\n * @param value The value to check\n * @returns True if the value is null, false otherwise\n */\nexport function isNull(value: unknown): value is null {\n  return value === null;\n}\n\n/**\n * Determines if the given value is a boolean\n * @param value The value to check\n * @returns True if the value is a boolean, false otherwise\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === \"boolean\";\n}\n\n/**\n * Determines if the given value is a non-null object.\n * @param value The value to check.\n * @returns True if the value is a non-null object, false otherwise.\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return (\n    !isNullish(value) &&\n    !isBoolean(value) &&\n    !isArray(value) &&\n    typeof value === \"object\"\n  );\n}\n\n/**\n * Determines if the given object is an empty object.\n * @param obj The object to check.\n * @returns True if the object is empty, false otherwise.\n */\nexport function isEmptyObject(obj: unknown): boolean {\n  return isObject(obj) && Object.keys(obj).length === 0;\n}\n\n/**\n * Determines if the given value is an array.\n * @param value The value to check.\n * @returns True if the value is an array, false otherwise.\n */\nexport function isArray(value: unknown): value is unknown[] {\n  return Array.isArray(value);\n}\n\n/**\n * Determines if the given array is empty\n * @param arr The array to check\n * @returns Whether the array is empty or not\n */\nexport function isEmptyArray(arr: unknown[]): arr is [] {\n  return arr.length === 0;\n}\n\n/**\n * Determines if the given value is a string array.\n * @param value The value to check.\n * @returns True if the value is a string array, false otherwise.\n */\nexport function isStringArray(value: unknown): value is string[] {\n  return isArray(value) && value.every(isString);\n}\n\n/**\n * Determines if the given value is an object with the specified property.\n * @param value The value to check.\n * @param key The property key to check for.\n * @returns True if the value is an object with the specified property, false otherwise.\n */\nexport function isObjectWithProperty<Key extends string>(\n  value: unknown,\n  key: Key\n): value is Record<Key, unknown> & Record<string, unknown> {\n  return isObject(value) && Object.hasOwn(value, key);\n}\n\n/**\n * Determines if the given value is an object with any of the specified properties.\n * @param value The value to check\n * @param keys The keys to check for\n * @returns True if the value is an object with any of the specified properties, false otherwise\n */\nexport function isObjectWithAnyOfProperties<Keys extends string>(\n  value: unknown,\n  keys: Keys[]\n): value is Record<Keys, unknown> & Record<string, unknown> {\n  return isObject(value) && keys.some((key) => key in value);\n}\n","import {\n  isObject,\n  isString,\n  isArray,\n  isStringArray,\n  isObjectWithProperty,\n  isEmptyArray,\n  isObjectWithAnyOfProperties,\n} from \"../Support/TypeGuards\";\n\nimport type {\n  ElementSelector,\n  ElementSelectorWithOptions,\n  ElementSelectors,\n  ExternalLibrarySelector,\n  ExternalLibrarySelectorWithOptions,\n  ExternalLibrariesSelector,\n  CapturedValuesSelector,\n  ExternalLibrarySelectorOptions,\n  SimpleElementSelectorByType,\n  ElementSelectorData,\n  DependencySelector,\n} from \"./Matcher.types\";\n\n/**\n * Determines if the given value is a captured values selector.\n * @param value The value to check.\n * @returns True if the value is a captured values selector, false otherwise.\n */\nexport function isCapturedValuesSelector(\n  value: unknown\n): value is CapturedValuesSelector {\n  if (!isObject(value) || isArray(value)) {\n    return false;\n  }\n\n  // Ensure all values are strings or string arrays\n  return Object.values(value).every(\n    (pattern) => isString(pattern) || isStringArray(pattern)\n  );\n}\n\n/**\n * Determines if the given value is a simple element selector.\n * @param value The value to check.\n * @returns True if the value is a simple element selector, false otherwise.\n */\nexport function isSimpleElementSelectorByType(\n  value: unknown\n): value is SimpleElementSelectorByType {\n  return isString(value);\n}\n\n/**\n * Determines if the given selector is a base element selector.\n * @param value The value to check.\n * @returns True if the selector is a base element selector\n */\nexport function isBaseElementSelectorData(\n  value: unknown\n): value is ElementSelectorData {\n  return isObjectWithAnyOfProperties(value, [\n    \"path\",\n    \"elementPath\",\n    \"internalPath\",\n    \"type\",\n    \"category\",\n    \"captured\",\n    \"origin\",\n    \"source\",\n    \"baseSource\",\n    \"isIgnored\",\n    \"isUnknown\",\n  ]);\n}\n\n/**\n * Determines if the given selector is an element or dependency element selector data.\n * @param value The value to check.\n * @returns True if the selector is an element or dependency element selector data, false otherwise.\n */\nexport function isElementSelectorData(\n  value: unknown\n): value is ElementSelectorData {\n  return (\n    isBaseElementSelectorData(value) ||\n    isObjectWithAnyOfProperties(value, [\n      \"relationship\",\n      \"kind\",\n      \"specifiers\",\n      \"nodeKind\",\n    ])\n  );\n}\n\n/**\n * Determines if the given selector is an element selector with options.\n * @param value The value to check.\n * @returns True if the selector is an element selector with options, false otherwise.\n */\nexport function isElementSelectorWithLegacyOptions(\n  value: unknown\n): value is ElementSelectorWithOptions {\n  return (\n    isArray(value) &&\n    ((value.length === 2 &&\n      isSimpleElementSelectorByType(value[0]) &&\n      // NOTE: Arrays of length 2 with captured values selector as second element having a key \"type\" or \"category\" will be treated as legacy options instead of two different selectors. We have to live with this limitation for now.\n      isCapturedValuesSelector(value[1])) ||\n      // NOTE: Backwards compatibility: Allow arrays of length 1 with simple element selector. Some users might defined arrays without options.\n      (value.length === 1 && isSimpleElementSelectorByType(value[0])))\n  );\n}\n\n/**\n * Determines if the given value is an element selector.\n * @param value The value to check.\n * @returns True if the value is an element selector, false otherwise.\n */\nexport function isElementSelector(value: unknown): value is ElementSelector {\n  return (\n    isSimpleElementSelectorByType(value) ||\n    isElementSelectorData(value) ||\n    isElementSelectorWithLegacyOptions(value)\n  );\n}\n\n/**\n * Determines if the given value is an elements selector.\n * @param value The value to check.\n * @returns True if the value is an elements selector, false otherwise.\n */\nexport function isElementsSelector(value: unknown): value is ElementSelectors {\n  return (\n    isElementSelector(value) ||\n    (isArray(value) && !isEmptyArray(value) && value.every(isElementSelector))\n  );\n}\n\n/**\n * Determines if the given value is a dependency selector.\n * @param value The value to check\n * @returns True if the value is a dependency selector, false otherwise.\n */\nexport function isDependencySelector(\n  value: unknown\n): value is DependencySelector {\n  return isObjectWithAnyOfProperties(value, [\"from\", \"to\"]);\n}\n\n/**\n * Determines if the given value is external library selector options with a path.\n * @param value The value to check.\n * @returns True if the value is external library selector options with a path, false otherwise.\n */\nexport function isExternalLibrarySelectorOptionsWithPath(\n  value: unknown\n): value is ExternalLibrarySelectorOptions & { path: string | string[] } {\n  return (\n    isObjectWithProperty(value, \"path\") &&\n    (isString(value.path) || isStringArray(value.path))\n  );\n}\n\n/**\n * Determines if the given value is external library selector options with specifiers.\n * @param value The value to check.\n * @returns True if the value is external library selector options with specifiers, false otherwise.\n */\nexport function isExternalLibrarySelectorOptionsWithSpecifiers(\n  value: unknown\n): value is ExternalLibrarySelectorOptions & { specifiers: string[] } {\n  return (\n    isObjectWithProperty(value, \"specifiers\") && isStringArray(value.specifiers)\n  );\n}\n\n/**\n * Determines if the given value is external library selector options.\n * @param value The value to check.\n * @returns True if the value is external library selector options, false otherwise.\n */\nexport function isExternalLibrarySelectorOptions(\n  value: unknown\n): value is ExternalLibrarySelectorOptions {\n  return (\n    isExternalLibrarySelectorOptionsWithPath(value) ||\n    isExternalLibrarySelectorOptionsWithSpecifiers(value)\n  );\n}\n\n/**\n * Determines if the given value is an external library selector with options.\n * @param value The value to check.\n * @returns True if the value is an external library selector with options, false otherwise.\n */\nexport function isExternalLibrarySelectorWithOptions(\n  value: unknown\n): value is ExternalLibrarySelectorWithOptions {\n  return (\n    isArray(value) &&\n    value.length === 2 &&\n    isSimpleElementSelectorByType(value[0]) &&\n    isExternalLibrarySelectorOptions(value[1])\n  );\n}\n\n/**\n * Determines if the given value is an external library selector.\n * @param value The value to check.\n * @returns True if the value is an external library selector, false otherwise.\n */\nexport function isExternalLibrarySelector(\n  value: unknown\n): value is ExternalLibrarySelector {\n  return (\n    isSimpleElementSelectorByType(value) ||\n    isExternalLibrarySelectorWithOptions(value)\n  );\n}\n\n/**\n * Determines if the given value is an external libraries selector.\n * @param value The value to check.\n * @returns True if the value is an external libraries selector, false otherwise.\n */\nexport function isExternalLibrariesSelector(\n  value: unknown\n): value is ExternalLibrariesSelector {\n  return (\n    isExternalLibrarySelector(value) ||\n    (isArray(value) &&\n      !isEmptyArray(value) &&\n      value.every(isExternalLibrarySelector))\n  );\n}\n","import type { MatchersOptionsNormalized } from \"../Config\";\nimport type {\n  DependencyDescription,\n  DependencyRelationship,\n} from \"../Descriptor\";\nimport { isNullish } from \"../Support\";\n\nimport {\n  BaseElementsMatcher,\n  normalizeElementsSelector,\n} from \"./BaseElementsMatcher\";\nimport type { ElementsMatcher } from \"./ElementsMatcher\";\nimport type {\n  BaseElementSelector,\n  TemplateData,\n  DependencySelector,\n  DependencyElementSelectorData,\n  DependencySelectorNormalized,\n  BaseElementSelectorData,\n  MatcherOptions,\n  MatcherOptionsDependencySelectorsGlobals,\n  DependencyMatchResult,\n} from \"./Matcher.types\";\nimport {\n  isBaseElementSelectorData,\n  isDependencySelector,\n} from \"./MatcherHelpers\";\nimport type { Micromatch } from \"./Micromatch\";\n\n/**\n * Matcher class to determine if dependencies match a given dependencies selector.\n */\nexport class DependenciesMatcher extends BaseElementsMatcher {\n  /**\n   * Elements matcher to use for matching elements within dependencies.\n   */\n  private readonly _elementsMatcher: ElementsMatcher;\n\n  /**\n   * Creates a new DependenciesMatcher.\n   * @param elementsMatcher Elements matcher to use for matching elements within dependencies.\n   * @param config Configuration options for the matcher.\n   * @param micromatch Micromatch instance for matching.\n   * @param globalCache Global cache instance.\n   */\n  constructor(\n    elementsMatcher: ElementsMatcher,\n    config: MatchersOptionsNormalized,\n    micromatch: Micromatch\n  ) {\n    super(config, micromatch);\n    this._elementsMatcher = elementsMatcher;\n  }\n\n  /**\n   * Normalizes selector into DependencySelectorNormalized format, containing arrays of selectors data.\n   * @param selector The dependency selector to normalize.\n   * @returns The normalized dependency selector.\n   */\n  private _normalizeDependencySelector(\n    selector: DependencySelector,\n    dependencySelectorsGlobals: MatcherOptionsDependencySelectorsGlobals\n  ): DependencySelectorNormalized {\n    if (!isDependencySelector(selector)) {\n      throw new Error(\"Invalid dependency selector\");\n    }\n    let normalizedDependencySelectors = selector.to\n      ? normalizeElementsSelector(selector.to)\n      : null;\n\n    if (normalizedDependencySelectors) {\n      normalizedDependencySelectors = normalizedDependencySelectors.map(\n        (depSelector) => {\n          return {\n            ...dependencySelectorsGlobals,\n            ...depSelector,\n          };\n        }\n      );\n    }\n\n    return {\n      from: selector.from ? normalizeElementsSelector(selector.from) : null,\n      to: normalizedDependencySelectors,\n    };\n  }\n\n  /**\n   * Converts a DependencyElementSelectorData to a BaseElementSelectorData, by removing dependency-specific properties.\n   * @param selector The dependency element selector data.\n   * @returns The base element selector data.\n   */\n  private _convertDependencyElementSelectorDataToBaseElementSelectorData(\n    selector: DependencyElementSelectorData\n  ): BaseElementSelector {\n    const baseSelector: Partial<BaseElementSelector> = {};\n\n    if (selector.type) {\n      baseSelector.type = selector.type;\n    }\n\n    if (selector.category) {\n      baseSelector.category = selector.category;\n    }\n\n    if (selector.path) {\n      baseSelector.path = selector.path;\n    }\n\n    if (selector.elementPath) {\n      baseSelector.elementPath = selector.elementPath;\n    }\n\n    if (selector.internalPath) {\n      baseSelector.internalPath = selector.internalPath;\n    }\n\n    if (selector.captured) {\n      baseSelector.captured = selector.captured;\n    }\n\n    if (selector.origin) {\n      baseSelector.origin = selector.origin;\n    }\n\n    if (selector.baseSource) {\n      baseSelector.baseSource = selector.baseSource;\n    }\n\n    if (selector.source) {\n      baseSelector.source = selector.source;\n    }\n\n    if (!isNullish(selector.isIgnored)) {\n      baseSelector.isIgnored = selector.isIgnored;\n    }\n\n    if (!isNullish(selector.isUnknown)) {\n      baseSelector.isUnknown = selector.isUnknown;\n    }\n\n    return baseSelector as BaseElementSelector;\n  }\n\n  /**\n   * Returns the selectors matching result for the given dependency.\n   * @param dependency The dependency description.\n   * @param selector The dependency selector normalized.\n   * @param extraTemplateData The extra template data for selector values.\n   * @returns The selectors matching result for the given dependency.\n   */\n  private _getSelectorMatching(\n    dependency: DependencyDescription,\n    selector: DependencySelectorNormalized,\n    templateData: TemplateData\n  ): DependencyMatchResult {\n    const getFromSelectorMatching =\n      (): DependencyElementSelectorData | null => {\n        for (const fromSelectorData of selector.from!) {\n          const fromMatch = this._elementsMatcher.isElementMatch(\n            dependency.from,\n            fromSelectorData,\n            {\n              extraTemplateData: templateData,\n            }\n          );\n          const dependencyPropertiesMatch = this._dependencyFromPropertiesMatch(\n            dependency,\n            [fromSelectorData],\n            templateData\n          );\n          if (fromMatch && dependencyPropertiesMatch) {\n            return fromSelectorData;\n          }\n        }\n        return null;\n      };\n\n    const getToSelectorMatching = (): DependencyElementSelectorData | null => {\n      for (const toSelectorData of selector.to!) {\n        const toMatch = isBaseElementSelectorData(toSelectorData)\n          ? this._elementsMatcher.isElementMatch(\n              dependency.to,\n              this._convertDependencyElementSelectorDataToBaseElementSelectorData(\n                toSelectorData\n              ),\n              {\n                extraTemplateData: templateData,\n              }\n            )\n          : true;\n        const dependencyPropertiesMatch = this._dependencyToPropertiesMatch(\n          dependency,\n          [toSelectorData],\n          templateData\n        );\n        if (toMatch && dependencyPropertiesMatch) {\n          return toSelectorData;\n        }\n      }\n      return null;\n    };\n\n    const fromSelectorMatching = selector.from\n      ? getFromSelectorMatching()\n      : null;\n    const toSelectorMatching = selector.to ? getToSelectorMatching() : null;\n\n    return {\n      from: fromSelectorMatching,\n      to: toSelectorMatching,\n      isMatch: Boolean(\n        (selector.from ? fromSelectorMatching : true) &&\n          (selector.to ? toSelectorMatching : true)\n      ),\n    };\n  }\n\n  /**\n   * Determines if the dependency relationship matches the selector.\n   * @param dependency The dependency description.\n   * @param selector The data of an element selector.\n   * @returns Whether the dependency relationship matches the selector.\n   */\n  private _relationshipMatches(\n    selector: DependencyElementSelectorData,\n    relationship: DependencyRelationship | null,\n    templateData: TemplateData\n  ): boolean {\n    if (!selector.relationship) {\n      return true;\n    }\n    return this.isTemplateMicromatchMatch(\n      selector.relationship,\n      templateData,\n      relationship\n    );\n  }\n\n  /**\n   * Determines if the selector matches an specific kind\n   * @param selector The dependency selector data\n   * @param kind Kind to check\n   * @param templateData The template data for rendering selector values\n   * @returns Whether the selector matches the kind\n   */\n  private _kindMatches(\n    selector: DependencyElementSelectorData,\n    kind: string,\n    templateData: TemplateData\n  ): boolean {\n    if (!selector.kind) {\n      return true;\n    }\n    return this.isTemplateMicromatchMatch(selector.kind, templateData, kind);\n  }\n\n  /**\n   * Determines if the selector matches some of the specifiers\n   * @param selector The dependency selector data\n   * @param specifiers Specifiers to check\n   * @param templateData The template data for rendering selector values\n   * @returns Whether the selector matches some of the specifiers\n   */\n  private _specifierMatches(\n    selector: DependencyElementSelectorData,\n    specifiers: string[] | null,\n    templateData: TemplateData\n  ): boolean {\n    if (!selector.specifiers) {\n      return true;\n    }\n    return this.isTemplateMicromatchMatch(\n      selector.specifiers,\n      templateData,\n      specifiers\n    );\n  }\n\n  /**\n   * Determines if the selector matches the nodeKind\n   * @param selector The dependency selector data\n   * @param nodeKind The nodeKind to check\n   * @param templateData The template data for rendering selector values\n   * @returns Whether the selector matches the nodeKind\n   */\n  private _nodeKindMatches(\n    selector: DependencyElementSelectorData,\n    nodeKind: string | null,\n    templateData: TemplateData\n  ): boolean {\n    if (!selector.nodeKind) {\n      return true;\n    }\n    return this.isTemplateMicromatchMatch(\n      selector.nodeKind,\n      templateData,\n      nodeKind\n    );\n  }\n\n  /**\n   * Determines if the dependency description matches the selector for 'from'.\n   * @param dependency The dependency description.\n   * @param fromSelector The selector for 'from' elements.\n   * @param templateData The template data for rendering selector values\n   * @returns Whether the dependency properties match the selector for 'from'.\n   */\n  private _dependencyFromPropertiesMatch(\n    dependency: DependencyDescription,\n    fromSelector: BaseElementSelectorData[],\n    templateData: TemplateData\n  ): boolean {\n    return fromSelector.some((selectorData) =>\n      this._relationshipMatches(\n        selectorData,\n        dependency.dependency.relationship.from,\n        templateData\n      )\n    );\n  }\n\n  /**\n   * Determines if the dependency description matches the selector for 'to'.\n   * @param dependency The dependency description.\n   * @param toSelector The selector for 'to' elements.\n   * @param templateData The template data for rendering selector values\n   * @returns Whether the dependency properties match the selector for 'to'.\n   */\n  private _dependencyToPropertiesMatch(\n    dependency: DependencyDescription,\n    toSelector: DependencyElementSelectorData[],\n    templateData: TemplateData\n  ): boolean {\n    // Extract dependency properties once to avoid repeated property access\n    const dependencyInfo = dependency.dependency;\n    const relationshipTo = dependencyInfo.relationship.to;\n    const kind = dependencyInfo.kind;\n    const nodeKind = dependencyInfo.nodeKind;\n    const specifiers = dependencyInfo.specifiers;\n\n    // Use a traditional for loop for better performance and early exit\n    for (const selectorData of toSelector) {\n      // Order checks by likelihood of failure (most restrictive first)\n      // and use short-circuit evaluation for performance\n      if (\n        this._kindMatches(selectorData, kind, templateData) &&\n        this._nodeKindMatches(selectorData, nodeKind, templateData) &&\n        this._relationshipMatches(selectorData, relationshipTo, templateData) &&\n        this._specifierMatches(selectorData, specifiers, templateData)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the selectors matching result for the given dependency.\n   * @param dependency The dependency to check.\n   * @param selector The selector to check against.\n   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.\n   * @returns The matching result for the dependency against the selector.\n   */\n  public getSelectorsMatching(\n    dependency: DependencyDescription,\n    selector: DependencySelector,\n    {\n      extraTemplateData = {},\n      dependencySelectorsGlobals = {},\n    }: MatcherOptions = {}\n  ): DependencyMatchResult {\n    const normalizedSelector = this._normalizeDependencySelector(\n      selector,\n      dependencySelectorsGlobals\n    );\n\n    const fromExtraData = extraTemplateData.from || {};\n    const toExtraData = extraTemplateData.to || {};\n\n    // Add `to` and `from` data to the template when checking elements in dependencies\n    const templateData: TemplateData = {\n      ...extraTemplateData,\n      from: {\n        ...dependency.from,\n        relationship: dependency.dependency.relationship.from,\n        ...fromExtraData,\n      },\n      to: {\n        ...dependency.to,\n        relationship: dependency.dependency.relationship.to,\n        kind: dependency.dependency.kind,\n        nodeKind: dependency.dependency.nodeKind,\n        specifiers: dependency.dependency.specifiers,\n        ...toExtraData,\n      },\n    };\n\n    const result = this._getSelectorMatching(\n      dependency,\n      normalizedSelector,\n      templateData\n    );\n    return result;\n  }\n\n  /**\n   * Returns whether the given dependency matches the selector.\n   * @param dependency The dependency to check.\n   * @param selector The selector to check against.\n   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.\n   * @returns Whether the dependency matches the selector properties.\n   */\n  public isDependencyMatch(\n    dependency: DependencyDescription,\n    selector: DependencySelector,\n    options?: MatcherOptions\n  ): boolean {\n    const matchResult = this.getSelectorsMatching(\n      dependency,\n      selector,\n      options\n    );\n    return matchResult.isMatch;\n  }\n}\n","import type { MatchersOptionsNormalized } from \"../Config\";\nimport type { ElementDescription } from \"../Descriptor\";\nimport { isArray, isNullish, isEmptyObject } from \"../Support\";\n\nimport {\n  BaseElementsMatcher,\n  normalizeElementsSelector,\n} from \"./BaseElementsMatcher\";\nimport type {\n  BaseElementSelectorData,\n  SelectableElement,\n  TemplateData,\n  BaseElementsSelector,\n  MatcherOptions,\n  ElementSelectorData,\n} from \"./Matcher.types\";\nimport type { Micromatch } from \"./Micromatch\";\n\n/**\n * Matcher class to determine if elements match a given selector.\n */\nexport class ElementsMatcher extends BaseElementsMatcher {\n  /** Whether the cache is enabled or not */\n  private readonly _cacheIsEnabled: boolean;\n\n  /**\n   * Creates a new ElementsSelectorMatcher.\n   * @param config Configuration options for the matcher.\n   * @param micromatch Micromatch instance for matching.\n   * @param globalCache Global cache instance.\n   */\n  constructor(config: MatchersOptionsNormalized, micromatch: Micromatch) {\n    super(config, micromatch);\n  }\n\n  /**\n   * Whether the given element type matches the selector type.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element type matches the selector type.\n   */\n  private _isTypeMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"type\",\n      selectorKey: \"type\",\n      selectorValue: selector.type,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element category matches the selector category.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element category matches the selector category.\n   */\n  private _isCategoryMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"category\",\n      selectorKey: \"category\",\n      selectorValue: selector.category,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element path matches the selector path.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element path matches the selector path.\n   */\n  private _isPathMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"path\",\n      selectorKey: \"path\",\n      selectorValue: selector.path,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element path matches the selector element path.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element path matches the selector element path.\n   */\n  private _isElementPathMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"elementPath\",\n      selectorKey: \"elementPath\",\n      selectorValue: selector.elementPath,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element internal path matches the selector internal path.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element internal path matches the selector internal path.\n   */\n  private _isInternalPathMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"internalPath\",\n      selectorKey: \"internalPath\",\n      selectorValue: selector.internalPath,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element origin matches the selector origin\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element origin matches the selector origin.\n   */\n  private _isOriginMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"origin\",\n      selectorKey: \"origin\",\n      selectorValue: selector.origin,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element baseSource matches the selector baseSource\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element baseSource matches the selector baseSource.\n   */\n  private _isBaseSourceMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"baseSource\",\n      selectorKey: \"baseSource\",\n      selectorValue: selector.baseSource,\n      templateData,\n    });\n  }\n\n  /**\n   * Whether the given element source matches the selector source\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param templateData The data to use for replace in selector value\n   * @returns Whether the element source matches the selector source.\n   */\n  private _isSourceMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    return this.isElementKeyMicromatchMatch({\n      element,\n      selector,\n      elementKey: \"source\",\n      selectorKey: \"source\",\n      selectorValue: selector.source,\n      templateData,\n    });\n  }\n\n  /**\n   * Determines if the captured values of the element match those in the selector.\n   * @param element The element to check.\n   * @param selector The selector to check against\n   * @param templateData The data to use for replace in selector values\n   * @returns True if the captured values match, false otherwise.\n   */\n  private _isCapturedValuesMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData,\n    templateData: TemplateData\n  ): boolean {\n    if (!selector.captured || isEmptyObject(selector.captured)) {\n      return true;\n    }\n    if (!element.captured) {\n      return false;\n    }\n\n    // Use for...of with early return for better performance than every()\n    for (const [key, pattern] of Object.entries(selector.captured)) {\n      const elementValue = element.captured?.[key];\n      if (!elementValue) {\n        return false;\n      }\n\n      const renderedPattern = this.getRenderedTemplates(pattern, templateData);\n      // Empty selector values do not match anything.\n      if (!renderedPattern) {\n        return false;\n      }\n\n      // Clean empty strings from arrays to avoid matching them.\n      const filteredPattern = isArray(renderedPattern)\n        ? renderedPattern.filter(Boolean)\n        : renderedPattern;\n\n      const isMatch = this.micromatch.isMatch(elementValue, filteredPattern);\n\n      if (!isMatch) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines if the isIgnored property of the element matches that in the selector.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @returns True if the isIgnored properties match, false otherwise.\n   */\n  private _isIgnoredMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData\n  ): boolean {\n    return this.isElementKeyBooleanMatch({\n      element,\n      selector,\n      elementKey: \"isIgnored\",\n      selectorKey: \"isIgnored\",\n    });\n  }\n\n  /**\n   * Determines if the isUnknown property of the element matches that in the selector.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @returns True if the isUnknown properties match, false otherwise.\n   */\n  private _isUnknownMatch(\n    element: SelectableElement,\n    selector: BaseElementSelectorData\n  ): boolean {\n    return this.isElementKeyBooleanMatch({\n      element,\n      selector,\n      elementKey: \"isUnknown\",\n      selectorKey: \"isUnknown\",\n    });\n  }\n\n  /**\n   * Returns the selector matching result for the given local or external element.\n   * @param element The local or external element to check.\n   * @param selector The selector to check against.\n   * @param extraTemplateData Extra template data to use for matching.\n   * @returns The selector matching result for the given element, or null if none matches.\n   */\n  private _getSelectorMatching(\n    element: SelectableElement,\n    selectorsData: BaseElementSelectorData[],\n    extraTemplateData: TemplateData\n  ): ElementSelectorData | null {\n    const templateData: TemplateData = {\n      element,\n      ...extraTemplateData,\n    };\n    // Optimized loop with early exits for better performance\n    for (const selectorData of selectorsData) {\n      // Order checks by likelihood of failing for better short-circuiting\n      // Most restrictive checks first to fail fast\n      if (\n        !this._isTypeMatch(element, selectorData, templateData) ||\n        !this._isCategoryMatch(element, selectorData, templateData) ||\n        !this._isOriginMatch(element, selectorData, templateData) ||\n        !this._isIgnoredMatch(element, selectorData) ||\n        !this._isUnknownMatch(element, selectorData) ||\n        !this._isPathMatch(element, selectorData, templateData) ||\n        !this._isElementPathMatch(element, selectorData, templateData) ||\n        !this._isInternalPathMatch(element, selectorData, templateData) ||\n        !this._isSourceMatch(element, selectorData, templateData) ||\n        !this._isBaseSourceMatch(element, selectorData, templateData) ||\n        !this._isCapturedValuesMatch(element, selectorData, templateData)\n      ) {\n        continue; // Early exit on first failed condition\n      }\n\n      // All conditions passed, return the matching selector\n      return selectorData;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the selector matching result for the given element, or null if none matches.\n   * It omits checks in keys applying only to dependency between elements, such as relationship.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.\n   * @returns The selector matching result for the given element, or null if none matches.\n   */\n  public getSelectorMatching(\n    element: ElementDescription,\n    selector: BaseElementsSelector,\n    { extraTemplateData = {} }: MatcherOptions = {}\n  ): ElementSelectorData | null {\n    const selectorsData = normalizeElementsSelector(selector);\n    return this._getSelectorMatching(element, selectorsData, extraTemplateData);\n  }\n\n  /**\n   * Returns whether the given element matches the selector.\n   * It omits checks in keys applying only to dependency between elements, such as relationship.\n   * @param element The element to check.\n   * @param selector The selector to check against.\n   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.\n   * @returns Whether the element matches the selector properties applying to elements.\n   */\n  public isElementMatch(\n    element: ElementDescription,\n    selector: BaseElementsSelector,\n    options?: MatcherOptions\n  ): boolean {\n    const selectorMatching = this.getSelectorMatching(\n      element,\n      selector,\n      options\n    );\n    return !isNullish(selectorMatching);\n  }\n}\n","/**\n * Map of the modes to interpret the pattern in an ElementDescriptor.\n */\nexport const ELEMENT_DESCRIPTOR_MODES_MAP = {\n  /** Mode to interpret the pattern as a folder */\n  FOLDER: \"folder\",\n  /** Mode to interpret the pattern as a file */\n  FILE: \"file\",\n  /** Mode to interpret the pattern as a full path */\n  FULL: \"full\",\n} as const;\n\n/**\n * Mode to interpret the pattern in an ElementDescriptor.\n */\nexport type ElementDescriptorMode =\n  (typeof ELEMENT_DESCRIPTOR_MODES_MAP)[keyof typeof ELEMENT_DESCRIPTOR_MODES_MAP];\n\n/**\n * Pattern(s) to match files for an element descriptor.\n */\nexport type ElementDescriptorPattern = string | string[];\n\n/**\n * Descriptor for an element (or layer) in the project.\n * Defines the type of the element, the pattern to match files, and optional settings like mode and capture groups.\n */\nexport type BaseElementDescriptor = {\n  /** Micromatch pattern(s) to match files belonging to this element. */\n  pattern: ElementDescriptorPattern;\n  /**\n   * Optional micromatch pattern. If provided, the left side of the element path must match also with this pattern from the root of the project (like if pattern is [basePattern]/** /[pattern]).\n   * This option is useful when using the option mode with file or folder values, but capturing fragments from the rest of the full path is also needed\n   **/\n  basePattern?: string;\n  /**\n   * Mode to interpret the pattern. Can be \"folder\" (default), \"file\", or \"full\".\n   * - \"folder\": Default value. the element type will be assigned to the first file's parent folder matching the pattern.\n   *             In the practice, it is like adding ** /* to the given pattern, but the plugin makes it by itself because it needs to know exactly which parent folder has to be considered the element.\n   * - \"file\": The given pattern will not be modified, but the plugin will still try to match the last part of the path.\n   *           So, a pattern like *.model.js would match with paths src/foo.model.js, src/modules/foo/foo.model.js, src/modules/foo/models/foo.model.js, etc.\n   * - \"full\": The given pattern will only match with patterns matching the full path.\n   *           This means that you will have to provide patterns matching from the base project path.\n   *           So, in order to match src/modules/foo/foo.model.js you'll have to provide patterns like ** /*.model.js, ** /* /*.model.js, src/* /* /*.model.js, etc. (the chosen pattern will depend on what do you want to capture from the path)\n   */\n  mode?: ElementDescriptorMode;\n  /**\n   * It allows to capture values of some fragments in the matching path to use them later in the rules configuration.\n   * Must be an array of strings representing the names of the capture groups in the pattern.\n   * The number of capture names must be equal to the number of capturing groups in the pattern.\n   * For example, if the pattern is \"src/modules/(* *)/(* *).service.js\" the capture could be [\"module\", \"service\"].\n   * Then, in the rules configuration, you could use [\"service\", { module: \"auth\" }] to match only services from the auth module.\n   */\n  capture?: string[];\n  /**\n   * Like capture, but for the basePattern.\n   * This allows to capture values from the left side of the path, which is useful when using the basePattern option.\n   * The captured values will be merged with the ones from the capture option. If the same name is used in both captures, the value from capture will take precedence.\n   */\n  baseCapture?: string[];\n};\n\n/**\n * Element descriptor with a type.\n */\nexport type ElementDescriptorWithType = BaseElementDescriptor & {\n  /** Type of the element (e.g., \"service\", \"component\", \"util\"). */\n  type: string;\n  /** Category of the element */\n  category?: never;\n};\n\n/**\n * Element descriptor with a category.\n */\nexport type ElementDescriptorWithCategory = BaseElementDescriptor & {\n  /** Category of the element (e.g., \"domain\", \"infrastructure\", \"application\"). */\n  category: string;\n  /** Type of the element*/\n  type?: never;\n};\n\n/**\n * Element descriptor with both type and category.\n */\nexport type ElementDescriptorWithTypeAndCategory = BaseElementDescriptor & {\n  /** Type of the element (e.g., \"service\", \"component\", \"util\"). */\n  type: string;\n  /** Category of the element (e.g., \"domain\", \"infrastructure\", \"application\"). */\n  category: string;\n};\n\n/**\n * Element descriptor, which can be defined by type, category, or both.\n */\nexport type ElementDescriptor =\n  | ElementDescriptorWithType\n  | ElementDescriptorWithCategory\n  | ElementDescriptorWithTypeAndCategory;\n\n/**\n * Array of element descriptors.\n */\nexport type ElementDescriptors = ElementDescriptor[];\n\n/**\n * Serialized cache of element descriptions.\n */\nexport type DescriptionsSerializedCache = Record<string, ElementDescription>;\n\n/**\n * Serialized cache of file elements.\n */\nexport type FileElementsSerializedCache = Record<string, FileElement>;\n\n/**\n * Serialized cache for ElementsDescriptor class.\n */\nexport type ElementsDescriptorSerializedCache = {\n  /** Serialized descriptions cache */\n  descriptions: DescriptionsSerializedCache;\n  /** Serialized files cache */\n  files: FileElementsSerializedCache;\n};\n\n/**\n * Captured values from an element path.\n */\nexport type CapturedValues = Record<string, string>;\n\n/**\n * Origins of an element\n */\nexport const ELEMENT_ORIGINS_MAP = {\n  /** Origin of local elements (files) */\n  LOCAL: \"local\",\n  /** Origin of external elements (libraries) */\n  EXTERNAL: \"external\",\n  /** Origin of core elements */\n  CORE: \"core\",\n} as const;\n\n/**\n * Kind of element origin, either local, external, or core.\n */\nexport type ElementOrigin =\n  (typeof ELEMENT_ORIGINS_MAP)[keyof typeof ELEMENT_ORIGINS_MAP];\n\n/**\n * Base element properties related to captured values\n */\nexport type BaseElement = {\n  /** Absolute path of the file. It might be null when a dependency path can't be resolved */\n  path: string | null;\n  /** Path of the file relative to the element, or null if the element is ignored or unknown */\n  elementPath: string | null;\n  /** Internal path of the file relative to the elementPath, or null if the element is ignored or unknown */\n  internalPath: string | null;\n  /** Source of the element when it is a dependency, or null if the element is not a dependency, or it is ignored or unknown */\n  source: string | null;\n  /** Base source of the element when it is an external or core dependency, null otherwise */\n  baseSource: string | null;\n  /** Type of the element, or null if the element is ignored or unknown */\n  type: string | null;\n  /** Category of the element, or null if the element is ignored or unknown */\n  category: string | null;\n  /** Captured values from the element, or null if the element descriptor has no capture or the element is ignored or unknown */\n  captured: CapturedValues | null;\n  /** Parent elements, or null if the element is ignored, unknown, or it is not a local element */\n  parents: ElementParent[] | null;\n  /** Origin of the element, or null if the element is ignored */\n  origin: ElementOrigin | null;\n  /** Indicates if the element is ignored by settings. If true, the element will be excluded from processing any other properties. */\n  isIgnored: boolean;\n  /** Indicates if the element is unknown, which means that it cannot be resolved to any descriptor */\n  isUnknown: boolean;\n};\n\n/**\n * Parent elements\n */\nexport type ElementParent = {\n  /** Type of the parent element */\n  type: string | null;\n  /** Category of the parent element */\n  category: string | null;\n  /** Path of the element relative to the project */\n  elementPath: string;\n  /** Captured values from the parent element */\n  captured: CapturedValues | null;\n};\n\n/**\n * Description of an ignored element\n */\nexport type IgnoredElement = BaseElement & {\n  /** Type of the element */\n  type: null;\n  /** Category of the element */\n  category: null;\n  /** Ignored elements have not captured values */\n  captured: null;\n  /** Origin of the element */\n  origin: null;\n  /** Indicates if the file is ignored */\n  isIgnored: true;\n  /** Indicates that the element is unknown */\n  isUnknown: true;\n};\n\n/**\n * Description of an unknown local element\n */\nexport type LocalElementUnknown = BaseElement & {\n  /** Type of the element */\n  type: null;\n  /** Category of the element */\n  category: null;\n  /** Unknown elements have not captured values */\n  captured: null;\n  /** Indicates that the element is local */\n  origin: typeof ELEMENT_ORIGINS_MAP.LOCAL;\n  /** Indicates that the file is not ignored */\n  isIgnored: false;\n  /** Indicates that the element is unknown */\n  isUnknown: true;\n};\n\n/**\n * Description of a local element (file)\n */\nexport type LocalElementKnown = BaseElement & {\n  /** Path of the element */\n  path: string;\n  /** Captured values from the parent element */\n  captured: CapturedValues | null;\n  /** Path of the file relative to the element */\n  elementPath: string;\n  /** Internal path of the file relative to the elementPath */\n  internalPath: string;\n  /** Parent elements */\n  parents: ElementParent[];\n  /** Indicates that the element is local */\n  origin: typeof ELEMENT_ORIGINS_MAP.LOCAL;\n  /** Indicates that the file is not ignored */\n  isIgnored: false;\n  /** Indicates that the element is known */\n  isUnknown: false;\n};\n\n/**\n * Base description of a dependency\n */\nexport type BaseDependencyElement = BaseElement & {\n  /** Dependency source */\n  source: string;\n  /** Indicates that dependencies are not ignored */\n  isIgnored: false;\n};\n\n/**\n * Description of a local dependency (known)\n */\nexport type LocalDependencyElementKnown = LocalElementKnown &\n  BaseDependencyElement;\n\n/**\n * Description of a local dependency (unknown)\n */\nexport type LocalDependencyElementUnknown = LocalElementUnknown &\n  BaseDependencyElement;\n\n/**\n * Description of a local dependency\n */\nexport type LocalDependencyElement =\n  | LocalDependencyElementKnown\n  | LocalDependencyElementUnknown;\n\n/**\n * Description of an external dependency\n */\nexport type ExternalDependencyElement = BaseDependencyElement & {\n  /** Path of the dependency relative to the base module */\n  internalPath: string;\n  /** Base module of the external dependency */\n  baseSource: string;\n  /** Indicates that the dependency is external */\n  origin: typeof ELEMENT_ORIGINS_MAP.EXTERNAL;\n};\n\n/**\n * Description of a core dependency\n */\nexport type CoreDependencyElement = BaseDependencyElement & {\n  /** Base module of the core dependency */\n  baseSource: string;\n  /** Indicates that the dependency is core */\n  origin: typeof ELEMENT_ORIGINS_MAP.CORE;\n};\n\n/**\n * Description of an ignored dependency element\n */\nexport type IgnoredDependencyElement = IgnoredElement & {\n  /** The source of the dependency */\n  source: string;\n};\n\n/**\n * Description of a file\n */\nexport type FileElement =\n  | IgnoredElement\n  | LocalElementKnown\n  | LocalElementUnknown;\n\n/**\n * Description of a dependency\n */\nexport type DependencyElementDescription =\n  | IgnoredDependencyElement\n  | CoreDependencyElement\n  | LocalDependencyElement\n  | ExternalDependencyElement;\n\n/**\n * Description of an element, either local or dependency\n */\nexport type ElementDescription = FileElement | DependencyElementDescription;\n","import {\n  isString,\n  isObjectWithProperty,\n  isArray,\n  isEmptyArray,\n} from \"../Support/TypeGuards\";\n\nimport type {\n  ElementDescription,\n  LocalElementKnown,\n  LocalDependencyElement,\n  ExternalDependencyElement,\n  DependencyElementDescription,\n  BaseElementDescriptor,\n  ElementDescriptorPattern,\n  ElementDescriptorMode,\n  ElementDescriptorWithType,\n  ElementDescriptorWithCategory,\n  ElementDescriptor,\n  IgnoredElement,\n  LocalElementUnknown,\n  BaseElement,\n  CoreDependencyElement,\n} from \"./ElementsDescriptor.types\";\nimport {\n  ELEMENT_DESCRIPTOR_MODES_MAP,\n  ELEMENT_ORIGINS_MAP,\n} from \"./ElementsDescriptor.types\";\n\n/**\n * Determines if the given value is a valid element descriptor mode.\n * @param value The value to check.\n * @returns True if the value is a valid element descriptor mode, false otherwise.\n */\nexport function isElementDescriptorMode(\n  value: unknown\n): value is ElementDescriptorMode {\n  return (\n    isString(value) &&\n    Object.values(ELEMENT_DESCRIPTOR_MODES_MAP).includes(\n      value as ElementDescriptorMode\n    )\n  );\n}\n\n/**\n * Determines if the given value is a valid element descriptor pattern.\n * @param value The value to check.\n * @returns True if the value is a valid element descriptor pattern, false otherwise.\n */\nexport function isElementDescriptorPattern(\n  value: unknown\n): value is ElementDescriptorPattern {\n  return (\n    isString(value) ||\n    (isArray(value) && !isEmptyArray(value) && value.every(isString))\n  );\n}\n\n/**\n * Determines if the given value is a base element descriptor.\n * @param value The value to check.\n * @returns True if the value is a base element descriptor, false otherwise.\n */\nexport function isBaseElementDescriptor(\n  value: unknown\n): value is BaseElementDescriptor {\n  return (\n    isObjectWithProperty(value, \"pattern\") &&\n    isElementDescriptorPattern(value.pattern)\n  );\n}\n\n/**\n * Determines if the given value is an element descriptor with type.\n * @param value The value to check.\n * @returns True if the value is an element descriptor with type, false otherwise.\n */\nexport function isElementDescriptorWithType(\n  value: unknown\n): value is ElementDescriptorWithType {\n  return (\n    isBaseElementDescriptor(value) &&\n    isObjectWithProperty(value, \"type\") &&\n    isString(value.type)\n  );\n}\n\n/**\n * Determines if the given value is an element descriptor with category.\n * @param value The value to check.\n * @returns True if the value is an element descriptor with category, false otherwise.\n */\nexport function isElementDescriptorWithCategory(\n  value: unknown\n): value is ElementDescriptorWithCategory {\n  return (\n    isBaseElementDescriptor(value) &&\n    isObjectWithProperty(value, \"category\") &&\n    isString(value.category)\n  );\n}\n\n/**\n * Determines if the given value is an element descriptor.\n * @param value The value to check.\n * @returns True if the value is an element descriptor, false otherwise.\n */\nexport function isElementDescriptor(\n  value: unknown\n): value is ElementDescriptor {\n  return (\n    isElementDescriptorWithType(value) || isElementDescriptorWithCategory(value)\n  );\n}\n\n/**\n * Determines if the value is a BaseElement\n * @param value The value to check\n * @returns True if the value is a valid BaseElement, false otherwise\n */\nexport function isBaseElement(value: unknown): value is BaseElement {\n  return (\n    isObjectWithProperty(value, \"type\") &&\n    isObjectWithProperty(value, \"category\") &&\n    isObjectWithProperty(value, \"path\") &&\n    isObjectWithProperty(value, \"captured\") &&\n    isObjectWithProperty(value, \"origin\") &&\n    isObjectWithProperty(value, \"isIgnored\") &&\n    isObjectWithProperty(value, \"isUnknown\")\n  );\n}\n\n/**\n * Determines if the given value is an ignored element.\n * @param value The element to check.\n * @returns True if the element is an ignored element, false otherwise.\n */\nexport function isIgnoredElement(value: unknown): value is IgnoredElement {\n  return (\n    isBaseElement(value) &&\n    isObjectWithProperty(value, \"isIgnored\") &&\n    value.isIgnored === true\n  );\n}\n\n/**\n * Determines if the given value is a local element.\n * @param value The value to check.\n * @returns True if the value is a local element, false otherwise.\n */\nexport function isLocalElement(\n  value: unknown\n): value is LocalElementKnown | LocalElementUnknown {\n  return isBaseElement(value) && value.origin === ELEMENT_ORIGINS_MAP.LOCAL;\n}\n\n/**\n * Determines if the given element is local and unknown, because its type and category could not be determined.\n * @param value The value to check.\n * @returns True if the element is an unknown element, false otherwise.\n */\nexport function isUnknownLocalElement(\n  value: unknown\n): value is LocalElementUnknown {\n  return isLocalElement(value) && value.isUnknown === true;\n}\n\n/**\n * Determines if the given element is local and known, because its type and category were determined.\n * @param value The value to check.\n * @returns True if the element is an unknown element, false otherwise.\n */\nexport function isKnownLocalElement(\n  value: unknown\n): value is LocalElementKnown {\n  return isLocalElement(value) && value.isUnknown === false;\n}\n\n/**\n * Determines if the given value is a dependency element.\n * @param value The element to check.\n * @returns True if the element is a dependency element, false otherwise.\n */\nexport function isDependencyElementDescription(\n  value: unknown\n): value is DependencyElementDescription {\n  return (\n    isBaseElement(value) &&\n    isObjectWithProperty(value, \"source\") &&\n    isString(value.source)\n  );\n}\n\n/**\n * Determines if the given value is an element (local or dependency).\n * @param value The value to check.\n * @returns True if the value is an element, false otherwise.\n */\nexport function isElementDescription(\n  value: unknown\n): value is ElementDescription {\n  return (\n    isIgnoredElement(value) ||\n    isUnknownLocalElement(value) ||\n    isKnownLocalElement(value) ||\n    isDependencyElementDescription(value)\n  );\n}\n\n/**\n * Determines if the given value is a local dependency element.\n * @param value The value to check.\n * @returns True if the element is a local dependency element, false otherwise.\n */\nexport function isLocalDependencyElement(\n  value: unknown\n): value is LocalDependencyElement {\n  return isDependencyElementDescription(value) && isLocalElement(value);\n}\n\n/**\n * Determines if the given value is an external element.\n * @param value The value to check.\n * @returns True if the element is an external dependency element, false otherwise.\n */\nexport function isExternalDependencyElement(\n  value: unknown\n): value is ExternalDependencyElement {\n  return (\n    isDependencyElementDescription(value) &&\n    value.origin === ELEMENT_ORIGINS_MAP.EXTERNAL &&\n    isObjectWithProperty(value, \"baseSource\") &&\n    isString(value.baseSource)\n  );\n}\n\n/**\n * Determines if the given value is a core element.\n * @param value The value to check.\n * @returns True if the element is a core dependency element, false otherwise.\n */\nexport function isCoreDependencyElement(\n  value: unknown\n): value is CoreDependencyElement {\n  return (\n    isDependencyElementDescription(value) &&\n    value.origin === ELEMENT_ORIGINS_MAP.CORE &&\n    isObjectWithProperty(value, \"baseSource\") &&\n    isString(value.baseSource)\n  );\n}\n","import type {\n  DependencyElementDescription,\n  FileElement,\n} from \"./ElementsDescriptor.types\";\n\nexport const DEPENDENCY_KIND_TYPE = \"type\" as const;\nexport const DEPENDENCY_KIND_VALUE = \"value\" as const;\nexport const DEPENDENCY_KIND_TYPEOF = \"typeof\" as const;\n\n/** Map of the kinds of dependency, either a type dependency or a value dependency */\nexport const DEPENDENCY_KINDS_MAP = {\n  /** Type import, e.g., `import type { X } from 'module'` */\n  TYPE: DEPENDENCY_KIND_TYPE,\n\n  /** Value import, e.g., `import { X } from 'module'` */\n  VALUE: DEPENDENCY_KIND_VALUE,\n\n  /** typeof import, e.g. `type ModuleType = typeof import(\"./my_module\");` */\n  TYPE_OF: DEPENDENCY_KIND_TYPEOF,\n} as const;\n\n/** Kind of dependency, either a type dependency or a value dependency */\nexport type DependencyKind =\n  (typeof DEPENDENCY_KINDS_MAP)[keyof typeof DEPENDENCY_KINDS_MAP];\n\n/** Map of possible kinds of relationships between elements being dependencies */\nexport const DEPENDENCY_RELATIONSHIPS_MAP = {\n  /** The dependency is internal to the element */\n  INTERNAL: \"internal\",\n  /** The dependency is a child of the element */\n  CHILD: \"child\",\n  /** The dependency is a descendant of the element */\n  DESCENDANT: \"descendant\",\n  /** The dependency is a sibling of the element (both have the same parent) */\n  SIBLING: \"sibling\",\n  /** The dependency is a parent of the element */\n  PARENT: \"parent\",\n  /** The dependency is an uncle of the element */\n  UNCLE: \"uncle\",\n  /** The dependency is a nephew of the element */\n  NEPHEW: \"nephew\",\n  /** The dependency is an ancestor of the element */\n  ANCESTOR: \"ancestor\",\n} as const;\n\nexport const DEPENDENCY_RELATIONSHIPS_INVERTED_MAP = {\n  [DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL]:\n    DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL,\n  [DEPENDENCY_RELATIONSHIPS_MAP.CHILD]: DEPENDENCY_RELATIONSHIPS_MAP.PARENT,\n  [DEPENDENCY_RELATIONSHIPS_MAP.DESCENDANT]:\n    DEPENDENCY_RELATIONSHIPS_MAP.ANCESTOR,\n  [DEPENDENCY_RELATIONSHIPS_MAP.SIBLING]: DEPENDENCY_RELATIONSHIPS_MAP.SIBLING,\n  [DEPENDENCY_RELATIONSHIPS_MAP.PARENT]: DEPENDENCY_RELATIONSHIPS_MAP.CHILD,\n  [DEPENDENCY_RELATIONSHIPS_MAP.UNCLE]: DEPENDENCY_RELATIONSHIPS_MAP.NEPHEW,\n  [DEPENDENCY_RELATIONSHIPS_MAP.NEPHEW]: DEPENDENCY_RELATIONSHIPS_MAP.UNCLE,\n  [DEPENDENCY_RELATIONSHIPS_MAP.ANCESTOR]:\n    DEPENDENCY_RELATIONSHIPS_MAP.DESCENDANT,\n} as const;\n\n/** Kind of relationship between elements being dependencies */\nexport type DependencyRelationship =\n  (typeof DEPENDENCY_RELATIONSHIPS_MAP)[keyof typeof DEPENDENCY_RELATIONSHIPS_MAP];\n\n/** Information about a dependency between two elements */\nexport type ElementsDependencyInfo = {\n  /** Kind of the dependency */\n  kind: DependencyKind;\n  /** Type of the node creating the dependency in the dependent element */\n  nodeKind: string | null;\n  /** Specifiers imported or exported in the dependency */\n  specifiers: string[] | null;\n  /** Relationship between the elements from both perspectives */\n  relationship: {\n    /** Relationship between the elements from the perspective of the file */\n    from: DependencyRelationship | null;\n    /** Relationship between the elements from the perspective of the dependency */\n    to: DependencyRelationship | null;\n  };\n};\n\n/**\n * Description of a dependency between two elements\n */\nexport type DependencyDescription = {\n  /** Source element of the dependency */\n  from: FileElement;\n  /** Target element of the dependency */\n  to: DependencyElementDescription;\n  /** Information about the dependency */\n  dependency: ElementsDependencyInfo;\n};\n\n/**\n * Serialized cache of dependencies descriptor.\n */\nexport type DependenciesDescriptorSerializedCache = Record<\n  string,\n  DependencyDescription\n>;\n\n/** Options for describing a dependency between two elements */\nexport type DescribeDependencyOptions = {\n  /** Path of the element where the dependency originates */\n  from: string;\n  /** Path of the element where the dependency points to */\n  to?: string;\n  /** Source of the dependency (import/export path) */\n  source: string;\n  /** Kind of the dependency (type, runtime) */\n  kind: DependencyKind;\n  /** Type of the node creating the dependency in the dependent element */\n  nodeKind?: string;\n  /** Specifiers imported or exported in the dependency */\n  specifiers?: string[];\n};\n","import { isString, isObjectWithProperty, isNull } from \"../Support/TypeGuards\";\n\nimport type {\n  DependencyKind,\n  DependencyRelationship,\n  ElementsDependencyInfo,\n  DependencyDescription,\n} from \"./DependenciesDescriptor.types\";\nimport {\n  DEPENDENCY_KINDS_MAP,\n  DEPENDENCY_RELATIONSHIPS_MAP,\n} from \"./DependenciesDescriptor.types\";\nimport { isElementDescription } from \"./ElementsDescriptorHelpers\";\n\n/**\n * Determines if the value is a valid dependency kind.\n * @param value The value to check\n * @returns True if the value is a valid dependency kind, false otherwise.\n */\nexport function isDependencyKind(value: unknown): value is DependencyKind {\n  return (\n    isString(value) &&\n    Object.values(DEPENDENCY_KINDS_MAP).includes(value as DependencyKind)\n  );\n}\n\n/**\n * Determines if the given value is a valid dependency relationship.\n * @param value The value to check.\n * @returns True if the value is a valid dependency relationship, false otherwise.\n */\nexport function isDependencyRelationship(\n  value: unknown\n): value is DependencyRelationship {\n  return (\n    isString(value) &&\n    Object.values(DEPENDENCY_RELATIONSHIPS_MAP).includes(\n      value as DependencyRelationship\n    )\n  );\n}\n\n/**\n * Determines if the given value is a valid dependency relationship description.\n * @param value The value to check.\n * @returns True if the value is a valid dependency relationship, false otherwise.\n */\nexport function isDependencyRelationshipDescription(\n  value: unknown\n): value is DependencyRelationship {\n  return (\n    isObjectWithProperty(value, \"to\") &&\n    (isNull(value.to) || isDependencyRelationship(value.to)) &&\n    isObjectWithProperty(value, \"from\") &&\n    (isNull(value.from) || isDependencyRelationship(value.from))\n  );\n}\n\n/**\n * Returns whether the given value is a valid ElementsDependencyInfo object.\n * @param value The value to check.\n * @returns True if the value is a valid ElementsDependencyInfo object, false otherwise.\n */\nexport function isElementsDependencyInfo(\n  value: unknown\n): value is ElementsDependencyInfo {\n  return (\n    isObjectWithProperty(value, \"kind\") &&\n    isDependencyKind(value.kind) &&\n    isObjectWithProperty(value, \"relationship\") &&\n    isDependencyRelationshipDescription(value.relationship) &&\n    isObjectWithProperty(value, \"nodeKind\") &&\n    (isNull(value.nodeKind) || isString(value.nodeKind))\n  );\n}\n\n/**\n * Determines whether the given value is a valid DependencyDescription object.\n * @param value The value to check\n * @returns True if the value is a valid DependencyDescription object, false otherwise.\n */\nexport function isDependencyDescription(\n  value: unknown\n): value is DependencyDescription {\n  return (\n    isObjectWithProperty(value, \"to\") &&\n    isElementDescription(value.to) &&\n    isObjectWithProperty(value, \"from\") &&\n    isElementDescription(value.from) &&\n    isObjectWithProperty(value, \"dependency\") &&\n    isElementsDependencyInfo(value.dependency)\n  );\n}\n\n/**\n * Determines whether the given dependency description is internal.\n * @param dependency The dependency to check\n * @returns True if the dependency is internal, false otherwise\n */\nexport function isInternalDependency(\n  dependency: DependencyDescription\n): boolean {\n  return (\n    dependency.dependency.relationship.to ===\n    DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL\n  );\n}\n","import { isString } from \"../Support\";\n\nimport type { NotUndefined } from \"./Cache.types\";\n\n/**\n * Generic cache manager class. Enables caching of values based on complex keys.\n */\nexport class CacheManager<CacheKey extends NotUndefined, CachedValue> {\n  /**\n   * Internal cache map\n   */\n  private readonly _cache: Map<string, CachedValue>;\n\n  /**\n   * Creates a new CacheManager instance\n   */\n  constructor() {\n    this._cache = new Map<string, CachedValue>();\n  }\n\n  /**\n   * Generates a string key from the given cache key. Has to be implemented for non-string keys.\n   * @param key The cache key to generate from\n   * @returns The generated string key\n   */\n  protected generateKey(key: CacheKey): string {\n    if (isString(key)) {\n      return key;\n    }\n    const errorMessage =\n      \"Cache key generation for non-string keys is not implemented because it causes performance issues: \" +\n      JSON.stringify(key);\n    throw new Error(errorMessage);\n  }\n\n  /**\n   * Generates a hashed key for the given cache key\n   * @param key The cache key to hash\n   * @returns The hashed key as a string\n   */\n  public getKey(key: CacheKey): string {\n    return this.generateKey(key);\n  }\n\n  /**\n   * Retrieves a value from the cache based on the given hashed key\n   * @param hashedKey The hashed key to retrieve\n   * @returns The cached value or undefined if not found\n   */\n  public get(hashedKey: string): CachedValue | undefined {\n    return this._cache.get(hashedKey);\n  }\n\n  /**\n   * Stores a value in the cache with a given hashed key\n   * @param hashedKey The hashed key to store\n   * @param value The value to cache\n   */\n  public set(hashedKey: string, value: CachedValue): void {\n    this._cache.set(hashedKey, value);\n  }\n\n  /**\n   * Checks if a value exists in the cache based on the given hashed key\n   * @param hashedKey The hashed key to check\n   * @returns True if the value exists, false otherwise\n   */\n  public has(hashedKey: string): boolean {\n    return this._cache.has(hashedKey);\n  }\n\n  /**\n   * Retrieves all cached values\n   * @returns A map of all cached values\n   */\n  public getAll(): Map<string, CachedValue> {\n    return this._cache;\n  }\n\n  /**\n   * Clears the entire cache\n   */\n  public clear(): void {\n    this._cache.clear();\n  }\n\n  /**\n   * Serializes the  cache to a plain object.\n   * @returns The serialized cache.\n   */\n  public serialize(): Record<string, CachedValue> {\n    return Array.from(this.getAll().entries()).reduce(\n      (acc, [key, value]) => {\n        acc[key] = value;\n        return acc;\n      },\n      {} as Record<string, CachedValue>\n    );\n  }\n\n  /**\n   * Sets the cache from a serialized object.\n   * @param serializedCache The serialized cache.\n   */\n  public setFromSerialized(serializedCache: Record<string, CachedValue>): void {\n    for (const key in serializedCache) {\n      this.set(key, serializedCache[key]);\n    }\n  }\n}\n","import { CacheManager } from \"./Cache\";\nimport type { NotUndefined } from \"./Cache.types\";\n\n/**\n * Disabled cache manager class. Disables caching of values.\n */\nexport class CacheManagerDisabled<\n  CacheKey extends NotUndefined,\n  CachedValue,\n> extends CacheManager<CacheKey, CachedValue> {\n  /**\n   * Generates a fake cache key as caching is disabled\n   * @param key The cache key to hash\n   * @returns An empty string\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public getKey(_key: CacheKey): string {\n    return \"\";\n  }\n\n  /**\n   * Does nothing as caching is disabled\n   * @param hashedKey The hashed key to retrieve\n   * @returns Undefined as caching is disabled\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public get(_hashedKey: string): CachedValue | undefined {\n    return undefined;\n  }\n\n  /**\n   * Does nothing as caching is disabled\n   * @param hashedKey The hashed key to store\n   * @param value The value to cache\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public set(_hashedKey: string, _value: CachedValue): void {\n    return;\n  }\n\n  /**\n   * Does nothing as caching is disabled\n   * @param hashedKey The hashed key to check\n   * @returns False as caching is disabled\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public has(_hashedKey: string): boolean {\n    return false;\n  }\n}\n","import { CacheManager } from \"../Cache\";\n\nimport type {\n  DependencyDescription,\n  DescribeDependencyOptions,\n} from \"./DependenciesDescriptor.types\";\n\n/**\n * Cache to store previously described dependencies.\n */\nexport class DependenciesDescriptionsCache extends CacheManager<\n  DescribeDependencyOptions,\n  DependencyDescription\n> {\n  /** Generates a unique key for the given dependency description options.\n   * @param options The options to generate the key from.\n   * @returns The generated key.\n   */\n  protected generateKey(options: {\n    from: string;\n    to?: string;\n    source: string;\n    kind: string;\n    nodeKind?: string;\n    specifiers?: string[];\n  }): string {\n    return `${options.from}|${options.to}|${options.source}|${options.kind}|${\n      options.nodeKind\n    }|${options.specifiers ? options.specifiers.join(\",\") : \"\"}`;\n  }\n}\n","import { CacheManagerDisabled } from \"../Cache\";\nimport type { DescriptorOptionsNormalized } from \"../Config\";\n\nimport { DependenciesDescriptionsCache } from \"./DependenciesDescriptionsCache\";\nimport {\n  DEPENDENCY_RELATIONSHIPS_MAP,\n  DEPENDENCY_RELATIONSHIPS_INVERTED_MAP,\n} from \"./DependenciesDescriptor.types\";\nimport type {\n  DependenciesDescriptorSerializedCache,\n  DependencyDescription,\n  DescribeDependencyOptions,\n} from \"./DependenciesDescriptor.types\";\nimport type { ElementsDescriptor } from \"./ElementsDescriptor\";\nimport type {\n  ElementDescription,\n  LocalElementKnown,\n} from \"./ElementsDescriptor.types\";\nimport {\n  isIgnoredElement,\n  isKnownLocalElement,\n} from \"./ElementsDescriptorHelpers\";\n\n/**\n * Class describing dependencies between elements.\n */\nexport class DependenciesDescriptor {\n  /**\n   * Cache to store previously described dependencies.\n   */\n  private readonly _dependenciesCache:\n    | DependenciesDescriptionsCache\n    | CacheManagerDisabled<DescribeDependencyOptions, DependencyDescription>;\n\n  /**\n   * Elements descriptor instance.\n   */\n  private readonly _elementsDescriptor: ElementsDescriptor;\n\n  /**\n   * Configuration options.\n   */\n  private readonly _config: DescriptorOptionsNormalized;\n\n  /**\n   * Creates a new DependenciesDescriptor instance.\n   * @param elementsDescriptor The elements descriptor instance.\n   * @param config The configuration options.\n   */\n  constructor(\n    elementsDescriptor: ElementsDescriptor,\n    config: DescriptorOptionsNormalized\n  ) {\n    this._elementsDescriptor = elementsDescriptor;\n    this._config = config;\n    this._dependenciesCache = this._config.cache\n      ? new DependenciesDescriptionsCache()\n      : new CacheManagerDisabled<\n          DescribeDependencyOptions,\n          DependencyDescription\n        >();\n  }\n\n  /**\n   * Serializes the elements cache to a plain object.\n   * @returns The serialized elements cache.\n   */\n  public serializeCache(): DependenciesDescriptorSerializedCache {\n    return this._dependenciesCache.serialize();\n  }\n\n  /**\n   * Sets the elements cache from a serialized object.\n   * @param serializedCache The serialized elements cache.\n   */\n  public setCacheFromSerialized(\n    serializedCache: DependenciesDescriptorSerializedCache\n  ): void {\n    this._dependenciesCache.setFromSerialized(serializedCache);\n  }\n\n  /**\n   * Clears the elements cache.\n   */\n  public clearCache(): void {\n    this._dependenciesCache.clear();\n  }\n\n  /**\n   * Retrieves the element path of the parent of a given element.\n   * @param elementInfo The element whose parent is to be retrieved.\n   * @returns The parent element path, or undefined if none exists.\n   */\n  private _getParent(elementInfo: LocalElementKnown) {\n    return elementInfo.parents[0]?.elementPath;\n  }\n\n  /**\n   * Retrieves the common ancestor of two elements.\n   * @param elementInfoA The first element.\n   * @param elementInfoB The second element.\n   * @returns The common ancestor element path, or undefined if none exists.\n   */\n  private _getCommonAncestor(\n    elementInfoA: LocalElementKnown,\n    elementInfoB: LocalElementKnown\n  ) {\n    const commonAncestor = elementInfoA.parents.find((elementParentA) => {\n      return elementInfoB.parents.some((elementParentB) => {\n        return elementParentA.elementPath === elementParentB.elementPath;\n      });\n    });\n    return commonAncestor?.elementPath;\n  }\n\n  /**\n   * Checks if the parent of element A is an ancestor of element B.\n   * @param elementA The element A.\n   * @param elementB The element B.\n   * @returns True if the parent of element A is an ancestor of element B, false otherwise.\n   */\n  private _isDescendantOfParent(\n    elementA: LocalElementKnown,\n    elementB: LocalElementKnown\n  ) {\n    const commonAncestor = this._getCommonAncestor(elementA, elementB);\n    return commonAncestor && commonAncestor === this._getParent(elementA);\n  }\n\n  /**\n   * Checks if two elements are siblings (same parent).\n   * @param elementA The first element.\n   * @param elementB The second element.\n   * @returns True if the elements are siblings, false otherwise.\n   */\n  private _isSibling(elementA: LocalElementKnown, elementB: LocalElementKnown) {\n    const parentA = this._getParent(elementA);\n    const parentB = this._getParent(elementB);\n    return parentA && parentB && parentA === parentB;\n  }\n\n  /**\n   * Checks if one element is a descendant of another.\n   * @param elementA The potential descendant element.\n   * @param elementB The potential ancestor element.\n   * @returns True if elementA is a descendant of elementB, false otherwise.\n   */\n  private _isDescendant(\n    elementA: LocalElementKnown,\n    elementB: LocalElementKnown\n  ) {\n    return elementA.parents.some(\n      (parent) => parent.elementPath === elementB.elementPath\n    );\n  }\n\n  /**\n   * Checks if one element is a child of another.\n   * @param elementA The potential child element.\n   * @param elementB The potential parent element.\n   * @returns True if elementA is a child of elementB, false otherwise.\n   */\n  private _isChild(elementA: LocalElementKnown, elementB: LocalElementKnown) {\n    return this._getParent(elementA) === elementB.elementPath;\n  }\n\n  /**\n   * Checks if two local elements are internally related (same element).\n   * @param elementA The first element.\n   * @param elementB The second element.\n   * @returns True if the elements are internally related, false otherwise.\n   */\n  private _isInternal(\n    elementA: LocalElementKnown,\n    elementB: LocalElementKnown\n  ) {\n    return elementA.elementPath === elementB.elementPath;\n  }\n\n  /**\n   * Retrieves the relationship between two local known elements in terms of dependency.\n   * @param element The element depending on another element.\n   * @param dependency The element being depended on.\n   * @returns The relationship between the elements.\n   */\n  private _dependencyRelationship(\n    element: ElementDescription,\n    dependency: ElementDescription\n  ) {\n    if (\n      isIgnoredElement(dependency) ||\n      !isKnownLocalElement(dependency) ||\n      !isKnownLocalElement(element)\n    ) {\n      return null;\n    }\n    if (this._isInternal(dependency, element)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.INTERNAL;\n    }\n    if (this._isChild(dependency, element)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.CHILD;\n    }\n    if (this._isDescendant(dependency, element)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.DESCENDANT;\n    }\n    if (this._isSibling(dependency, element)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.SIBLING;\n    }\n    if (this._isChild(element, dependency)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.PARENT;\n    }\n    if (this._isDescendant(element, dependency)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.ANCESTOR;\n    }\n    if (this._isDescendantOfParent(dependency, element)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.UNCLE;\n    }\n    if (this._isDescendantOfParent(element, dependency)) {\n      return DEPENDENCY_RELATIONSHIPS_MAP.NEPHEW;\n    }\n    return null;\n  }\n\n  private _dependencyRelationships(\n    element: ElementDescription,\n    dependency: ElementDescription\n  ) {\n    const toRelationship = this._dependencyRelationship(element, dependency);\n    const fromRelationship = toRelationship\n      ? DEPENDENCY_RELATIONSHIPS_INVERTED_MAP[toRelationship]\n      : null;\n    return {\n      from: fromRelationship,\n      to: toRelationship,\n    };\n  }\n\n  /**\n   * Describes elements in a dependency relationship, and provides additional information about the dependency itself.\n   * @param options The options for describing the elements and the dependency details.\n   * @returns The description of the dependency between the elements.\n   */\n  public describeDependency({\n    from,\n    to,\n    source,\n    kind,\n    nodeKind,\n    specifiers,\n  }: DescribeDependencyOptions): DependencyDescription {\n    const cacheKey = this._dependenciesCache.getKey({\n      from,\n      to,\n      source,\n      kind,\n      nodeKind,\n      specifiers,\n    });\n    if (this._dependenciesCache.has(cacheKey)) {\n      return this._dependenciesCache.get(cacheKey)!;\n    }\n\n    const fromElement = this._elementsDescriptor.describeElement(from);\n    const toElement = this._elementsDescriptor.describeDependencyElement(\n      source,\n      to\n    );\n\n    const result = {\n      from: fromElement,\n      to: toElement,\n      dependency: {\n        kind,\n        nodeKind: nodeKind || null,\n        relationship: this._dependencyRelationships(fromElement, toElement),\n        specifiers: specifiers || null,\n      },\n    };\n\n    this._dependenciesCache.set(cacheKey, result);\n\n    return result;\n  }\n}\n","import type Mod from \"node:module\";\n\nimport isCoreModule from \"is-core-module\";\n\nimport { CacheManager, CacheManagerDisabled } from \"../Cache\";\nimport type { DescriptorOptionsNormalized } from \"../Config\";\nimport type { Micromatch } from \"../Matcher\";\nimport { isArray, isNullish } from \"../Support\";\n\nimport type {\n  ElementDescription,\n  ElementDescriptor,\n  ElementDescriptors,\n  LocalElementKnown,\n  CapturedValues,\n  FileElement,\n  ExternalDependencyElement,\n  LocalElementUnknown,\n  CoreDependencyElement,\n  DependencyElementDescription,\n  ElementsDescriptorSerializedCache,\n} from \"./ElementsDescriptor.types\";\nimport {\n  ELEMENT_DESCRIPTOR_MODES_MAP,\n  ELEMENT_ORIGINS_MAP,\n} from \"./ElementsDescriptor.types\";\nimport {\n  isElementDescriptorMode,\n  isKnownLocalElement,\n  isElementDescriptor,\n} from \"./ElementsDescriptorHelpers\";\n\nconst UNKNOWN_ELEMENT: LocalElementUnknown = {\n  path: null,\n  elementPath: null,\n  internalPath: null,\n  source: null,\n  baseSource: null,\n  parents: null,\n  type: null,\n  category: null,\n  captured: null,\n  origin: ELEMENT_ORIGINS_MAP.LOCAL,\n  isIgnored: false,\n  isUnknown: true,\n};\n\n/** Options for the _fileDescriptorMatch private method */\ntype FileDescriptorMatchOptions = {\n  /** The element descriptor to match. */\n  elementDescriptor: ElementDescriptor;\n  /** The file path to match against the descriptor */\n  filePath: string;\n  /** The current path segments leading to the element */\n  currentPathSegments: string[];\n  /** The last path segment that was matched */\n  lastPathSegmentMatching: number;\n  /** Whether the element matched previously */\n  alreadyMatched: boolean;\n};\n\nconst SCOPED_PACKAGE_REGEX = /^@[^/]*\\/?[^/]+/;\nconst EXTERNAL_PATH_REGEX = /^\\w/;\n\n/**\n * Class describing elements in a project given their paths and configuration.\n */\nexport class ElementsDescriptor {\n  private _mod: typeof Mod | null = null;\n  /**\n   * Cache to store previously described elements.\n   */\n  private readonly _descriptionsCache:\n    | CacheManager<string, ElementDescription>\n    | CacheManagerDisabled<string, ElementDescription>;\n\n  /**\n   * Cache to store previously described files.\n   */\n  private readonly _filesCache:\n    | CacheManager<string, FileElement>\n    | CacheManagerDisabled<string, FileElement>;\n\n  /**\n   * Configuration instance for this descriptor.\n   */\n  private readonly _config: DescriptorOptionsNormalized;\n\n  /**\n   * Element descriptors used by this descriptor.\n   */\n  private readonly _elementDescriptors: ElementDescriptors;\n\n  /** Micromatch instance for path matching */\n  private readonly _micromatch: Micromatch;\n\n  /**\n   * The configuration options for this descriptor.\n   * @param elementDescriptors The element descriptors.\n   * @param configOptions The configuration options.\n   * @param globalCache The global cache for various caching needs.\n   * @param micromatch The micromatch instance for path matching.\n   */\n  constructor(\n    elementDescriptors: ElementDescriptors,\n    configOptions: DescriptorOptionsNormalized,\n    micromatch: Micromatch\n  ) {\n    this._micromatch = micromatch;\n    this._elementDescriptors = elementDescriptors;\n    this._validateDescriptors(elementDescriptors);\n    this._config = configOptions;\n    this._filesCache = this._config.cache\n      ? new CacheManager<string, FileElement>()\n      : new CacheManagerDisabled<string, FileElement>();\n    this._descriptionsCache = this._config.cache\n      ? new CacheManager<string, ElementDescription>()\n      : new CacheManagerDisabled<string, ElementDescription>();\n    this._loadModuleInNode();\n  }\n\n  /**\n   * Serializes the elements cache to a plain object.\n   * @returns The serialized elements cache.\n   */\n  public serializeCache(): ElementsDescriptorSerializedCache {\n    return {\n      descriptions: this._descriptionsCache.serialize(),\n      files: this._filesCache.serialize(),\n    };\n  }\n\n  /**\n   * Sets the elements cache from a serialized object.\n   * @param serializedCache The serialized elements cache.\n   */\n  public setCacheFromSerialized(\n    serializedCache: ElementsDescriptorSerializedCache\n  ): void {\n    this._descriptionsCache.setFromSerialized(serializedCache.descriptions);\n    this._filesCache.setFromSerialized(serializedCache.files);\n  }\n\n  /**\n   * Clears the elements cache.\n   */\n  public clearCache(): void {\n    this._descriptionsCache.clear();\n    this._filesCache.clear();\n  }\n\n  /**\n   * Loads the Node.js module to access built-in modules information when running in Node.js environment.\n   */\n  private _loadModuleInNode(): void {\n    // istanbul ignore next: Fallback for non-Node.js environments\n    if (\n      !this._mod &&\n      !isNullish(process) &&\n      !isNullish(process.versions) &&\n      !isNullish(process.versions.node)\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      this._mod = require(\"node:module\");\n    }\n  }\n\n  /**\n   * Validates the element descriptors to ensure they are correctly defined.\n   */\n  private _validateDescriptors(elementDescriptors: ElementDescriptors): void {\n    let index = 0;\n    for (const descriptor of elementDescriptors) {\n      if (!isElementDescriptor(descriptor)) {\n        throw new Error(\n          `Element descriptor at index ${index} must have a pattern, and either a 'type' or 'category' defined.`\n        );\n      }\n      index++;\n    }\n  }\n\n  /**\n   * Determines if a dependency source is a core module.\n   * @param dependencySource The source of the dependency to check.\n   * @param baseDependencySource The base source of the dependency to check.\n   * @returns True if the dependency source is a core module, false otherwise.\n   */\n  private _dependencySourceIsCoreModule(\n    dependencySource: string,\n    baseDependencySource: string\n  ): boolean {\n    // istanbul ignore next: Fallback for non-Node.js environments\n    if (this._mod) {\n      const baseSourceWithoutPrefix = baseDependencySource.startsWith(\"node:\")\n        ? baseDependencySource.slice(5)\n        : baseDependencySource;\n      return this._mod.builtinModules.includes(baseSourceWithoutPrefix);\n    }\n    // istanbul ignore next: Fallback for non-Node.js environments\n    return isCoreModule(dependencySource);\n  }\n\n  /**\n   * Determines if a dependency source is scoped (e.g., @scope/package).\n   * @param dependencySource The source of the dependency to check.\n   * @returns True if the dependency source is scoped, false otherwise.\n   */\n  private _dependencySourceIsScoped(dependencySource: string): boolean {\n    return SCOPED_PACKAGE_REGEX.test(dependencySource);\n  }\n\n  /**\n   * Determines if a dependency source is external or an alias.\n   * @param dependencySource The source of the dependency to check.\n   * @returns True if the dependency source is external or an alias, false otherwise.\n   */\n  private _dependencySourceIsExternalOrScoped(\n    dependencySource: string\n  ): boolean {\n    return (\n      EXTERNAL_PATH_REGEX.test(dependencySource) ||\n      this._dependencySourceIsScoped(dependencySource)\n    );\n  }\n\n  /**\n   * Gets the base source of an external module.\n   * @param dependencySource The source of the dependency to check.\n   * @returns The base source of the external module. (e.g., for \"@scope/package/submodule\", it returns \"@scope/package\")\n   */\n  private _getExternalOrCoreModuleBaseSource(dependencySource: string): string {\n    if (this._dependencySourceIsScoped(dependencySource)) {\n      const [scope, packageName] = dependencySource.split(\"/\");\n      return `${scope}/${packageName}`;\n    }\n    const [pkg] = dependencySource.split(\"/\");\n    return pkg;\n  }\n\n  /**\n   * Determines if an element is external based on its file path and dependency source.\n   * Files inside \"node_modules\" are considered external.\n   * If the dependency source is not provided, only the file path is considered.\n   * If the dependency source is provided, it must not be a local path (i.e, it should start by \"./\", \"../\", or \"/\").\n   * @param filePath\n   * @param dependencySource\n   * @returns\n   */\n  private _isExternalDependency(\n    filePath: string | null,\n    dependencySource?: string\n  ): boolean {\n    return (\n      (!filePath || filePath.includes(\"node_modules\")) &&\n      // Not having a source, and being in node_modules only could happen if user is analyzing a file directly from there, not as a dependency. Should this be considered external then?\n      (!dependencySource ||\n        this._dependencySourceIsExternalOrScoped(dependencySource))\n    );\n  }\n\n  /**\n   * Determines if a given path is included based on the configuration.\n   * Uses caching for better performance on repeated calls.\n   * @param elementPath The element path to check.\n   * @param includeExternal Whether to include external files.\n   * @returns True if the path is included, false otherwise.\n   */\n  private _pathIsIncluded(elementPath: string): boolean {\n    let result: boolean;\n\n    if (this._config.includePaths && this._config.ignorePaths) {\n      const isIncluded = this._micromatch.isMatch(\n        elementPath,\n        this._config.includePaths\n      );\n      const isIgnored = this._micromatch.isMatch(\n        elementPath,\n        this._config.ignorePaths\n      );\n      result = isIncluded && !isIgnored;\n    } else if (this._config.includePaths) {\n      result = this._micromatch.isMatch(elementPath, this._config.includePaths);\n    } else if (this._config.ignorePaths) {\n      result = !this._micromatch.isMatch(elementPath, this._config.ignorePaths);\n    } else {\n      result = true;\n    }\n\n    return result;\n  }\n\n  /**\n   * Gets captured values from the captured array and capture configuration.\n   * @param captured The array of captured strings.\n   * @param captureConfig The configuration for capturing values.\n   * @returns The captured values as an object.\n   */\n  private _getCapturedValues(\n    captured: string[],\n    captureConfig?: string[]\n  ): CapturedValues | null {\n    if (!captureConfig) {\n      return null;\n    }\n    return captured.reduce((capturedValues, captureValue, index) => {\n      if (captureConfig[index]) {\n        capturedValues[captureConfig[index]] = captureValue;\n      }\n      return capturedValues;\n    }, {} as CapturedValues);\n  }\n\n  /**\n   * Gets the element path based on the path pattern, path segments to the element, and all path segments from the file path.\n   * @param pathPattern The element path pattern.\n   * @param pathSegments The path segments leading to the element.\n   * @param allPathSegments The full path segments from the file path.\n   * @returns The element path.\n   */\n  private _getElementPath(\n    pathPattern: string,\n    pathSegments: string[],\n    allPathSegments: string[]\n  ): string {\n    const elementPathRegexp = this._micromatch.makeRe(pathPattern);\n\n    const testedSegments: string[] = [];\n    let result: string | undefined;\n\n    for (const pathSegment of pathSegments) {\n      testedSegments.push(pathSegment);\n      const joinedSegments = testedSegments.join(\"/\");\n      if (elementPathRegexp.test(joinedSegments)) {\n        result = joinedSegments;\n        break; // Early exit when match is found\n      }\n    }\n    // NOTE: result should never be undefined here, as we already matched the pattern before\n    return `${[...allPathSegments].reverse().join(\"/\").split(result!)[0]}${result}`;\n  }\n\n  /**\n   * Determines if an element descriptor matches the given parameters in the provided path.\n   * @param options The options for matching the descriptor.\n   * @returns The result of the match, including whether it matched and any captured values.\n   */\n  private _fileDescriptorMatch(options: FileDescriptorMatchOptions): {\n    matched: true;\n    capture: string[];\n    baseCapture: string[] | null;\n    useFullPathMatch: boolean;\n    patternUsed: string;\n  };\n\n  private _fileDescriptorMatch({\n    elementDescriptor,\n    filePath,\n    currentPathSegments,\n    lastPathSegmentMatching,\n    alreadyMatched,\n  }: FileDescriptorMatchOptions): {\n    matched: boolean;\n    capture?: string[];\n    baseCapture?: string[] | null;\n    useFullPathMatch?: boolean;\n    patternUsed?: string;\n  } {\n    const mode = isElementDescriptorMode(elementDescriptor.mode)\n      ? elementDescriptor.mode\n      : ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER;\n    // TODO: Filter patterns to file/folder/full when mode supports \"external\". Another method to match external dependencies might be needed.\n    const patterns = isArray(elementDescriptor.pattern)\n      ? elementDescriptor.pattern\n      : [elementDescriptor.pattern];\n\n    for (const pattern of patterns) {\n      const useFullPathMatch =\n        mode === ELEMENT_DESCRIPTOR_MODES_MAP.FULL && !alreadyMatched;\n      const effectivePattern =\n        mode === ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER && !alreadyMatched\n          ? `${pattern}/**/*`\n          : pattern;\n\n      const targetPath = useFullPathMatch\n        ? filePath\n        : currentPathSegments.join(\"/\");\n\n      let baseCapture: string[] | null = null;\n      let hasCapture = true;\n\n      if (elementDescriptor.basePattern) {\n        const baseTarget = filePath\n          .split(\"/\")\n          .slice(0, filePath.split(\"/\").length - lastPathSegmentMatching)\n          .join(\"/\");\n        baseCapture = this._micromatch.capture(\n          [elementDescriptor.basePattern, \"**\", effectivePattern].join(\"/\"),\n          baseTarget\n        );\n        hasCapture = baseCapture !== null;\n      }\n\n      const capture = this._micromatch.capture(effectivePattern, targetPath);\n\n      if (capture && hasCapture) {\n        return {\n          matched: true,\n          capture,\n          baseCapture,\n          useFullPathMatch,\n          patternUsed: pattern,\n        };\n      }\n    }\n\n    return { matched: false };\n  }\n\n  /**\n   * Retrieves the description of a local file given its path.\n   * @param elementPath The path of the element to describe.\n   * @returns The description of the element.\n   */\n  private _getFileDescription(filePath?: string): FileElement {\n    // Return unknown element if no file path is provided. Filepath couldn't be resolved.\n    if (!filePath) {\n      return {\n        ...UNKNOWN_ELEMENT,\n      };\n    }\n\n    // Return ignored element if the path is not included in the configuration.\n    if (!this._pathIsIncluded(filePath)) {\n      return {\n        ...UNKNOWN_ELEMENT,\n        path: filePath,\n        isIgnored: true,\n        origin: null,\n      };\n    }\n\n    const parents: LocalElementKnown[\"parents\"] = [];\n    const elementResult: Partial<LocalElementKnown> = {\n      path: filePath,\n      type: null,\n      category: null,\n      captured: null,\n      origin: ELEMENT_ORIGINS_MAP.LOCAL,\n      isIgnored: false,\n    };\n\n    interface State {\n      pathSegmentsAccumulator: string[];\n      lastPathSegmentMatching: number;\n    }\n\n    const state: State = {\n      pathSegmentsAccumulator: [],\n      lastPathSegmentMatching: 0,\n    };\n\n    const pathSegments = filePath.split(\"/\").reverse();\n\n    const processElementMatch = (\n      elementDescriptor: ElementDescriptor,\n      matchInfo: {\n        matched: true;\n        capture: string[];\n        baseCapture: string[] | null;\n        useFullPathMatch: boolean;\n        patternUsed: string;\n      },\n      currentPathSegments: string[],\n      elementPaths: string[]\n    ) => {\n      const { capture, baseCapture, useFullPathMatch, patternUsed } = matchInfo;\n\n      let capturedValues = this._getCapturedValues(\n        capture,\n        elementDescriptor.capture\n      );\n\n      if (elementDescriptor.basePattern && baseCapture) {\n        capturedValues = {\n          ...this._getCapturedValues(\n            baseCapture,\n            elementDescriptor.baseCapture\n          ),\n          ...capturedValues,\n        };\n      }\n\n      const elementPath = useFullPathMatch\n        ? filePath\n        : this._getElementPath(patternUsed, currentPathSegments, elementPaths);\n\n      if (!elementResult.type && !elementResult.category) {\n        const mode =\n          elementDescriptor.mode || ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER;\n        // It is the main element\n        elementResult.type = elementDescriptor.type || null;\n        elementResult.category = elementDescriptor.category || null;\n        elementResult.isUnknown = false;\n        elementResult.elementPath = elementPath;\n        elementResult.captured = capturedValues;\n        elementResult.internalPath =\n          mode === ELEMENT_DESCRIPTOR_MODES_MAP.FOLDER ||\n          filePath !== elementPath // When using 'file' mode, but the pattern matches a folder, we need to calculate the internal path\n            ? filePath.replace(`${elementPath}/`, \"\")\n            : filePath.split(\"/\").pop(); // In 'file' mode, if the pattern matches the full file, internalPath is the file name\n      } else {\n        // It is a parent element, because we have already matched the main one\n        parents.push({\n          type: elementDescriptor.type || null,\n          category: elementDescriptor.category || null,\n          elementPath,\n          captured: capturedValues,\n        });\n      }\n    };\n\n    // Optimized matching loop - reduced complexity from O(n*m) to better performance\n    for (let i = 0; i < pathSegments.length; i++) {\n      const segment = pathSegments[i];\n      state.pathSegmentsAccumulator.unshift(segment);\n\n      // Early exit if we have both type and category (main element found)\n      const alreadyHasMainElement =\n        Boolean(elementResult.type) || Boolean(elementResult.category);\n\n      for (const elementDescriptor of this._elementDescriptors) {\n        const match = this._fileDescriptorMatch({\n          elementDescriptor,\n          filePath,\n          currentPathSegments: state.pathSegmentsAccumulator,\n          lastPathSegmentMatching: state.lastPathSegmentMatching,\n          alreadyMatched: alreadyHasMainElement,\n        });\n\n        if (match.matched) {\n          processElementMatch(\n            elementDescriptor,\n            match,\n            state.pathSegmentsAccumulator,\n            pathSegments\n          );\n          state.pathSegmentsAccumulator = [];\n          state.lastPathSegmentMatching = i + 1;\n\n          // Break out of the inner loop since we found a match\n          break;\n        }\n      }\n    }\n\n    const result = { ...elementResult, parents };\n\n    // Not matched as any element, ensure that it is marked as unknown\n    if (!isKnownLocalElement(result)) {\n      return {\n        ...UNKNOWN_ELEMENT,\n        path: filePath,\n      };\n    }\n\n    return result;\n  }\n\n  /**\n   * Describes a file given its path.\n   * @param includeExternal Whether to include external files (inside node_modules) in the matching process.\n   * @param filePath The path of the file to describe.\n   * @returns The description of the element.\n   */\n  private _describeFile(filePath?: string): FileElement {\n    const cacheKey = this._filesCache.getKey(String(filePath));\n    if (this._filesCache.has(cacheKey)) {\n      return this._filesCache.get(cacheKey)!;\n    }\n    const description = this._getFileDescription(filePath);\n    this._filesCache.set(cacheKey, description);\n    return description;\n  }\n\n  /**\n   * Returns an external or core dependency element given its dependency source and file path.\n   * @param dependencySource The source of the dependency.\n   * @param filePath The resolved file path of the dependency, if known.\n   * @returns The external or core dependency element, or null if it is a local dependency.\n   */\n  private _getExternalOrCoreDependencyElement(\n    dependencySource: string,\n    filePath?: string\n  ): ExternalDependencyElement | CoreDependencyElement | null {\n    const baseDependencySource =\n      this._getExternalOrCoreModuleBaseSource(dependencySource);\n\n    // Determine if the dependency source is a core module\n    const isCore = this._dependencySourceIsCoreModule(\n      dependencySource,\n      baseDependencySource\n    );\n\n    if (isCore) {\n      const coreElement: CoreDependencyElement = {\n        ...UNKNOWN_ELEMENT,\n        source: dependencySource,\n        baseSource: baseDependencySource,\n        origin: ELEMENT_ORIGINS_MAP.CORE,\n      };\n      return coreElement;\n    }\n\n    const isExternal = this._isExternalDependency(\n      filePath || null,\n      dependencySource\n    );\n\n    if (isExternal) {\n      const externalElement: ExternalDependencyElement = {\n        ...UNKNOWN_ELEMENT,\n        path: filePath || null,\n        internalPath: dependencySource.replace(baseDependencySource, \"\"),\n        source: dependencySource,\n        baseSource: baseDependencySource,\n        origin: ELEMENT_ORIGINS_MAP.EXTERNAL,\n      };\n      return externalElement;\n    }\n    return null;\n  }\n\n  /**\n   * Describes an element given its file path and dependency source, if any.\n   * @param filePath The path of the file to describe.\n   * @param dependencySource The source of the dependency, if the element to describe is so. It refers to the import/export path used to reference the file or external module.\n   * @returns The description of the element. A dependency element if dependency source is provided, otherwise a file element.\n   */\n  private _describeElement(): LocalElementUnknown;\n  private _describeElement(filePath?: string): FileElement;\n  private _describeElement(\n    filePath?: string,\n    dependencySource?: string\n  ): DependencyElementDescription;\n\n  private _describeElement(\n    filePath?: string,\n    dependencySource?: string\n  ): ElementDescription {\n    const cacheKey = `${String(dependencySource)}::${String(filePath)}`;\n    if (this._descriptionsCache.has(cacheKey)) {\n      return this._descriptionsCache.get(cacheKey)!;\n    }\n\n    const externalOrCoreDependencyElement = dependencySource\n      ? this._getExternalOrCoreDependencyElement(dependencySource, filePath)\n      : null;\n\n    if (externalOrCoreDependencyElement) {\n      this._descriptionsCache.set(cacheKey, externalOrCoreDependencyElement);\n      return externalOrCoreDependencyElement;\n    }\n\n    const fileDescription = this._describeFile(filePath);\n    const elementResult = dependencySource\n      ? {\n          ...fileDescription,\n          source: dependencySource,\n        }\n      : fileDescription;\n\n    this._descriptionsCache.set(cacheKey, elementResult);\n    return elementResult;\n  }\n\n  /**\n   * Describes an element given its file path.\n   * @param filePath The path of the file to describe.\n   * @returns The description of the element.\n   */\n  public describeElement(filePath?: string): FileElement {\n    return this._describeElement(filePath);\n  }\n\n  /**\n   * Describes a dependency element given its dependency source and file path.\n   * @param dependencySource The source of the dependency.\n   * @param filePath The path of the file being the dependency, if known.\n   * @returns The description of the dependency element.\n   */\n  public describeDependencyElement(\n    dependencySource: string,\n    filePath?: string\n  ): DependencyElementDescription {\n    return this._describeElement(filePath, dependencySource);\n  }\n}\n","import type { DescriptorOptionsNormalized } from \"../Config\";\nimport type { Micromatch } from \"../Matcher\";\n\nimport { DependenciesDescriptor } from \"./DependenciesDescriptor\";\nimport type {\n  DependencyDescription,\n  DescribeDependencyOptions,\n} from \"./DependenciesDescriptor.types\";\nimport type { DescriptorsSerializedCache } from \"./Descriptors.types\";\nimport { ElementsDescriptor } from \"./ElementsDescriptor\";\nimport type {\n  ElementDescriptors,\n  DependencyElementDescription,\n  FileElement,\n} from \"./ElementsDescriptor.types\";\n\n/**\n * Class with methods to describe elements and dependencies between them.\n */\nexport class Descriptors {\n  private readonly _elementsDescriptor: ElementsDescriptor;\n  private readonly _dependenciesDescriptor: DependenciesDescriptor;\n\n  /** Creates a new DescriptorsManager instance\n   * @param elementDescriptors The element descriptors.\n   * @param configOptions The configuration options.\n   * @param micromatch The Micromatch instance.\n   */\n  constructor(\n    elementDescriptors: ElementDescriptors,\n    config: DescriptorOptionsNormalized,\n    micromatch: Micromatch\n  ) {\n    this._elementsDescriptor = new ElementsDescriptor(\n      elementDescriptors,\n      config,\n      micromatch\n    );\n    this._dependenciesDescriptor = new DependenciesDescriptor(\n      this._elementsDescriptor,\n      config\n    );\n  }\n\n  /**\n   * Serializes the elements and dependencies cache to a plain object.\n   * @returns The serialized elements and dependencies cache.\n   */\n  public serializeCache(): DescriptorsSerializedCache {\n    return {\n      elements: this._elementsDescriptor.serializeCache(),\n      dependencies: this._dependenciesDescriptor.serializeCache(),\n    };\n  }\n\n  /**\n   * Sets the elements and dependencies cache from a serialized object.\n   * @param serializedCache The serialized elements and dependencies cache.\n   */\n  public setCacheFromSerialized(\n    serializedCache: DescriptorsSerializedCache\n  ): void {\n    this._elementsDescriptor.setCacheFromSerialized(serializedCache.elements);\n    this._dependenciesDescriptor.setCacheFromSerialized(\n      serializedCache.dependencies\n    );\n  }\n\n  /**\n   * Clears all caches.\n   */\n  public clearCache(): void {\n    this._elementsDescriptor.clearCache();\n    this._dependenciesDescriptor.clearCache();\n  }\n\n  /**\n   * Describes an element given its file path.\n   * @param filePath The path of the file to describe.\n   * @returns The description of the element.\n   */\n  public describeElement(filePath?: string): FileElement {\n    return this._elementsDescriptor.describeElement(filePath);\n  }\n\n  /**\n   * Describes a dependency element given its dependency source and file path.\n   * @param dependencySource The source of the dependency.\n   * @param filePath The path of the file being the dependency, if known.\n   * @returns The description of the dependency element.\n   */\n  public describeDependencyElement(\n    dependencySource: string,\n    filePath?: string\n  ): DependencyElementDescription {\n    return this._elementsDescriptor.describeDependencyElement(\n      dependencySource,\n      filePath\n    );\n  }\n\n  /**\n   * Describes elements in a dependency relationship, and provides additional information about the dependency itself.\n   * @param options The options for describing the elements and the dependency details.\n   * @returns The description of the dependency between the elements.\n   */\n  public describeDependency(\n    options: DescribeDependencyOptions\n  ): DependencyDescription {\n    return this._dependenciesDescriptor.describeDependency(options);\n  }\n}\n","import type { DescriptorOptionsNormalized } from \"../Config\";\nimport type {\n  ElementDescriptors,\n  DescribeDependencyOptions,\n  ElementDescription,\n  DependencyDescription,\n} from \"../Descriptor\";\nimport {\n  Descriptors,\n  isElementDescription,\n  isDependencyDescription,\n} from \"../Descriptor\";\nimport { isString } from \"../Support\";\n\nimport type { DependenciesMatcher } from \"./DependenciesMatcher\";\nimport type { ElementsMatcher } from \"./ElementsMatcher\";\nimport type {\n  DependencySelector,\n  MatcherOptions,\n  ElementsSelector,\n  ElementSelectorData,\n  DependencyMatchResult,\n  MatcherSerializedCache,\n} from \"./Matcher.types\";\nimport { isDependencySelector, isElementsSelector } from \"./MatcherHelpers\";\nimport type { Micromatch } from \"./Micromatch\";\n\n/**\n * Matcher class to evaluate if elements or dependencies match given selectors.\n */\nexport class Matcher {\n  private readonly _descriptors: Descriptors;\n  private readonly _elementsMatcher: ElementsMatcher;\n  private readonly _dependenciesMatcher: DependenciesMatcher;\n\n  /**\n   * Constructor for the Matcher class.\n   * @param descriptors Element descriptors to use for matching.\n   * @param elementsMatcher Elements matcher instance.\n   * @param dependenciesMatcher Dependencies matcher instance.\n   * @param config Configuration options.\n   * @param globalCache Global cache instance.\n   */\n  constructor(\n    descriptors: ElementDescriptors,\n    elementsMatcher: ElementsMatcher,\n    dependenciesMatcher: DependenciesMatcher,\n    config: DescriptorOptionsNormalized,\n    micromatch: Micromatch\n  ) {\n    this._descriptors = new Descriptors(descriptors, config, micromatch);\n    this._elementsMatcher = elementsMatcher;\n    this._dependenciesMatcher = dependenciesMatcher;\n  }\n\n  /**\n   * Determines if an element matches a given selector.\n   * @param filePath The file path of the element\n   * @param selector The selector to match against\n   * @param options Extra matcher options\n   * @returns True if the element matches the selector, false otherwise\n   */\n  private _isElementMatch(\n    filePath: string,\n    selector: ElementsSelector,\n    options?: MatcherOptions\n  ): boolean {\n    const description = this._descriptors.describeElement(filePath);\n    return this._elementsMatcher.isElementMatch(description, selector, options);\n  }\n\n  /**\n   * Determines if a dependency matches a given selector.\n   * @param dependencyData The data describing the dependency\n   * @param selector The selector to match against\n   * @param options Extra matcher options\n   * @returns True if the dependency matches the selector, false otherwise\n   */\n  private _isDependencyMatch(\n    dependencyData: DescribeDependencyOptions,\n    selector: DependencySelector,\n    options?: MatcherOptions\n  ): boolean {\n    const description = this._descriptors.describeDependency(dependencyData);\n    return this._dependenciesMatcher.isDependencyMatch(\n      description,\n      selector,\n      options\n    );\n  }\n\n  /**\n   * Determines if the given element or dependency matches the provided selector.\n   * @param descriptorOptions The file path or dependency options to describe the element or dependency\n   * @param selector The selector to match against\n   * @param options Extra matcher options\n   */\n  public isMatch(\n    descriptorOptions: string,\n    selector: ElementsSelector,\n    options?: MatcherOptions\n  ): boolean;\n  public isMatch(\n    descriptorOptions: DescribeDependencyOptions,\n    selector: DependencySelector,\n    options?: MatcherOptions\n  ): boolean;\n  public isMatch(\n    descriptorOptions: string | DescribeDependencyOptions,\n    selector: ElementsSelector | DependencySelector,\n    options?: MatcherOptions\n  ): boolean {\n    if (isString(descriptorOptions)) {\n      return this._isElementMatch(\n        descriptorOptions,\n        selector as ElementsSelector,\n        options\n      );\n    }\n    return this._isDependencyMatch(\n      descriptorOptions,\n      selector as DependencySelector,\n      options\n    );\n  }\n\n  /**\n   * Determines the selector matching for an element.\n   * @param filePath The file path of the element\n   * @param selector The selectors to match against\n   * @param options Extra options for matching\n   * @returns The matching selector data or null if no match is found\n   */\n  private _getElementSelectorMatching(\n    filePath: string,\n    selector: ElementsSelector,\n    options?: MatcherOptions\n  ) {\n    const description = this._descriptors.describeElement(filePath);\n    return this._elementsMatcher.getSelectorMatching(\n      description,\n      selector,\n      options\n    );\n  }\n\n  /**\n   * Determines the selector matching for a dependency.\n   * @param dependencyData The data describing the dependency\n   * @param selector The selectors to match against\n   * @param options Extra options for matching\n   * @returns The matching dependency result or null if no match is found\n   */\n  private _getDependencySelectorMatching(\n    dependencyData: DescribeDependencyOptions,\n    selector: DependencySelector,\n    options?: MatcherOptions\n  ) {\n    const description = this._descriptors.describeDependency(dependencyData);\n    return this._dependenciesMatcher.getSelectorsMatching(\n      description,\n      selector,\n      options\n    );\n  }\n\n  /**\n   * Determines the selector matching for a dependency or element.\n   * @param descriptorOptions The file path or dependency options to describe the element or dependency\n   * @param selector The selectors to match against\n   * @param options Extra options for matching\n   * @returns The matching dependency result or element selector data, or null if no match is found\n   */\n  public getSelectorMatching(\n    descriptorOptions: string,\n    selector: ElementsSelector,\n    options?: MatcherOptions\n  ): ElementSelectorData | null;\n  public getSelectorMatching(\n    descriptorOptions: DescribeDependencyOptions,\n    selector: DependencySelector,\n    options?: MatcherOptions\n  ): DependencyMatchResult | null;\n  public getSelectorMatching(\n    descriptorOptions: string | DescribeDependencyOptions,\n    selector: ElementsSelector | DependencySelector,\n    options?: MatcherOptions\n  ): ElementSelectorData | DependencyMatchResult | null {\n    if (isString(descriptorOptions)) {\n      return this._getElementSelectorMatching(\n        descriptorOptions,\n        selector as ElementsSelector,\n        options\n      );\n    }\n    return this._getDependencySelectorMatching(\n      descriptorOptions,\n      selector as DependencySelector,\n      options\n    );\n  }\n\n  /**\n   * Returns the selectors matching result for the given element or dependency description.\n   * @param description The element or dependency  description to check.\n   * @param selector The selector to check against.\n   * @param options Extra options for matching, such as templates data, globals for dependency selectors, etc.\n   * @returns The selectors matching result for the given description, and whether it matches or not.\n   */\n  public getSelectorMatchingDescription(\n    description: DependencyDescription,\n    selector: DependencySelector,\n    options?: MatcherOptions\n  ): DependencyMatchResult;\n  public getSelectorMatchingDescription(\n    description: ElementDescription,\n    selector: ElementsSelector,\n    options?: MatcherOptions\n  ): ElementSelectorData;\n  public getSelectorMatchingDescription(\n    description: DependencyDescription | ElementDescription,\n    selector: DependencySelector | ElementsSelector,\n    options?: MatcherOptions\n  ): DependencyMatchResult | ElementSelectorData | null {\n    if (isElementsSelector(selector) && isElementDescription(description)) {\n      return this._elementsMatcher.getSelectorMatching(\n        description,\n        selector,\n        options\n      );\n    } else if (\n      isDependencySelector(selector) &&\n      isDependencyDescription(description)\n    ) {\n      return this._dependenciesMatcher.getSelectorsMatching(\n        description,\n        selector,\n        options\n      );\n    }\n    throw new Error(\n      \"Invalid arguments: Please provide a valid description and selector\"\n    );\n  }\n\n  /**\n   * Describes an element given its file path.\n   * @param filePath The path of the file to describe.\n   * @returns The description of the element.\n   */\n  public describeElement(filePath: string) {\n    return this._descriptors.describeElement(filePath);\n  }\n\n  /**\n   * Describes a dependency element given its dependency source and file path.\n   * @param dependencySource The source of the dependency.\n   * @param filePath The path of the file being the dependency, if known.\n   * @returns The description of the dependency element.\n   */\n  public describeDependencyElement(\n    dependencySource: string,\n    filePath?: string\n  ) {\n    return this._descriptors.describeDependencyElement(\n      dependencySource,\n      filePath\n    );\n  }\n\n  /**\n   * Describes elements in a dependency relationship, and provides additional information about the dependency itself.\n   * @param options The options for describing the elements and the dependency details.\n   * @returns The description of the dependency between the elements.\n   */\n  public describeDependency(options: DescribeDependencyOptions) {\n    return this._descriptors.describeDependency(options);\n  }\n\n  /**\n   * Clears all caches.\n   */\n  public clearCache() {\n    this._descriptors.clearCache();\n  }\n\n  /**\n   * Serializes the descriptors matchers cache to a plain object.\n   * @returns The serialized cache\n   */\n  public serializeCache(): MatcherSerializedCache {\n    return {\n      descriptors: this._descriptors.serializeCache(),\n    };\n  }\n\n  /**\n   * Sets the descriptors matchers cache from a serialized object.\n   * @param serializedCache The serialized cache\n   */\n  public setCacheFromSerialized(serializedCache: {\n    descriptors: ReturnType<Descriptors[\"serializeCache\"]>;\n  }) {\n    this._descriptors.setCacheFromSerialized(serializedCache.descriptors);\n  }\n}\n","import micromatch from \"micromatch\";\n\nimport { CacheManager, CacheManagerDisabled } from \"../Cache\";\nimport { isArray } from \"../Support\";\n\nimport type { MicromatchSerializedCache } from \"./Matcher.types\";\n\n/**\n * Cache key type for micromatch matching results\n */\ntype MatchingResultsCacheKey = {\n  value: string;\n  pattern: string | string[];\n};\n\n/**\n * Cache for micromatch matching results\n */\nclass MatchingResultsCache extends CacheManager<\n  MatchingResultsCacheKey,\n  boolean\n> {\n  /**\n   * Generates a unique cache key based on the value and pattern\n   * @param param0 The cache key components\n   * @returns The generated cache key\n   */\n  protected generateKey({ value, pattern }: MatchingResultsCacheKey): string {\n    return `${value}::${isArray(pattern) ? pattern.join(\"|\") : pattern}`;\n  }\n}\n\n/**\n * Cache key type for micromatch captured values\n */\ntype CapturedValueCacheKey = {\n  pattern: string;\n  target: string;\n};\n\n/**\n * Cache for micromatch captured values\n */\nclass CapturedValueCache extends CacheManager<\n  CapturedValueCacheKey,\n  string[] | null\n> {\n  /**\n   * Generates a unique cache key based on the pattern and target\n   * @param param0 The cache key components\n   * @returns The generated cache key\n   */\n  protected generateKey({ pattern, target }: CapturedValueCacheKey): string {\n    return `${pattern}|${target}`;\n  }\n}\n\n/**\n * Micromatch wrapper class with caching capabilities.\n */\n\nexport class Micromatch {\n  /**\n   * Cache for micromatch matching results\n   */\n  private readonly _matchingResultsCache:\n    | MatchingResultsCache\n    | CacheManagerDisabled<MatchingResultsCacheKey, boolean>;\n\n  /**\n   * Cache for micromatch captures\n   */\n  private readonly _capturesCache:\n    | CapturedValueCache\n    | CacheManagerDisabled<CapturedValueCacheKey, string[] | null> =\n    new CacheManagerDisabled<CapturedValueCacheKey, string[] | null>();\n\n  /**\n   * Cache for micromatch makeRe results\n   */\n  private readonly _makeReCache: CacheManagerDisabled<string, RegExp> =\n    new CacheManagerDisabled<string, RegExp>();\n\n  /**\n   * Creates an instance of Micromatch class.\n   * @param cache Whether to use caching or not.\n   */\n  constructor(cache: boolean) {\n    this._matchingResultsCache = cache\n      ? new MatchingResultsCache()\n      : new CacheManagerDisabled<MatchingResultsCacheKey, boolean>();\n    this._capturesCache = cache\n      ? new CapturedValueCache()\n      : new CacheManagerDisabled<CapturedValueCacheKey, string[] | null>();\n    this._makeReCache = cache\n      ? new CacheManager<string, RegExp>()\n      : new CacheManagerDisabled<string, RegExp>();\n  }\n\n  /**\n   * Clears all caches.\n   */\n  public clearCache(): void {\n    this._matchingResultsCache.clear();\n    this._capturesCache.clear();\n    this._makeReCache.clear();\n  }\n\n  /**\n   * Serializes the current cache state.\n   * @returns The serialized cache data.\n   */\n  public serializeCache(): MicromatchSerializedCache {\n    return {\n      matchingResults: this._matchingResultsCache.serialize(),\n      captures: this._capturesCache.serialize(),\n    };\n  }\n\n  /**\n   * Restores the cache state from serialized data.\n   * @param serializedCache The serialized cache data.\n   */\n  public setFromSerialized(serializedCache: MicromatchSerializedCache): void {\n    this._matchingResultsCache.setFromSerialized(\n      serializedCache.matchingResults\n    );\n    this._capturesCache.setFromSerialized(serializedCache.captures);\n  }\n\n  /**\n   * Optimized micromatch match with caching.\n   * @param value The value to match.\n   * @param pattern The pattern to match against.\n   * @returns True if the value matches the pattern, false otherwise.\n   */\n  public isMatch(value: string, pattern: string | string[]): boolean {\n    const cacheKey = this._matchingResultsCache.getKey({\n      value,\n      pattern,\n    });\n\n    if (this._matchingResultsCache.has(cacheKey)) {\n      return this._matchingResultsCache.get(cacheKey)!;\n    }\n\n    const isMatch = micromatch.isMatch(value, pattern);\n    this._matchingResultsCache.set(cacheKey, isMatch);\n    return isMatch;\n  }\n\n  /**\n   * Optimized micromatch capture with caching.\n   * @param pattern The pattern to match against.\n   * @param target The target string to test.\n   * @returns Captured groups or null if no match.\n   */\n  public capture(pattern: string, target: string): string[] | null {\n    const cacheKey = this._capturesCache.getKey({ pattern, target });\n\n    if (this._capturesCache.has(cacheKey)) {\n      return this._capturesCache.get(cacheKey)!;\n    }\n\n    const result = micromatch.capture(pattern, target);\n    this._capturesCache.set(cacheKey, result);\n    return result;\n  }\n\n  /**\n   * Optimized micromatch makeRe with caching.\n   * @param pattern The pattern to convert to RegExp.\n   * @returns The RegExp instance.\n   */\n  public makeRe(pattern: string): RegExp {\n    if (this._makeReCache.has(pattern)) {\n      return this._makeReCache.get(pattern)!;\n    }\n    const regexp = micromatch.makeRe(pattern);\n    this._makeReCache.set(pattern, regexp);\n    return regexp;\n  }\n}\n","import { CacheManager } from \"./Cache\";\nimport type { ConfigOptionsNormalized } from \"./Config\";\nimport type { ElementDescriptors } from \"./Descriptor\";\nimport type { Matcher } from \"./Matcher\";\n\n/**\n * Cache manager for Matcher instances, unique for each different configuration\n */\nexport class MatchersCache extends CacheManager<\n  {\n    config: ConfigOptionsNormalized;\n    elementDescriptors: ElementDescriptors;\n  },\n  {\n    config: ConfigOptionsNormalized;\n    elementDescriptors: ElementDescriptors;\n    matcher: Matcher;\n  }\n> {\n  /**\n   * Generates a unique key based on the configuration options and element descriptors\n   * @param params The configuration and element descriptors\n   * @returns A unique string key\n   */\n  protected generateKey({\n    config,\n    elementDescriptors,\n  }: {\n    config: ConfigOptionsNormalized;\n    elementDescriptors: ElementDescriptors;\n  }): string {\n    const configHash = `${config.legacyTemplates}|${config.includePaths}|${config.ignorePaths}|${\n      config.cache\n    }`;\n\n    const elementDescriptorsHash = elementDescriptors\n      .map(\n        (descriptor) =>\n          `${descriptor.type}|${descriptor.category}|${descriptor.pattern}|${descriptor.basePattern}|${descriptor.mode}|${descriptor.capture}|${descriptor.baseCapture}`\n      )\n      .join(\",\");\n    return `${configHash}|:|${elementDescriptorsHash}`;\n  }\n}\n","import type { ConfigOptions, ConfigOptionsNormalized } from \"./Config\";\nimport { Config } from \"./Config\";\nimport type { ElementDescriptors } from \"./Descriptor\";\nimport type { ElementsSerializedCache } from \"./Elements.types\";\nimport {\n  Micromatch,\n  DependenciesMatcher,\n  ElementsMatcher,\n  Matcher,\n} from \"./Matcher\";\nimport { MatchersCache } from \"./MatchersCache\";\n\n/**\n * Main class to interact with Elements functionality.\n * It include one method to get descriptors with different caching for different configurations, methods to manage the cache, and methods to match element selectors against element descriptions.\n */\nexport class Elements {\n  /** The global configuration options for Elements. Can be overridden when getting a descriptor */\n  private readonly _globalConfigOptions: ConfigOptionsNormalized;\n\n  /** Cache manager for Matcher instances, unique for each different configuration */\n  private readonly _matchersCache = new MatchersCache();\n\n  /** Micromatch instances for pattern matching */\n  private readonly _micromatchWithCache = new Micromatch(true);\n  private readonly _micromatchWithoutCache = new Micromatch(false);\n\n  /**\n   * Creates a new Elements instance\n   * @param configOptions The global configuration options for Elements. Can be overridden when getting a descriptor.\n   */\n  constructor(configOptions?: ConfigOptions) {\n    const globalConfig = new Config(configOptions);\n    this._globalConfigOptions = globalConfig.options;\n  }\n\n  /**\n   * Returns a serialized representation of the current state of the cache.\n   * @returns A serialized representation of the cache.\n   */\n  public serializeCache(): ElementsSerializedCache {\n    const matchersCache = Array.from(\n      this._matchersCache.getAll().entries()\n    ).reduce(\n      (acc, [key, cache]) => {\n        acc[key] = {\n          config: cache.config,\n          elementDescriptors: cache.elementDescriptors,\n          cache: cache.matcher.serializeCache(),\n        };\n        return acc;\n      },\n      {} as ElementsSerializedCache[\"matchers\"]\n    );\n\n    const micromatchCache = this._micromatchWithCache.serializeCache();\n\n    return {\n      matchers: matchersCache,\n      micromatch: micromatchCache,\n    };\n  }\n\n  /**\n   * Sets the Elements cache from a serialized representation.\n   * @param serializedCache The serialized cache to set.\n   */\n  public setCacheFromSerialized(\n    serializedCache: ElementsSerializedCache\n  ): void {\n    this._micromatchWithCache.setFromSerialized(serializedCache.micromatch);\n    for (const key in serializedCache.matchers) {\n      const matcher = this.getMatcher(\n        serializedCache.matchers[key].elementDescriptors,\n        serializedCache.matchers[key].config\n      );\n      matcher.setCacheFromSerialized(serializedCache.matchers[key].cache);\n      this._matchersCache.set(key, {\n        config: serializedCache.matchers[key].config,\n        elementDescriptors: serializedCache.matchers[key].elementDescriptors,\n        matcher: matcher,\n      });\n    }\n  }\n\n  /**\n   * Clears cache\n   */\n  public clearCache(): void {\n    for (const { matcher } of this._matchersCache.getAll().values()) {\n      matcher.clearCache();\n    }\n    this._matchersCache.clear();\n    this._micromatchWithCache.clearCache();\n  }\n\n  /**\n   * Gets a Matcher instance for the given configuration options.\n   * It uses caching to return the same instance for the same configuration options. If no options are provided, the global configuration options are used.\n   * @param elementDescriptors The element descriptors to use.\n   * @param config Optional configuration options to override the global ones.\n   * @returns A matcher instance, unique for each different configuration.\n   */\n  public getMatcher(\n    elementDescriptors: ElementDescriptors,\n    config?: ConfigOptions\n  ): Matcher {\n    const optionsToUse = config || this._globalConfigOptions;\n    const configInstance = new Config(optionsToUse);\n    const cacheIsEnabled = configInstance.cache;\n    const configOptionsNormalized = configInstance.options;\n    const descriptorNormalizedOptions = configInstance.descriptorOptions;\n    const matchersNormalizedOptions = configInstance.matchersOptions;\n\n    const cacheKey = this._matchersCache.getKey({\n      config: configOptionsNormalized,\n      elementDescriptors,\n    });\n\n    if (this._matchersCache.has(cacheKey)) {\n      return this._matchersCache.get(cacheKey)!.matcher;\n    }\n\n    const micromatch = cacheIsEnabled\n      ? this._micromatchWithCache\n      : this._micromatchWithoutCache;\n\n    const elementsMatcher = new ElementsMatcher(\n      matchersNormalizedOptions,\n      micromatch\n    );\n    const dependenciesMatcher = new DependenciesMatcher(\n      elementsMatcher,\n      matchersNormalizedOptions,\n      micromatch\n    );\n\n    const matcher = new Matcher(\n      elementDescriptors,\n      elementsMatcher,\n      dependenciesMatcher,\n      descriptorNormalizedOptions,\n      micromatch\n    );\n\n    this._matchersCache.set(cacheKey, {\n      config: configOptionsNormalized,\n      elementDescriptors,\n      matcher,\n    });\n    return matcher;\n  }\n}\n"],"mappings":";;;;;;;;AAQO,IAAM,SAAN,MAAa;AAAA;AAAA,EAED;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjB,YAAY,SAAyB;AACnC,SAAK,eAAe,SAAS;AAC7B,SAAK,gBAAgB,SAAS;AAC9B,SAAK,mBAAmB,SAAS,mBAAmB;AACpD,SAAK,SAAS,SAAS,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,UAAmC;AAC5C,WAAO;AAAA,MACL,aAAa,KAAK;AAAA,MAClB,cAAc,KAAK;AAAA,MACnB,iBAAiB,KAAK;AAAA,MACtB,OAAO,KAAK;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,oBAAiD;AAC1D,WAAO;AAAA,MACL,aAAa,KAAK;AAAA,MAClB,cAAc,KAAK;AAAA,MACnB,OAAO,KAAK;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,kBAA6C;AACtD,WAAO;AAAA,MACL,iBAAiB,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,QAAiB;AAC1B,WAAO,KAAK;AAAA,EACd;AACF;;;AClEA,OAAO,gBAAgB;;;ACKhB,SAAS,SAAS,OAAiC;AACxD,SAAO,OAAO,UAAU;AAC1B;AAOO,SAAS,UAAU,OAA2C;AACnE,SAAO,UAAU,QAAQ,UAAU;AACrC;AAOO,SAAS,OAAO,OAA+B;AACpD,SAAO,UAAU;AACnB;AAOO,SAAS,UAAU,OAAkC;AAC1D,SAAO,OAAO,UAAU;AAC1B;AAOO,SAAS,SAAS,OAAkD;AACzE,SACE,CAAC,UAAU,KAAK,KAChB,CAAC,UAAU,KAAK,KAChB,CAAC,QAAQ,KAAK,KACd,OAAO,UAAU;AAErB;AAOO,SAAS,cAAc,KAAuB;AACnD,SAAO,SAAS,GAAG,KAAK,OAAO,KAAK,GAAG,EAAE,WAAW;AACtD;AAOO,SAAS,QAAQ,OAAoC;AAC1D,SAAO,MAAM,QAAQ,KAAK;AAC5B;AAOO,SAAS,aAAa,KAA2B;AACtD,SAAO,IAAI,WAAW;AACxB;AAOO,SAAS,cAAc,OAAmC;AAC/D,SAAO,QAAQ,KAAK,KAAK,MAAM,MAAM,QAAQ;AAC/C;AAQO,SAAS,qBACd,OACA,KACyD;AACzD,SAAO,SAAS,KAAK,KAAK,OAAO,OAAO,OAAO,GAAG;AACpD;AAQO,SAAS,4BACd,OACA,MAC0D;AAC1D,SAAO,SAAS,KAAK,KAAK,KAAK,KAAK,CAAC,QAAQ,OAAO,KAAK;AAC3D;;;ACjFO,SAAS,yBACd,OACiC;AACjC,MAAI,CAAC,SAAS,KAAK,KAAK,QAAQ,KAAK,GAAG;AACtC,WAAO;AAAA,EACT;AAGA,SAAO,OAAO,OAAO,KAAK,EAAE;AAAA,IAC1B,CAAC,YAAY,SAAS,OAAO,KAAK,cAAc,OAAO;AAAA,EACzD;AACF;AAOO,SAAS,8BACd,OACsC;AACtC,SAAO,SAAS,KAAK;AACvB;AAOO,SAAS,0BACd,OAC8B;AAC9B,SAAO,4BAA4B,OAAO;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAOO,SAAS,sBACd,OAC8B;AAC9B,SACE,0BAA0B,KAAK,KAC/B,4BAA4B,OAAO;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAEL;AAOO,SAAS,mCACd,OACqC;AACrC,SACE,QAAQ,KAAK,MACX,MAAM,WAAW,KACjB,8BAA8B,MAAM,CAAC,CAAC;AAAA,EAEtC,yBAAyB,MAAM,CAAC,CAAC;AAAA,EAEhC,MAAM,WAAW,KAAK,8BAA8B,MAAM,CAAC,CAAC;AAEnE;AAOO,SAAS,kBAAkB,OAA0C;AAC1E,SACE,8BAA8B,KAAK,KACnC,sBAAsB,KAAK,KAC3B,mCAAmC,KAAK;AAE5C;AAOO,SAAS,mBAAmB,OAA2C;AAC5E,SACE,kBAAkB,KAAK,KACtB,QAAQ,KAAK,KAAK,CAAC,aAAa,KAAK,KAAK,MAAM,MAAM,iBAAiB;AAE5E;AAOO,SAAS,qBACd,OAC6B;AAC7B,SAAO,4BAA4B,OAAO,CAAC,QAAQ,IAAI,CAAC;AAC1D;AAOO,SAAS,yCACd,OACuE;AACvE,SACE,qBAAqB,OAAO,MAAM,MACjC,SAAS,MAAM,IAAI,KAAK,cAAc,MAAM,IAAI;AAErD;AAOO,SAAS,+CACd,OACoE;AACpE,SACE,qBAAqB,OAAO,YAAY,KAAK,cAAc,MAAM,UAAU;AAE/E;AAOO,SAAS,iCACd,OACyC;AACzC,SACE,yCAAyC,KAAK,KAC9C,+CAA+C,KAAK;AAExD;AAOO,SAAS,qCACd,OAC6C;AAC7C,SACE,QAAQ,KAAK,KACb,MAAM,WAAW,KACjB,8BAA8B,MAAM,CAAC,CAAC,KACtC,iCAAiC,MAAM,CAAC,CAAC;AAE7C;AAOO,SAAS,0BACd,OACkC;AAClC,SACE,8BAA8B,KAAK,KACnC,qCAAqC,KAAK;AAE9C;AAOO,SAAS,4BACd,OACoC;AACpC,SACE,0BAA0B,KAAK,KAC9B,QAAQ,KAAK,KACZ,CAAC,aAAa,KAAK,KACnB,MAAM,MAAM,yBAAyB;AAE3C;;;AFpMA,IAAM,4BAA4B;AAClC,IAAM,wBAAwB;AAa9B,SAAS,kBAAkB,UAAgD;AACzE,MAAI,8BAA8B,QAAQ,GAAG;AAC3C,WAAO,EAAE,MAAM,SAAS;AAAA,EAC1B;AAEA,MAAI,sBAAsB,QAAQ,GAAG;AACnC,WAAO,EAAE,GAAG,SAAS;AAAA,EACvB;AAEA,MAAI,mCAAmC,QAAQ,GAAG;AAChD,WAAO;AAAA,MACL,MAAM,SAAS,CAAC;AAAA,MAChB,UAAU,SAAS,CAAC,IAAI,EAAE,GAAG,SAAS,CAAC,EAAE,IAAI;AAAA,IAC/C;AAAA,EACF;AACA,QAAM,IAAI,MAAM,0BAA0B;AAC5C;AAaO,SAAS,0BACd,kBACuB;AACvB,MAAI,QAAQ,gBAAgB,GAAG;AAC7B,QAAI,mCAAmC,gBAAgB,GAAG;AACxD,aAAO,CAAC,kBAAkB,gBAAgB,CAAC;AAAA,IAC7C;AACA,WAAO,iBAAiB,IAAI,CAAC,QAAQ,kBAAkB,GAAG,CAAC;AAAA,EAC7D;AACA,SAAO,CAAC,kBAAkB,gBAAgB,CAAC;AAC7C;AAKO,IAAM,sBAAN,MAA0B;AAAA;AAAA;AAAA;AAAA,EAIZ;AAAA;AAAA;AAAA;AAAA,EAKT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOV,YAAY,QAAmCA,aAAwB;AACrE,SAAK,aAAaA;AAClB,SAAK,mBAAmB,OAAO;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,gCAAgC,UAA0B;AAChE,WAAO,SAAS,WAAW,uBAAuB,UAAU;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,sBAAsB,UAA2B;AACvD,WAAO,0BAA0B,KAAK,QAAQ;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,qBACN,UACA,cACQ;AACR,UAAM,gBAAgB,KAAK,mBACvB,KAAK,gCAAgC,QAAQ,IAC7C;AACJ,QAAI,CAAC,KAAK,sBAAsB,aAAa,GAAG;AAE9C,aAAO;AAAA,IACT;AAEA,UAAM,mBAAmB,WAAW,QAAQ,aAAa;AAEzD,WAAO,iBAAiB,YAAY;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,qBACR,UACA,cACmB;AACnB,QAAI,QAAQ,QAAQ,GAAG;AACrB,aAAO,SAAS,IAAI,CAAC,SAAS;AAC5B,eAAO,KAAK,qBAAqB,MAAM,YAAY;AAAA,MACrD,CAAC;AAAA,IACH;AACA,WAAO,KAAK,qBAAqB,UAAU,YAAY;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,kBACR,OACA,SACS;AAET,UAAM,sBACJ,CAAC,SAAS,CAAC,SAAS,KAAK,IAAI,OAAO,KAAK,IAAI;AAE/C,UAAM,uBAAuB,QAAQ,OAAO,IACxC,QAAQ,OAAO,OAAO,IACtB;AAEJ,WAAO,KAAK,WAAW,QAAQ,qBAAqB,oBAAoB;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,0BACR,SACA,cACA,OACS;AAET,QAAI,UAAU,KAAK,GAAG;AACpB,aAAO;AAAA,IACT;AAEA,UAAM,kBAAkB,KAAK,qBAAqB,SAAS,YAAY;AAGvE,QAAI,CAAC,iBAAiB;AACpB,aAAO;AAAA,IACT;AAGA,UAAM,kBAAkB,QAAQ,eAAe,IAC3C,gBAAgB,OAAO,OAAO,IAC9B;AAEJ,QAAI,QAAQ,KAAK,GAAG;AAElB,aAAO,MAAM,KAAK,CAAC,QAAQ,KAAK,kBAAkB,KAAK,eAAe,CAAC;AAAA,IACzE;AACA,WAAO,KAAK,kBAAkB,OAAO,eAAe;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,yBAGR;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA;AAAA,EACF,GASY;AAEV,QAAI,EAAE,eAAe,WAAW;AAC9B,aAAO;AAAA,IACT;AAGA,QAAI,EAAE,cAAc,UAAU;AAC5B,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,UAAU,SAAS,WAAW,CAAC,KAAK,CAAC,UAAU,QAAQ,UAAU,CAAC,GAAG;AACxE,aAAO;AAAA,IACT;AACA,WACG,SAAS,WAAW,MAAmB,QAAQ,UAAU;AAAA,EAE9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,4BAGR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAuBY;AAEV,QAAI,EAAE,eAAe,WAAW;AAC9B,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,eAAe;AAClB,aAAO;AAAA,IACT;AAGA,QAAI,CAAC,qBAAqB,SAAS,UAAU,GAAG;AAC9C,aAAO;AAAA,IACT;AAEA,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA,QAAQ,UAAU;AAAA,IACpB;AAAA,EACF;AACF;;;AGpTO,IAAM,sBAAN,cAAkC,oBAAoB;AAAA;AAAA;AAAA;AAAA,EAI1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASjB,YACE,iBACA,QACAC,aACA;AACA,UAAM,QAAQA,WAAU;AACxB,SAAK,mBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,6BACN,UACA,4BAC8B;AAC9B,QAAI,CAAC,qBAAqB,QAAQ,GAAG;AACnC,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AACA,QAAI,gCAAgC,SAAS,KACzC,0BAA0B,SAAS,EAAE,IACrC;AAEJ,QAAI,+BAA+B;AACjC,sCAAgC,8BAA8B;AAAA,QAC5D,CAAC,gBAAgB;AACf,iBAAO;AAAA,YACL,GAAG;AAAA,YACH,GAAG;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,MAAM,SAAS,OAAO,0BAA0B,SAAS,IAAI,IAAI;AAAA,MACjE,IAAI;AAAA,IACN;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,+DACN,UACqB;AACrB,UAAM,eAA6C,CAAC;AAEpD,QAAI,SAAS,MAAM;AACjB,mBAAa,OAAO,SAAS;AAAA,IAC/B;AAEA,QAAI,SAAS,UAAU;AACrB,mBAAa,WAAW,SAAS;AAAA,IACnC;AAEA,QAAI,SAAS,MAAM;AACjB,mBAAa,OAAO,SAAS;AAAA,IAC/B;AAEA,QAAI,SAAS,aAAa;AACxB,mBAAa,cAAc,SAAS;AAAA,IACtC;AAEA,QAAI,SAAS,cAAc;AACzB,mBAAa,eAAe,SAAS;AAAA,IACvC;AAEA,QAAI,SAAS,UAAU;AACrB,mBAAa,WAAW,SAAS;AAAA,IACnC;AAEA,QAAI,SAAS,QAAQ;AACnB,mBAAa,SAAS,SAAS;AAAA,IACjC;AAEA,QAAI,SAAS,YAAY;AACvB,mBAAa,aAAa,SAAS;AAAA,IACrC;AAEA,QAAI,SAAS,QAAQ;AACnB,mBAAa,SAAS,SAAS;AAAA,IACjC;AAEA,QAAI,CAAC,UAAU,SAAS,SAAS,GAAG;AAClC,mBAAa,YAAY,SAAS;AAAA,IACpC;AAEA,QAAI,CAAC,UAAU,SAAS,SAAS,GAAG;AAClC,mBAAa,YAAY,SAAS;AAAA,IACpC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,qBACN,YACA,UACA,cACuB;AACvB,UAAM,0BACJ,MAA4C;AAC1C,iBAAW,oBAAoB,SAAS,MAAO;AAC7C,cAAM,YAAY,KAAK,iBAAiB;AAAA,UACtC,WAAW;AAAA,UACX;AAAA,UACA;AAAA,YACE,mBAAmB;AAAA,UACrB;AAAA,QACF;AACA,cAAM,4BAA4B,KAAK;AAAA,UACrC;AAAA,UACA,CAAC,gBAAgB;AAAA,UACjB;AAAA,QACF;AACA,YAAI,aAAa,2BAA2B;AAC1C,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEF,UAAM,wBAAwB,MAA4C;AACxE,iBAAW,kBAAkB,SAAS,IAAK;AACzC,cAAM,UAAU,0BAA0B,cAAc,IACpD,KAAK,iBAAiB;AAAA,UACpB,WAAW;AAAA,UACX,KAAK;AAAA,YACH;AAAA,UACF;AAAA,UACA;AAAA,YACE,mBAAmB;AAAA,UACrB;AAAA,QACF,IACA;AACJ,cAAM,4BAA4B,KAAK;AAAA,UACrC;AAAA,UACA,CAAC,cAAc;AAAA,UACf;AAAA,QACF;AACA,YAAI,WAAW,2BAA2B;AACxC,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,UAAM,uBAAuB,SAAS,OAClC,wBAAwB,IACxB;AACJ,UAAM,qBAAqB,SAAS,KAAK,sBAAsB,IAAI;AAEnE,WAAO;AAAA,MACL,MAAM;AAAA,MACN,IAAI;AAAA,MACJ,SAAS;AAAA,SACN,SAAS,OAAO,uBAAuB,UACrC,SAAS,KAAK,qBAAqB;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,qBACN,UACA,cACA,cACS;AACT,QAAI,CAAC,SAAS,cAAc;AAC1B,aAAO;AAAA,IACT;AACA,WAAO,KAAK;AAAA,MACV,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,aACN,UACA,MACA,cACS;AACT,QAAI,CAAC,SAAS,MAAM;AAClB,aAAO;AAAA,IACT;AACA,WAAO,KAAK,0BAA0B,SAAS,MAAM,cAAc,IAAI;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBACN,UACA,YACA,cACS;AACT,QAAI,CAAC,SAAS,YAAY;AACxB,aAAO;AAAA,IACT;AACA,WAAO,KAAK;AAAA,MACV,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,iBACN,UACA,UACA,cACS;AACT,QAAI,CAAC,SAAS,UAAU;AACtB,aAAO;AAAA,IACT;AACA,WAAO,KAAK;AAAA,MACV,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,+BACN,YACA,cACA,cACS;AACT,WAAO,aAAa;AAAA,MAAK,CAAC,iBACxB,KAAK;AAAA,QACH;AAAA,QACA,WAAW,WAAW,aAAa;AAAA,QACnC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,6BACN,YACA,YACA,cACS;AAET,UAAM,iBAAiB,WAAW;AAClC,UAAM,iBAAiB,eAAe,aAAa;AACnD,UAAM,OAAO,eAAe;AAC5B,UAAM,WAAW,eAAe;AAChC,UAAM,aAAa,eAAe;AAGlC,eAAW,gBAAgB,YAAY;AAGrC,UACE,KAAK,aAAa,cAAc,MAAM,YAAY,KAClD,KAAK,iBAAiB,cAAc,UAAU,YAAY,KAC1D,KAAK,qBAAqB,cAAc,gBAAgB,YAAY,KACpE,KAAK,kBAAkB,cAAc,YAAY,YAAY,GAC7D;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,qBACL,YACA,UACA;AAAA,IACE,oBAAoB,CAAC;AAAA,IACrB,6BAA6B,CAAC;AAAA,EAChC,IAAoB,CAAC,GACE;AACvB,UAAM,qBAAqB,KAAK;AAAA,MAC9B;AAAA,MACA;AAAA,IACF;AAEA,UAAM,gBAAgB,kBAAkB,QAAQ,CAAC;AACjD,UAAM,cAAc,kBAAkB,MAAM,CAAC;AAG7C,UAAM,eAA6B;AAAA,MACjC,GAAG;AAAA,MACH,MAAM;AAAA,QACJ,GAAG,WAAW;AAAA,QACd,cAAc,WAAW,WAAW,aAAa;AAAA,QACjD,GAAG;AAAA,MACL;AAAA,MACA,IAAI;AAAA,QACF,GAAG,WAAW;AAAA,QACd,cAAc,WAAW,WAAW,aAAa;AAAA,QACjD,MAAM,WAAW,WAAW;AAAA,QAC5B,UAAU,WAAW,WAAW;AAAA,QAChC,YAAY,WAAW,WAAW;AAAA,QAClC,GAAG;AAAA,MACL;AAAA,IACF;AAEA,UAAM,SAAS,KAAK;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,kBACL,YACA,UACA,SACS;AACT,UAAM,cAAc,KAAK;AAAA,MACvB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,YAAY;AAAA,EACrB;AACF;;;ACrZO,IAAM,kBAAN,cAA8B,oBAAoB;AAAA;AAAA,EAEtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQjB,YAAY,QAAmCC,aAAwB;AACrE,UAAM,QAAQA,WAAU;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,aACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,iBACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,aACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,oBACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,qBACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,eACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,mBACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,eACN,SACA,UACA,cACS;AACT,WAAO,KAAK,4BAA4B;AAAA,MACtC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,eAAe,SAAS;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,uBACN,SACA,UACA,cACS;AACT,QAAI,CAAC,SAAS,YAAY,cAAc,SAAS,QAAQ,GAAG;AAC1D,aAAO;AAAA,IACT;AACA,QAAI,CAAC,QAAQ,UAAU;AACrB,aAAO;AAAA,IACT;AAGA,eAAW,CAAC,KAAK,OAAO,KAAK,OAAO,QAAQ,SAAS,QAAQ,GAAG;AAC9D,YAAM,eAAe,QAAQ,WAAW,GAAG;AAC3C,UAAI,CAAC,cAAc;AACjB,eAAO;AAAA,MACT;AAEA,YAAM,kBAAkB,KAAK,qBAAqB,SAAS,YAAY;AAEvE,UAAI,CAAC,iBAAiB;AACpB,eAAO;AAAA,MACT;AAGA,YAAM,kBAAkB,QAAQ,eAAe,IAC3C,gBAAgB,OAAO,OAAO,IAC9B;AAEJ,YAAM,UAAU,KAAK,WAAW,QAAQ,cAAc,eAAe;AAErE,UAAI,CAAC,SAAS;AACZ,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,gBACN,SACA,UACS;AACT,WAAO,KAAK,yBAAyB;AAAA,MACnC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,gBACN,SACA,UACS;AACT,WAAO,KAAK,yBAAyB;AAAA,MACnC;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,qBACN,SACA,eACA,mBAC4B;AAC5B,UAAM,eAA6B;AAAA,MACjC;AAAA,MACA,GAAG;AAAA,IACL;AAEA,eAAW,gBAAgB,eAAe;AAGxC,UACE,CAAC,KAAK,aAAa,SAAS,cAAc,YAAY,KACtD,CAAC,KAAK,iBAAiB,SAAS,cAAc,YAAY,KAC1D,CAAC,KAAK,eAAe,SAAS,cAAc,YAAY,KACxD,CAAC,KAAK,gBAAgB,SAAS,YAAY,KAC3C,CAAC,KAAK,gBAAgB,SAAS,YAAY,KAC3C,CAAC,KAAK,aAAa,SAAS,cAAc,YAAY,KACtD,CAAC,KAAK,oBAAoB,SAAS,cAAc,YAAY,KAC7D,CAAC,KAAK,qBAAqB,SAAS,cAAc,YAAY,KAC9D,CAAC,KAAK,eAAe,SAAS,cAAc,YAAY,KACxD,CAAC,KAAK,mBAAmB,SAAS,cAAc,YAAY,KAC5D,CAAC,KAAK,uBAAuB,SAAS,cAAc,YAAY,GAChE;AACA;AAAA,MACF;AAGA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,oBACL,SACA,UACA,EAAE,oBAAoB,CAAC,EAAE,IAAoB,CAAC,GAClB;AAC5B,UAAM,gBAAgB,0BAA0B,QAAQ;AACxD,WAAO,KAAK,qBAAqB,SAAS,eAAe,iBAAiB;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,eACL,SACA,UACA,SACS;AACT,UAAM,mBAAmB,KAAK;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,CAAC,UAAU,gBAAgB;AAAA,EACpC;AACF;;;ACnXO,IAAM,+BAA+B;AAAA;AAAA,EAE1C,QAAQ;AAAA;AAAA,EAER,MAAM;AAAA;AAAA,EAEN,MAAM;AACR;AA2HO,IAAM,sBAAsB;AAAA;AAAA,EAEjC,OAAO;AAAA;AAAA,EAEP,UAAU;AAAA;AAAA,EAEV,MAAM;AACR;;;AC1GO,SAAS,wBACd,OACgC;AAChC,SACE,SAAS,KAAK,KACd,OAAO,OAAO,4BAA4B,EAAE;AAAA,IAC1C;AAAA,EACF;AAEJ;AAOO,SAAS,2BACd,OACmC;AACnC,SACE,SAAS,KAAK,KACb,QAAQ,KAAK,KAAK,CAAC,aAAa,KAAK,KAAK,MAAM,MAAM,QAAQ;AAEnE;AAOO,SAAS,wBACd,OACgC;AAChC,SACE,qBAAqB,OAAO,SAAS,KACrC,2BAA2B,MAAM,OAAO;AAE5C;AAOO,SAAS,4BACd,OACoC;AACpC,SACE,wBAAwB,KAAK,KAC7B,qBAAqB,OAAO,MAAM,KAClC,SAAS,MAAM,IAAI;AAEvB;AAOO,SAAS,gCACd,OACwC;AACxC,SACE,wBAAwB,KAAK,KAC7B,qBAAqB,OAAO,UAAU,KACtC,SAAS,MAAM,QAAQ;AAE3B;AAOO,SAAS,oBACd,OAC4B;AAC5B,SACE,4BAA4B,KAAK,KAAK,gCAAgC,KAAK;AAE/E;AAOO,SAAS,cAAc,OAAsC;AAClE,SACE,qBAAqB,OAAO,MAAM,KAClC,qBAAqB,OAAO,UAAU,KACtC,qBAAqB,OAAO,MAAM,KAClC,qBAAqB,OAAO,UAAU,KACtC,qBAAqB,OAAO,QAAQ,KACpC,qBAAqB,OAAO,WAAW,KACvC,qBAAqB,OAAO,WAAW;AAE3C;AAOO,SAAS,iBAAiB,OAAyC;AACxE,SACE,cAAc,KAAK,KACnB,qBAAqB,OAAO,WAAW,KACvC,MAAM,cAAc;AAExB;AAOO,SAAS,eACd,OACkD;AAClD,SAAO,cAAc,KAAK,KAAK,MAAM,WAAW,oBAAoB;AACtE;AAOO,SAAS,sBACd,OAC8B;AAC9B,SAAO,eAAe,KAAK,KAAK,MAAM,cAAc;AACtD;AAOO,SAAS,oBACd,OAC4B;AAC5B,SAAO,eAAe,KAAK,KAAK,MAAM,cAAc;AACtD;AAOO,SAAS,+BACd,OACuC;AACvC,SACE,cAAc,KAAK,KACnB,qBAAqB,OAAO,QAAQ,KACpC,SAAS,MAAM,MAAM;AAEzB;AAOO,SAAS,qBACd,OAC6B;AAC7B,SACE,iBAAiB,KAAK,KACtB,sBAAsB,KAAK,KAC3B,oBAAoB,KAAK,KACzB,+BAA+B,KAAK;AAExC;AAOO,SAAS,yBACd,OACiC;AACjC,SAAO,+BAA+B,KAAK,KAAK,eAAe,KAAK;AACtE;AAOO,SAAS,4BACd,OACoC;AACpC,SACE,+BAA+B,KAAK,KACpC,MAAM,WAAW,oBAAoB,YACrC,qBAAqB,OAAO,YAAY,KACxC,SAAS,MAAM,UAAU;AAE7B;AAOO,SAAS,wBACd,OACgC;AAChC,SACE,+BAA+B,KAAK,KACpC,MAAM,WAAW,oBAAoB,QACrC,qBAAqB,OAAO,YAAY,KACxC,SAAS,MAAM,UAAU;AAE7B;;;ACtPO,IAAM,uBAAuB;AAC7B,IAAM,wBAAwB;AAC9B,IAAM,yBAAyB;AAG/B,IAAM,uBAAuB;AAAA;AAAA,EAElC,MAAM;AAAA;AAAA,EAGN,OAAO;AAAA;AAAA,EAGP,SAAS;AACX;AAOO,IAAM,+BAA+B;AAAA;AAAA,EAE1C,UAAU;AAAA;AAAA,EAEV,OAAO;AAAA;AAAA,EAEP,YAAY;AAAA;AAAA,EAEZ,SAAS;AAAA;AAAA,EAET,QAAQ;AAAA;AAAA,EAER,OAAO;AAAA;AAAA,EAEP,QAAQ;AAAA;AAAA,EAER,UAAU;AACZ;AAEO,IAAM,wCAAwC;AAAA,EACnD,CAAC,6BAA6B,QAAQ,GACpC,6BAA6B;AAAA,EAC/B,CAAC,6BAA6B,KAAK,GAAG,6BAA6B;AAAA,EACnE,CAAC,6BAA6B,UAAU,GACtC,6BAA6B;AAAA,EAC/B,CAAC,6BAA6B,OAAO,GAAG,6BAA6B;AAAA,EACrE,CAAC,6BAA6B,MAAM,GAAG,6BAA6B;AAAA,EACpE,CAAC,6BAA6B,KAAK,GAAG,6BAA6B;AAAA,EACnE,CAAC,6BAA6B,MAAM,GAAG,6BAA6B;AAAA,EACpE,CAAC,6BAA6B,QAAQ,GACpC,6BAA6B;AACjC;;;ACtCO,SAAS,iBAAiB,OAAyC;AACxE,SACE,SAAS,KAAK,KACd,OAAO,OAAO,oBAAoB,EAAE,SAAS,KAAuB;AAExE;AAOO,SAAS,yBACd,OACiC;AACjC,SACE,SAAS,KAAK,KACd,OAAO,OAAO,4BAA4B,EAAE;AAAA,IAC1C;AAAA,EACF;AAEJ;AAOO,SAAS,oCACd,OACiC;AACjC,SACE,qBAAqB,OAAO,IAAI,MAC/B,OAAO,MAAM,EAAE,KAAK,yBAAyB,MAAM,EAAE,MACtD,qBAAqB,OAAO,MAAM,MACjC,OAAO,MAAM,IAAI,KAAK,yBAAyB,MAAM,IAAI;AAE9D;AAOO,SAAS,yBACd,OACiC;AACjC,SACE,qBAAqB,OAAO,MAAM,KAClC,iBAAiB,MAAM,IAAI,KAC3B,qBAAqB,OAAO,cAAc,KAC1C,oCAAoC,MAAM,YAAY,KACtD,qBAAqB,OAAO,UAAU,MACrC,OAAO,MAAM,QAAQ,KAAK,SAAS,MAAM,QAAQ;AAEtD;AAOO,SAAS,wBACd,OACgC;AAChC,SACE,qBAAqB,OAAO,IAAI,KAChC,qBAAqB,MAAM,EAAE,KAC7B,qBAAqB,OAAO,MAAM,KAClC,qBAAqB,MAAM,IAAI,KAC/B,qBAAqB,OAAO,YAAY,KACxC,yBAAyB,MAAM,UAAU;AAE7C;AAOO,SAAS,qBACd,YACS;AACT,SACE,WAAW,WAAW,aAAa,OACnC,6BAA6B;AAEjC;;;ACnGO,IAAM,eAAN,MAA+D;AAAA;AAAA;AAAA;AAAA,EAInD;AAAA;AAAA;AAAA;AAAA,EAKjB,cAAc;AACZ,SAAK,SAAS,oBAAI,IAAyB;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,YAAY,KAAuB;AAC3C,QAAI,SAAS,GAAG,GAAG;AACjB,aAAO;AAAA,IACT;AACA,UAAM,eACJ,uGACA,KAAK,UAAU,GAAG;AACpB,UAAM,IAAI,MAAM,YAAY;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,OAAO,KAAuB;AACnC,WAAO,KAAK,YAAY,GAAG;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,WAA4C;AACrD,WAAO,KAAK,OAAO,IAAI,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,WAAmB,OAA0B;AACtD,SAAK,OAAO,IAAI,WAAW,KAAK;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,WAA4B;AACrC,WAAO,KAAK,OAAO,IAAI,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,SAAmC;AACxC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKO,QAAc;AACnB,SAAK,OAAO,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,YAAyC;AAC9C,WAAO,MAAM,KAAK,KAAK,OAAO,EAAE,QAAQ,CAAC,EAAE;AAAA,MACzC,CAAC,KAAK,CAAC,KAAK,KAAK,MAAM;AACrB,YAAI,GAAG,IAAI;AACX,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,kBAAkB,iBAAoD;AAC3E,eAAW,OAAO,iBAAiB;AACjC,WAAK,IAAI,KAAK,gBAAgB,GAAG,CAAC;AAAA,IACpC;AAAA,EACF;AACF;;;ACvGO,IAAM,uBAAN,cAGG,aAAoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOrC,OAAO,MAAwB;AACpC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,IAAI,YAA6C;AACtD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,IAAI,YAAoB,QAA2B;AACxD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,IAAI,YAA6B;AACtC,WAAO;AAAA,EACT;AACF;;;ACvCO,IAAM,gCAAN,cAA4C,aAGjD;AAAA;AAAA;AAAA;AAAA;AAAA,EAKU,YAAY,SAOX;AACT,WAAO,GAAG,QAAQ,IAAI,IAAI,QAAQ,EAAE,IAAI,QAAQ,MAAM,IAAI,QAAQ,IAAI,IACpE,QAAQ,QACV,IAAI,QAAQ,aAAa,QAAQ,WAAW,KAAK,GAAG,IAAI,EAAE;AAAA,EAC5D;AACF;;;ACJO,IAAM,yBAAN,MAA6B;AAAA;AAAA;AAAA;AAAA,EAIjB;AAAA;AAAA;AAAA;AAAA,EAOA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,YACE,oBACA,QACA;AACA,SAAK,sBAAsB;AAC3B,SAAK,UAAU;AACf,SAAK,qBAAqB,KAAK,QAAQ,QACnC,IAAI,8BAA8B,IAClC,IAAI,qBAGF;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,iBAAwD;AAC7D,WAAO,KAAK,mBAAmB,UAAU;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,uBACL,iBACM;AACN,SAAK,mBAAmB,kBAAkB,eAAe;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKO,aAAmB;AACxB,SAAK,mBAAmB,MAAM;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,WAAW,aAAgC;AACjD,WAAO,YAAY,QAAQ,CAAC,GAAG;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,mBACN,cACA,cACA;AACA,UAAM,iBAAiB,aAAa,QAAQ,KAAK,CAAC,mBAAmB;AACnE,aAAO,aAAa,QAAQ,KAAK,CAAC,mBAAmB;AACnD,eAAO,eAAe,gBAAgB,eAAe;AAAA,MACvD,CAAC;AAAA,IACH,CAAC;AACD,WAAO,gBAAgB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,sBACN,UACA,UACA;AACA,UAAM,iBAAiB,KAAK,mBAAmB,UAAU,QAAQ;AACjE,WAAO,kBAAkB,mBAAmB,KAAK,WAAW,QAAQ;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,WAAW,UAA6B,UAA6B;AAC3E,UAAM,UAAU,KAAK,WAAW,QAAQ;AACxC,UAAM,UAAU,KAAK,WAAW,QAAQ;AACxC,WAAO,WAAW,WAAW,YAAY;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,cACN,UACA,UACA;AACA,WAAO,SAAS,QAAQ;AAAA,MACtB,CAAC,WAAW,OAAO,gBAAgB,SAAS;AAAA,IAC9C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,SAAS,UAA6B,UAA6B;AACzE,WAAO,KAAK,WAAW,QAAQ,MAAM,SAAS;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YACN,UACA,UACA;AACA,WAAO,SAAS,gBAAgB,SAAS;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,wBACN,SACA,YACA;AACA,QACE,iBAAiB,UAAU,KAC3B,CAAC,oBAAoB,UAAU,KAC/B,CAAC,oBAAoB,OAAO,GAC5B;AACA,aAAO;AAAA,IACT;AACA,QAAI,KAAK,YAAY,YAAY,OAAO,GAAG;AACzC,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,SAAS,YAAY,OAAO,GAAG;AACtC,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,cAAc,YAAY,OAAO,GAAG;AAC3C,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,WAAW,YAAY,OAAO,GAAG;AACxC,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,SAAS,SAAS,UAAU,GAAG;AACtC,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,cAAc,SAAS,UAAU,GAAG;AAC3C,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,sBAAsB,YAAY,OAAO,GAAG;AACnD,aAAO,6BAA6B;AAAA,IACtC;AACA,QAAI,KAAK,sBAAsB,SAAS,UAAU,GAAG;AACnD,aAAO,6BAA6B;AAAA,IACtC;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,yBACN,SACA,YACA;AACA,UAAM,iBAAiB,KAAK,wBAAwB,SAAS,UAAU;AACvE,UAAM,mBAAmB,iBACrB,sCAAsC,cAAc,IACpD;AACJ,WAAO;AAAA,MACL,MAAM;AAAA,MACN,IAAI;AAAA,IACN;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,mBAAmB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAAqD;AACnD,UAAM,WAAW,KAAK,mBAAmB,OAAO;AAAA,MAC9C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AACD,QAAI,KAAK,mBAAmB,IAAI,QAAQ,GAAG;AACzC,aAAO,KAAK,mBAAmB,IAAI,QAAQ;AAAA,IAC7C;AAEA,UAAM,cAAc,KAAK,oBAAoB,gBAAgB,IAAI;AACjE,UAAM,YAAY,KAAK,oBAAoB;AAAA,MACzC;AAAA,MACA;AAAA,IACF;AAEA,UAAM,SAAS;AAAA,MACb,MAAM;AAAA,MACN,IAAI;AAAA,MACJ,YAAY;AAAA,QACV;AAAA,QACA,UAAU,YAAY;AAAA,QACtB,cAAc,KAAK,yBAAyB,aAAa,SAAS;AAAA,QAClE,YAAY,cAAc;AAAA,MAC5B;AAAA,IACF;AAEA,SAAK,mBAAmB,IAAI,UAAU,MAAM;AAE5C,WAAO;AAAA,EACT;AACF;;;ACzRA,OAAO,kBAAkB;AA8BzB,IAAM,kBAAuC;AAAA,EAC3C,MAAM;AAAA,EACN,aAAa;AAAA,EACb,cAAc;AAAA,EACd,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AAAA,EACV,QAAQ,oBAAoB;AAAA,EAC5B,WAAW;AAAA,EACX,WAAW;AACb;AAgBA,IAAM,uBAAuB;AAC7B,IAAM,sBAAsB;AAKrB,IAAM,qBAAN,MAAyB;AAAA,EACtB,OAA0B;AAAA;AAAA;AAAA;AAAA,EAIjB;AAAA;AAAA;AAAA;AAAA,EAOA;AAAA;AAAA;AAAA;AAAA,EAOA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA,EAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASjB,YACE,oBACA,eACAC,aACA;AACA,SAAK,cAAcA;AACnB,SAAK,sBAAsB;AAC3B,SAAK,qBAAqB,kBAAkB;AAC5C,SAAK,UAAU;AACf,SAAK,cAAc,KAAK,QAAQ,QAC5B,IAAI,aAAkC,IACtC,IAAI,qBAA0C;AAClD,SAAK,qBAAqB,KAAK,QAAQ,QACnC,IAAI,aAAyC,IAC7C,IAAI,qBAAiD;AACzD,SAAK,kBAAkB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,iBAAoD;AACzD,WAAO;AAAA,MACL,cAAc,KAAK,mBAAmB,UAAU;AAAA,MAChD,OAAO,KAAK,YAAY,UAAU;AAAA,IACpC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,uBACL,iBACM;AACN,SAAK,mBAAmB,kBAAkB,gBAAgB,YAAY;AACtE,SAAK,YAAY,kBAAkB,gBAAgB,KAAK;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKO,aAAmB;AACxB,SAAK,mBAAmB,MAAM;AAC9B,SAAK,YAAY,MAAM;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAA0B;AAEhC,QACE,CAAC,KAAK,QACN,CAAC,UAAU,OAAO,KAClB,CAAC,UAAU,QAAQ,QAAQ,KAC3B,CAAC,UAAU,QAAQ,SAAS,IAAI,GAChC;AAEA,WAAK,OAAO,UAAQ,QAAa;AAAA,IACnC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAAqB,oBAA8C;AACzE,QAAI,QAAQ;AACZ,eAAW,cAAc,oBAAoB;AAC3C,UAAI,CAAC,oBAAoB,UAAU,GAAG;AACpC,cAAM,IAAI;AAAA,UACR,+BAA+B,KAAK;AAAA,QACtC;AAAA,MACF;AACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,8BACN,kBACA,sBACS;AAET,QAAI,KAAK,MAAM;AACb,YAAM,0BAA0B,qBAAqB,WAAW,OAAO,IACnE,qBAAqB,MAAM,CAAC,IAC5B;AACJ,aAAO,KAAK,KAAK,eAAe,SAAS,uBAAuB;AAAA,IAClE;AAEA,WAAO,aAAa,gBAAgB;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,0BAA0B,kBAAmC;AACnE,WAAO,qBAAqB,KAAK,gBAAgB;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,oCACN,kBACS;AACT,WACE,oBAAoB,KAAK,gBAAgB,KACzC,KAAK,0BAA0B,gBAAgB;AAAA,EAEnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,mCAAmC,kBAAkC;AAC3E,QAAI,KAAK,0BAA0B,gBAAgB,GAAG;AACpD,YAAM,CAAC,OAAO,WAAW,IAAI,iBAAiB,MAAM,GAAG;AACvD,aAAO,GAAG,KAAK,IAAI,WAAW;AAAA,IAChC;AACA,UAAM,CAAC,GAAG,IAAI,iBAAiB,MAAM,GAAG;AACxC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,sBACN,UACA,kBACS;AACT,YACG,CAAC,YAAY,SAAS,SAAS,cAAc;AAAA,KAE7C,CAAC,oBACA,KAAK,oCAAoC,gBAAgB;AAAA,EAE/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,gBAAgB,aAA8B;AACpD,QAAI;AAEJ,QAAI,KAAK,QAAQ,gBAAgB,KAAK,QAAQ,aAAa;AACzD,YAAM,aAAa,KAAK,YAAY;AAAA,QAClC;AAAA,QACA,KAAK,QAAQ;AAAA,MACf;AACA,YAAM,YAAY,KAAK,YAAY;AAAA,QACjC;AAAA,QACA,KAAK,QAAQ;AAAA,MACf;AACA,eAAS,cAAc,CAAC;AAAA,IAC1B,WAAW,KAAK,QAAQ,cAAc;AACpC,eAAS,KAAK,YAAY,QAAQ,aAAa,KAAK,QAAQ,YAAY;AAAA,IAC1E,WAAW,KAAK,QAAQ,aAAa;AACnC,eAAS,CAAC,KAAK,YAAY,QAAQ,aAAa,KAAK,QAAQ,WAAW;AAAA,IAC1E,OAAO;AACL,eAAS;AAAA,IACX;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,mBACN,UACA,eACuB;AACvB,QAAI,CAAC,eAAe;AAClB,aAAO;AAAA,IACT;AACA,WAAO,SAAS,OAAO,CAAC,gBAAgB,cAAc,UAAU;AAC9D,UAAI,cAAc,KAAK,GAAG;AACxB,uBAAe,cAAc,KAAK,CAAC,IAAI;AAAA,MACzC;AACA,aAAO;AAAA,IACT,GAAG,CAAC,CAAmB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,gBACN,aACA,cACA,iBACQ;AACR,UAAM,oBAAoB,KAAK,YAAY,OAAO,WAAW;AAE7D,UAAM,iBAA2B,CAAC;AAClC,QAAI;AAEJ,eAAW,eAAe,cAAc;AACtC,qBAAe,KAAK,WAAW;AAC/B,YAAM,iBAAiB,eAAe,KAAK,GAAG;AAC9C,UAAI,kBAAkB,KAAK,cAAc,GAAG;AAC1C,iBAAS;AACT;AAAA,MACF;AAAA,IACF;AAEA,WAAO,GAAG,CAAC,GAAG,eAAe,EAAE,QAAQ,EAAE,KAAK,GAAG,EAAE,MAAM,MAAO,EAAE,CAAC,CAAC,GAAG,MAAM;AAAA,EAC/E;AAAA,EAeQ,qBAAqB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAME;AACA,UAAM,OAAO,wBAAwB,kBAAkB,IAAI,IACvD,kBAAkB,OAClB,6BAA6B;AAEjC,UAAM,WAAW,QAAQ,kBAAkB,OAAO,IAC9C,kBAAkB,UAClB,CAAC,kBAAkB,OAAO;AAE9B,eAAW,WAAW,UAAU;AAC9B,YAAM,mBACJ,SAAS,6BAA6B,QAAQ,CAAC;AACjD,YAAM,mBACJ,SAAS,6BAA6B,UAAU,CAAC,iBAC7C,GAAG,OAAO,UACV;AAEN,YAAM,aAAa,mBACf,WACA,oBAAoB,KAAK,GAAG;AAEhC,UAAI,cAA+B;AACnC,UAAI,aAAa;AAEjB,UAAI,kBAAkB,aAAa;AACjC,cAAM,aAAa,SAChB,MAAM,GAAG,EACT,MAAM,GAAG,SAAS,MAAM,GAAG,EAAE,SAAS,uBAAuB,EAC7D,KAAK,GAAG;AACX,sBAAc,KAAK,YAAY;AAAA,UAC7B,CAAC,kBAAkB,aAAa,MAAM,gBAAgB,EAAE,KAAK,GAAG;AAAA,UAChE;AAAA,QACF;AACA,qBAAa,gBAAgB;AAAA,MAC/B;AAEA,YAAM,UAAU,KAAK,YAAY,QAAQ,kBAAkB,UAAU;AAErE,UAAI,WAAW,YAAY;AACzB,eAAO;AAAA,UACL,SAAS;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA,UACA,aAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAEA,WAAO,EAAE,SAAS,MAAM;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,oBAAoB,UAAgC;AAE1D,QAAI,CAAC,UAAU;AACb,aAAO;AAAA,QACL,GAAG;AAAA,MACL;AAAA,IACF;AAGA,QAAI,CAAC,KAAK,gBAAgB,QAAQ,GAAG;AACnC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,MAAM;AAAA,QACN,WAAW;AAAA,QACX,QAAQ;AAAA,MACV;AAAA,IACF;AAEA,UAAM,UAAwC,CAAC;AAC/C,UAAM,gBAA4C;AAAA,MAChD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU;AAAA,MACV,QAAQ,oBAAoB;AAAA,MAC5B,WAAW;AAAA,IACb;AAOA,UAAM,QAAe;AAAA,MACnB,yBAAyB,CAAC;AAAA,MAC1B,yBAAyB;AAAA,IAC3B;AAEA,UAAM,eAAe,SAAS,MAAM,GAAG,EAAE,QAAQ;AAEjD,UAAM,sBAAsB,CAC1B,mBACA,WAOA,qBACA,iBACG;AACH,YAAM,EAAE,SAAS,aAAa,kBAAkB,YAAY,IAAI;AAEhE,UAAI,iBAAiB,KAAK;AAAA,QACxB;AAAA,QACA,kBAAkB;AAAA,MACpB;AAEA,UAAI,kBAAkB,eAAe,aAAa;AAChD,yBAAiB;AAAA,UACf,GAAG,KAAK;AAAA,YACN;AAAA,YACA,kBAAkB;AAAA,UACpB;AAAA,UACA,GAAG;AAAA,QACL;AAAA,MACF;AAEA,YAAM,cAAc,mBAChB,WACA,KAAK,gBAAgB,aAAa,qBAAqB,YAAY;AAEvE,UAAI,CAAC,cAAc,QAAQ,CAAC,cAAc,UAAU;AAClD,cAAM,OACJ,kBAAkB,QAAQ,6BAA6B;AAEzD,sBAAc,OAAO,kBAAkB,QAAQ;AAC/C,sBAAc,WAAW,kBAAkB,YAAY;AACvD,sBAAc,YAAY;AAC1B,sBAAc,cAAc;AAC5B,sBAAc,WAAW;AACzB,sBAAc,eACZ,SAAS,6BAA6B,UACtC,aAAa,cACT,SAAS,QAAQ,GAAG,WAAW,KAAK,EAAE,IACtC,SAAS,MAAM,GAAG,EAAE,IAAI;AAAA,MAChC,OAAO;AAEL,gBAAQ,KAAK;AAAA,UACX,MAAM,kBAAkB,QAAQ;AAAA,UAChC,UAAU,kBAAkB,YAAY;AAAA,UACxC;AAAA,UACA,UAAU;AAAA,QACZ,CAAC;AAAA,MACH;AAAA,IACF;AAGA,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,YAAM,UAAU,aAAa,CAAC;AAC9B,YAAM,wBAAwB,QAAQ,OAAO;AAG7C,YAAM,wBACJ,QAAQ,cAAc,IAAI,KAAK,QAAQ,cAAc,QAAQ;AAE/D,iBAAW,qBAAqB,KAAK,qBAAqB;AACxD,cAAM,QAAQ,KAAK,qBAAqB;AAAA,UACtC;AAAA,UACA;AAAA,UACA,qBAAqB,MAAM;AAAA,UAC3B,yBAAyB,MAAM;AAAA,UAC/B,gBAAgB;AAAA,QAClB,CAAC;AAED,YAAI,MAAM,SAAS;AACjB;AAAA,YACE;AAAA,YACA;AAAA,YACA,MAAM;AAAA,YACN;AAAA,UACF;AACA,gBAAM,0BAA0B,CAAC;AACjC,gBAAM,0BAA0B,IAAI;AAGpC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,SAAS,EAAE,GAAG,eAAe,QAAQ;AAG3C,QAAI,CAAC,oBAAoB,MAAM,GAAG;AAChC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,MAAM;AAAA,MACR;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,cAAc,UAAgC;AACpD,UAAM,WAAW,KAAK,YAAY,OAAO,OAAO,QAAQ,CAAC;AACzD,QAAI,KAAK,YAAY,IAAI,QAAQ,GAAG;AAClC,aAAO,KAAK,YAAY,IAAI,QAAQ;AAAA,IACtC;AACA,UAAM,cAAc,KAAK,oBAAoB,QAAQ;AACrD,SAAK,YAAY,IAAI,UAAU,WAAW;AAC1C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,oCACN,kBACA,UAC0D;AAC1D,UAAM,uBACJ,KAAK,mCAAmC,gBAAgB;AAG1D,UAAM,SAAS,KAAK;AAAA,MAClB;AAAA,MACA;AAAA,IACF;AAEA,QAAI,QAAQ;AACV,YAAM,cAAqC;AAAA,QACzC,GAAG;AAAA,QACH,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,QAAQ,oBAAoB;AAAA,MAC9B;AACA,aAAO;AAAA,IACT;AAEA,UAAM,aAAa,KAAK;AAAA,MACtB,YAAY;AAAA,MACZ;AAAA,IACF;AAEA,QAAI,YAAY;AACd,YAAM,kBAA6C;AAAA,QACjD,GAAG;AAAA,QACH,MAAM,YAAY;AAAA,QAClB,cAAc,iBAAiB,QAAQ,sBAAsB,EAAE;AAAA,QAC/D,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,QAAQ,oBAAoB;AAAA,MAC9B;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAeQ,iBACN,UACA,kBACoB;AACpB,UAAM,WAAW,GAAG,OAAO,gBAAgB,CAAC,KAAK,OAAO,QAAQ,CAAC;AACjE,QAAI,KAAK,mBAAmB,IAAI,QAAQ,GAAG;AACzC,aAAO,KAAK,mBAAmB,IAAI,QAAQ;AAAA,IAC7C;AAEA,UAAM,kCAAkC,mBACpC,KAAK,oCAAoC,kBAAkB,QAAQ,IACnE;AAEJ,QAAI,iCAAiC;AACnC,WAAK,mBAAmB,IAAI,UAAU,+BAA+B;AACrE,aAAO;AAAA,IACT;AAEA,UAAM,kBAAkB,KAAK,cAAc,QAAQ;AACnD,UAAM,gBAAgB,mBAClB;AAAA,MACE,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,IACA;AAEJ,SAAK,mBAAmB,IAAI,UAAU,aAAa;AACnD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAgB,UAAgC;AACrD,WAAO,KAAK,iBAAiB,QAAQ;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,0BACL,kBACA,UAC8B;AAC9B,WAAO,KAAK,iBAAiB,UAAU,gBAAgB;AAAA,EACzD;AACF;;;ACtqBO,IAAM,cAAN,MAAkB;AAAA,EACN;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,YACE,oBACA,QACAC,aACA;AACA,SAAK,sBAAsB,IAAI;AAAA,MAC7B;AAAA,MACA;AAAA,MACAA;AAAA,IACF;AACA,SAAK,0BAA0B,IAAI;AAAA,MACjC,KAAK;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,iBAA6C;AAClD,WAAO;AAAA,MACL,UAAU,KAAK,oBAAoB,eAAe;AAAA,MAClD,cAAc,KAAK,wBAAwB,eAAe;AAAA,IAC5D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,uBACL,iBACM;AACN,SAAK,oBAAoB,uBAAuB,gBAAgB,QAAQ;AACxE,SAAK,wBAAwB;AAAA,MAC3B,gBAAgB;AAAA,IAClB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,aAAmB;AACxB,SAAK,oBAAoB,WAAW;AACpC,SAAK,wBAAwB,WAAW;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAgB,UAAgC;AACrD,WAAO,KAAK,oBAAoB,gBAAgB,QAAQ;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,0BACL,kBACA,UAC8B;AAC9B,WAAO,KAAK,oBAAoB;AAAA,MAC9B;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,mBACL,SACuB;AACvB,WAAO,KAAK,wBAAwB,mBAAmB,OAAO;AAAA,EAChE;AACF;;;ACjFO,IAAM,UAAN,MAAc;AAAA,EACF;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUjB,YACE,aACA,iBACA,qBACA,QACAC,aACA;AACA,SAAK,eAAe,IAAI,YAAY,aAAa,QAAQA,WAAU;AACnE,SAAK,mBAAmB;AACxB,SAAK,uBAAuB;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,gBACN,UACA,UACA,SACS;AACT,UAAM,cAAc,KAAK,aAAa,gBAAgB,QAAQ;AAC9D,WAAO,KAAK,iBAAiB,eAAe,aAAa,UAAU,OAAO;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,mBACN,gBACA,UACA,SACS;AACT,UAAM,cAAc,KAAK,aAAa,mBAAmB,cAAc;AACvE,WAAO,KAAK,qBAAqB;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAkBO,QACL,mBACA,UACA,SACS;AACT,QAAI,SAAS,iBAAiB,GAAG;AAC/B,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,4BACN,UACA,UACA,SACA;AACA,UAAM,cAAc,KAAK,aAAa,gBAAgB,QAAQ;AAC9D,WAAO,KAAK,iBAAiB;AAAA,MAC3B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,+BACN,gBACA,UACA,SACA;AACA,UAAM,cAAc,KAAK,aAAa,mBAAmB,cAAc;AACvE,WAAO,KAAK,qBAAqB;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAmBO,oBACL,mBACA,UACA,SACoD;AACpD,QAAI,SAAS,iBAAiB,GAAG;AAC/B,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAmBO,+BACL,aACA,UACA,SACoD;AACpD,QAAI,mBAAmB,QAAQ,KAAK,qBAAqB,WAAW,GAAG;AACrE,aAAO,KAAK,iBAAiB;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,WACE,qBAAqB,QAAQ,KAC7B,wBAAwB,WAAW,GACnC;AACA,aAAO,KAAK,qBAAqB;AAAA,QAC/B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAgB,UAAkB;AACvC,WAAO,KAAK,aAAa,gBAAgB,QAAQ;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,0BACL,kBACA,UACA;AACA,WAAO,KAAK,aAAa;AAAA,MACvB;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,mBAAmB,SAAoC;AAC5D,WAAO,KAAK,aAAa,mBAAmB,OAAO;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKO,aAAa;AAClB,SAAK,aAAa,WAAW;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,iBAAyC;AAC9C,WAAO;AAAA,MACL,aAAa,KAAK,aAAa,eAAe;AAAA,IAChD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,uBAAuB,iBAE3B;AACD,SAAK,aAAa,uBAAuB,gBAAgB,WAAW;AAAA,EACtE;AACF;;;ACjTA,OAAO,gBAAgB;AAkBvB,IAAM,uBAAN,cAAmC,aAGjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMU,YAAY,EAAE,OAAO,QAAQ,GAAoC;AACzE,WAAO,GAAG,KAAK,KAAK,QAAQ,OAAO,IAAI,QAAQ,KAAK,GAAG,IAAI,OAAO;AAAA,EACpE;AACF;AAaA,IAAM,qBAAN,cAAiC,aAG/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMU,YAAY,EAAE,SAAS,OAAO,GAAkC;AACxE,WAAO,GAAG,OAAO,IAAI,MAAM;AAAA,EAC7B;AACF;AAMO,IAAM,aAAN,MAAiB;AAAA;AAAA;AAAA;AAAA,EAIL;AAAA;AAAA;AAAA;AAAA,EAOA,iBAGf,IAAI,qBAA6D;AAAA;AAAA;AAAA;AAAA,EAKlD,eACf,IAAI,qBAAqC;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3C,YAAY,OAAgB;AAC1B,SAAK,wBAAwB,QACzB,IAAI,qBAAqB,IACzB,IAAI,qBAAuD;AAC/D,SAAK,iBAAiB,QAClB,IAAI,mBAAmB,IACvB,IAAI,qBAA6D;AACrE,SAAK,eAAe,QAChB,IAAI,aAA6B,IACjC,IAAI,qBAAqC;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKO,aAAmB;AACxB,SAAK,sBAAsB,MAAM;AACjC,SAAK,eAAe,MAAM;AAC1B,SAAK,aAAa,MAAM;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,iBAA4C;AACjD,WAAO;AAAA,MACL,iBAAiB,KAAK,sBAAsB,UAAU;AAAA,MACtD,UAAU,KAAK,eAAe,UAAU;AAAA,IAC1C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,kBAAkB,iBAAkD;AACzE,SAAK,sBAAsB;AAAA,MACzB,gBAAgB;AAAA,IAClB;AACA,SAAK,eAAe,kBAAkB,gBAAgB,QAAQ;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,QAAQ,OAAe,SAAqC;AACjE,UAAM,WAAW,KAAK,sBAAsB,OAAO;AAAA,MACjD;AAAA,MACA;AAAA,IACF,CAAC;AAED,QAAI,KAAK,sBAAsB,IAAI,QAAQ,GAAG;AAC5C,aAAO,KAAK,sBAAsB,IAAI,QAAQ;AAAA,IAChD;AAEA,UAAM,UAAU,WAAW,QAAQ,OAAO,OAAO;AACjD,SAAK,sBAAsB,IAAI,UAAU,OAAO;AAChD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,QAAQ,SAAiB,QAAiC;AAC/D,UAAM,WAAW,KAAK,eAAe,OAAO,EAAE,SAAS,OAAO,CAAC;AAE/D,QAAI,KAAK,eAAe,IAAI,QAAQ,GAAG;AACrC,aAAO,KAAK,eAAe,IAAI,QAAQ;AAAA,IACzC;AAEA,UAAM,SAAS,WAAW,QAAQ,SAAS,MAAM;AACjD,SAAK,eAAe,IAAI,UAAU,MAAM;AACxC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,OAAO,SAAyB;AACrC,QAAI,KAAK,aAAa,IAAI,OAAO,GAAG;AAClC,aAAO,KAAK,aAAa,IAAI,OAAO;AAAA,IACtC;AACA,UAAM,SAAS,WAAW,OAAO,OAAO;AACxC,SAAK,aAAa,IAAI,SAAS,MAAM;AACrC,WAAO;AAAA,EACT;AACF;;;AC9KO,IAAM,gBAAN,cAA4B,aAUjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMU,YAAY;AAAA,IACpB;AAAA,IACA;AAAA,EACF,GAGW;AACT,UAAM,aAAa,GAAG,OAAO,eAAe,IAAI,OAAO,YAAY,IAAI,OAAO,WAAW,IACvF,OAAO,KACT;AAEA,UAAM,yBAAyB,mBAC5B;AAAA,MACC,CAAC,eACC,GAAG,WAAW,IAAI,IAAI,WAAW,QAAQ,IAAI,WAAW,OAAO,IAAI,WAAW,WAAW,IAAI,WAAW,IAAI,IAAI,WAAW,OAAO,IAAI,WAAW,WAAW;AAAA,IAChK,EACC,KAAK,GAAG;AACX,WAAO,GAAG,UAAU,MAAM,sBAAsB;AAAA,EAClD;AACF;;;AC3BO,IAAM,WAAN,MAAe;AAAA;AAAA,EAEH;AAAA;AAAA,EAGA,iBAAiB,IAAI,cAAc;AAAA;AAAA,EAGnC,uBAAuB,IAAI,WAAW,IAAI;AAAA,EAC1C,0BAA0B,IAAI,WAAW,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAM/D,YAAY,eAA+B;AACzC,UAAM,eAAe,IAAI,OAAO,aAAa;AAC7C,SAAK,uBAAuB,aAAa;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,iBAA0C;AAC/C,UAAM,gBAAgB,MAAM;AAAA,MAC1B,KAAK,eAAe,OAAO,EAAE,QAAQ;AAAA,IACvC,EAAE;AAAA,MACA,CAAC,KAAK,CAAC,KAAK,KAAK,MAAM;AACrB,YAAI,GAAG,IAAI;AAAA,UACT,QAAQ,MAAM;AAAA,UACd,oBAAoB,MAAM;AAAA,UAC1B,OAAO,MAAM,QAAQ,eAAe;AAAA,QACtC;AACA,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAEA,UAAM,kBAAkB,KAAK,qBAAqB,eAAe;AAEjE,WAAO;AAAA,MACL,UAAU;AAAA,MACV,YAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,uBACL,iBACM;AACN,SAAK,qBAAqB,kBAAkB,gBAAgB,UAAU;AACtE,eAAW,OAAO,gBAAgB,UAAU;AAC1C,YAAM,UAAU,KAAK;AAAA,QACnB,gBAAgB,SAAS,GAAG,EAAE;AAAA,QAC9B,gBAAgB,SAAS,GAAG,EAAE;AAAA,MAChC;AACA,cAAQ,uBAAuB,gBAAgB,SAAS,GAAG,EAAE,KAAK;AAClE,WAAK,eAAe,IAAI,KAAK;AAAA,QAC3B,QAAQ,gBAAgB,SAAS,GAAG,EAAE;AAAA,QACtC,oBAAoB,gBAAgB,SAAS,GAAG,EAAE;AAAA,QAClD;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,aAAmB;AACxB,eAAW,EAAE,QAAQ,KAAK,KAAK,eAAe,OAAO,EAAE,OAAO,GAAG;AAC/D,cAAQ,WAAW;AAAA,IACrB;AACA,SAAK,eAAe,MAAM;AAC1B,SAAK,qBAAqB,WAAW;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,WACL,oBACA,QACS;AACT,UAAM,eAAe,UAAU,KAAK;AACpC,UAAM,iBAAiB,IAAI,OAAO,YAAY;AAC9C,UAAM,iBAAiB,eAAe;AACtC,UAAM,0BAA0B,eAAe;AAC/C,UAAM,8BAA8B,eAAe;AACnD,UAAM,4BAA4B,eAAe;AAEjD,UAAM,WAAW,KAAK,eAAe,OAAO;AAAA,MAC1C,QAAQ;AAAA,MACR;AAAA,IACF,CAAC;AAED,QAAI,KAAK,eAAe,IAAI,QAAQ,GAAG;AACrC,aAAO,KAAK,eAAe,IAAI,QAAQ,EAAG;AAAA,IAC5C;AAEA,UAAMC,cAAa,iBACf,KAAK,uBACL,KAAK;AAET,UAAM,kBAAkB,IAAI;AAAA,MAC1B;AAAA,MACAA;AAAA,IACF;AACA,UAAM,sBAAsB,IAAI;AAAA,MAC9B;AAAA,MACA;AAAA,MACAA;AAAA,IACF;AAEA,UAAM,UAAU,IAAI;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,IACF;AAEA,SAAK,eAAe,IAAI,UAAU;AAAA,MAChC,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AACF;","names":["micromatch","micromatch","micromatch","micromatch","micromatch","micromatch","micromatch"]}